docno="lists-005-15154140"
received="Sat Dec 23 00:02:02 2000"
isoreceived="20001223050202"
sent="Sat, 23 Dec 2000 00:01:15 -0500 (EST)"
isosent="20001223050115"
name="Geoffrey M. Clemm"
email="geoffrey.clemm@rational.com"
subject="Re: Subversion support"
id="200012230501.AAA09432@tantalum.atria.com"
inreplyto="20001222014646.B22947&#64;lyra.org"
expires="-1"


To:ietf-dav-versioning@w3.org


   From: Greg Stein <gstein@lyra.org>

   SVN can do a copy-by-reference, so they're cheap as hell. I can label
   something simply by doing:

     COPY http://www.lyra.org/svn/project
     Destination: http://www.lyra.org/svn/labels/1.0a1

According to the protocol, that would create a bunch of new
non-version-controlled resources.  They could be automatically put
under version control, but then as far as the protocol is concerned,
they would be completely unrelated to the resources that they came
from (i.e. changes couldn't be merged back to /svn/project).

I believe the most interoperable way of marshalling this in
the versioning protocol so that you could merge changes back
would be:

     REPORT /svn/project
     Host: www.lyra.org
     <D:property-report>
       <D:baseline-selector>
         <D:checked-in/>        ; (used to be D:target)
       </D:baseline-selector>
     </D:property-report>

; This gets you the current baseline (aka Subversion "repository revision")
of your project.
      

     BASELINE-CONTROL /svn/labels/1.0a1
     <D:baseline-control>
       <D:baseline> http://whatever-came-back-from-REPORT
       </D:baseline>
     </D:baseline-control>

In other words, you "instantiate" a baseline in a baseline-controlled
collection whenever you want to expose that baseline as a namespace. 

   Assuming nobody monkeys in the 1.0a1 tree, it will reflect the state of
   "/svn/project" at the time of the COPY. Of course, we can also apply a
   simple ACL to prevent that monkeying (but then again: we might want to apply
   fixes to the alpha).

   That said, I think we might do labels in the classic RCS/CVS sense simply
   for the user-model aspect. That's why I'm tentative with labels. I think
   we'd like to keep them as copies, but it can be a funny model for some
   people.

   "how do I see my labels?" "well, go over to that part of the tree" "oh, is
   that 'labels' subtree part of the system?" "nah... we just picked that... it
   is a policy choice" "WTF?!" :-)

Well, if they want to "slash through" the names of the labeled copy,
they pretty much have to instantiate it somewhere in the namespace.

But I agree that they probably don't want to instantiate all their
labels as copies in the namespace (even if subversion can do it
cheaply :-), so I guess I'll withdraw my objection to labels, as long
as they are used on baselines (which I believe is the only place
subversion would place them?) and not on individual file versions.

Cheers,
Geoff



