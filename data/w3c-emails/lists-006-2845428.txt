docno="lists-006-2845428"
received="Tue Jun 19 15:08:34 2001"
isoreceived="20010619190834"
sent="Tue, 19 Jun 2001 15:08:29 -0400"
isosent="20010619190829"
name="Jim Amsden"
email="jamsden@us.ibm.com"
subject="RE: [ietf-dav-versioning] &lt;none&gt;"
id="OF1925F62A.57E4E421-ON85256A70.006814D5@raleigh.ibm.com"
charset="us-ascii"
inreplyto="[ietf-dav-versioning] &lt;none&gt;"
expires="-1"

To:ietf-dav-versioning@w3.org


Geoff says:
Encapsulation is preventing you from seeing the implementation.  That
is exactly what an IETF protocol does ... you can only see and use the
public parts (which are the methods and properties defined by the
protocol).  A public property is as much a part of the type signature
as a public method.  All we are saying is that we should be using type
signature equivalence, rather than type name equivalence, since HTTP
does not provide a "subtype declaration" mechanism, but the versioning
protocol has defined a type signature exposure mechanism
(DAV:supported-method-set and DAV:supported-live-property-set).

Encapsulation can also be used to suppress detail and provide higher level 
abstractions to reduce complexity for some client classes. I agree a 
protocol does present an encapsulation of a server's services in a 
standard way. What we're talking about here is encapsulating the details 
of the protocol itself - we're up a meta-level. HTTP doesn't provide a 
subtype declaration mechanism, but WebDAV does - DAV:resourcetype. I think 
some of us would just like to be able to use it to hide the details and 
name the things in the protocol the way we name them in the specification. 
This, ideally, shouldn't have to be discovered through introspection as it 
requires the introspector to know protocol details that might better be 
handled by the server. Its a many-to-one thing for complexity management. 
You have one server doing the work instead of many clients.



