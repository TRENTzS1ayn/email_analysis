docno="lists-011-10258832"
received="Tue Nov  4 14:18:09 1997"
isoreceived="19971104191809"
sent="Tue, 04 Nov 1997 17:13:22 0500"
isosent="19971104221322"
name="Dave Kristol"
email="dmk@belllabs.com"
subject="Re: Question on byte ranges"
id="345F9E02.30E4F99F@belllabs.com"
charset="usascii"
inreplyto="9711042147.AA07731&#64;acetes.pa.dec.com"
expires="1"


To: Jeffrey Mogul<mogul@pa.dec.com>
Cc: http working group<http-wg%cuckoo.hpl.hp.com@hplb.hpl.hp.com>

Jeffrey Mogul wrote:
> [...]
> (3) Also in section 14.36.1 Byte Ranges, before the paragraph that
> starts "Examples of byte-ranges-specifier values ...", insert this
> paragraph:
> 
>         If a syntactically valid byte-range-set includes at least one
>         byte-range-spec whose first-byte-pos is less than the current
>         length of the entity-body, or at least one
>         suffix-byte-range-spec with a non-zero suffix-length, then the
>         byte-range-set is satisfiable.  Otherwise, the byte-range-set
>         is unsatisfiable.  If the byte-range-set is unsatisfiable, the
>         server SHOULD return a response with a status of 416 (Requested
>         range not satisfiable).  Otherwise, the server SHOULD return a
>         response with a status of 206 (Partial Content) containing the
>         satisfiable ranges of the entity-body.

That's much clearer.  But I think it's backward.  I think 416 should
mean the request (and therefore the client) is buggy.  And if none of
the ranges are satisfiable, return everything (pretend there's no Range
header).  I think it's a little strange to return an error if the Range
header was well-formed and ignore Range if it's ill-formed.

Dave Kristol



