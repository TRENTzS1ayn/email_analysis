docno="lists-012-12515019"
received="Thu Dec 23 12:48:14 1999"
isoreceived="19991223174814"
sent="Thu, 23 Dec 1999 13:44:12 +0100 (MET)"
isosent="19991223124412"
name="Koen Holtman"
email="koen@win.tue.nl"
subject="Re: Clarification on cacheability"
id="199912231244.NAA00813@wsooti28.win.tue.nl"
charset="USASCII"
inreplyto="BFF90FB6CF66D111BF4F0000F840DB850BCBBEE1&#64;lassie.dns.microsoft.com"
expires="1"


To:joshco@Exchange.Microsoft.com(Josh Cohen (Exchange))
Cc:fielding@kiwi.ics.uci.edu,joshco@Exchange.Microsoft.com,http-wg@hplb.hpl.hp.com

Josh Cohen:
>
[...]
>I guess if there is any chance that the response could be different,
>based on client auth, client type, or whatever, then it is not safe to
>cache. 

It _is_ safe to make the response cacheable as long as you use Vary
correctly, this is what Vary was invented for.

>(especially since caches dont filter based on accept before
>returning responses)

As Roy said, most (all?) 1.1 caches don't actually implement the
refined filtering made possible by Vary.  They implement the Vary
requirements in 1.1 by treating 'Vary: anything' as equivalent to
'no-cache'.

But you can still use Vary if you want to help possible future caches:
I would consider this to be good protocol design.  You can find some
examples of the use of Vary+Expires in RFC2295.


Koen.



