docno="lists-012-14924834"
received="Fri Oct  6 17:43:52 2000"
isoreceived="20001006214352"
sent="Fri, 6 Oct 2000 10:42:26 0600"
isosent="20001006164226"
name="Carl Kugler/Boulder/IBM"
email="kugler@us.ibm.com"
subject="RE: Conformance Test for HTTP 1.1"
id="OF7E6356B1.0BFCAEA5ON87256970.005B718E@LocalDomain"
charset="iso-88591"
inreplyto="Conformance Test for HTTP 1.1"
expires="1"

To: Yves Lafon<ylafon@w3.org>
Cc: Miles Sabin<msabin@cromwellmedia.co.uk>,http-wg@cuckoo.hpl.hp.com



Once you have all the pieces for a server, building a client is easy, IMO.
For something driven by scripts, with no GUI, etc, no need to actually
render HTML or graphics, pretty straightforward.  I have done some of this
for test IPP implementations (IPP uses HTTP as its transfer protocol, so
some of the tests I wrote were HTTP specific).  But I used my own HTTP
classes at the time.  The main thing you need is the HTTP parser, which is
pretty much the same on server and client sides.

     -Carl


Yves Lafon <ylafon@w3.org> on 10/06/2000 10:29:54 AM

To:   Carl Kugler/Boulder/IBM@IBMUS
cc:   Miles Sabin <msabin@cromwellmedia.co.uk>, http-wg@cuckoo.hpl.hp.com
Subject:  RE: Conformance Test for HTTP 1.1



On Fri, 6 Oct 2000, Carl Kugler/Boulder/IBM wrote:

>
> One approach might be to build a test framework around Jigsaw objects,
> perhaps driven by JPython scripts for easy testcase development and
> platform independence.

That's what I did (except that some scripts are just plain sh ;) ). But
basically the small test case available at http://jigsaw.w3.org/HTTP/ is
made with some specific Jigsaw filters or configuration (for 406).

But testing means also testing the server, so a client version of the
test is also needed (my first guess was a servlet doing client request
on a server).

--
Yves Lafon - W3C / Jigsaw - XML Protocol - HTTP
"Baroula que barouleras, au ti?u toujou t'entourneras."



