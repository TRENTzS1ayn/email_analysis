docno="lists-012-15011073"
received="Tue Oct 10 16:09:32 2000"
isoreceived="20001010200932"
sent="Tue, 10 Oct 2000 08:57:38 0600"
isosent="20001010145738"
name="Carl Kugler/Boulder/IBM"
email="kugler@us.ibm.com"
subject="Re: Conformance Test for HTTP 1.1"
id="OF81EB3AC9.9AB6D3C6ON87256974.0050A1ED@LocalDomain"
charset="usascii"
inreplyto="Conformance Test for HTTP 1.1"
expires="1"

To:http-wg@cuckoo.hpl.hp.com


Keith wrote:

>Carl,
>
>Once we start doing any kind of compliancy checking we face the proverbial
>"slippery slope".  What comes next?  Seperate tests for things that MAY be
>done according to the specs?  Things that SHOULD be?
>
>I think the best thing to do is stay out of the compliancy checking
business
>all together.
>
>Thanks,
>
>Keith
>
>

MAYs are untestable, by definition  Since MAY is semantically equivalent to
MAY NOT, there is no way to test the hypothesis that an implementation
conforms to the statement.

SHOULDs are also untestable by definition, since an application is allowed
to violate a SHOULD if it has a good reason to.  Since the test writer
can't know whether or not the implementer had a good reason to violate a
SHOULD, SHOULDs can't be used for compliance testing.

Any implementation that meets all the MUSTs is compliant.  That's all that
really matters for compliancy, IMO.  Obviously, this kind of compliancy
test tells you little about the quality of an implementation, but it might
help shake out bugs and misinterpretations.

     -Carl



