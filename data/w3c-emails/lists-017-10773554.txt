docno="lists-017-10773554"
received="Wed Oct  9 04:48:21 2002"
isoreceived="20021009084821"
sent="Wed, 09 Oct 2002 16:22:23 +0900"
isosent="20021009072223"
name="Martin Duerst"
email="duerst@w3.org"
subject="Re: Fwd: validator/httpd/cgibin check"
id="4.2.0.58.J.20021009161733.0571fa40@localhost"
charset="usascii"
inreplyto="1034147254.17160.20.camel&#64;bobcat.ods.org"
expires="1"


To: Ville Skytta<ville.skytta@iki.fi>
Cc:public-qa-dev@w3.org


At 10:07 02/10/09 +0300, Ville Skytt wrote:
>On Wed, 2002-10-09 at 07:05, Martin Duerst wrote:
>
> > Just to make sure that I understand what's going on:
> >
> > my original version was:
> >     return $encodingA && $encodingB && $encodingA ne $encodingB;
>
>Yep, that works.
>
> > your first version was:
> >     return $encodingA && $encodingB and $encodingA ne $encodingB;
>
>No.  That was Terje's change in
><http://dev.w3.org/cvsweb/validator/httpd/cgi-bin/check.diff?r1=1.234&r2=1. 
>235&f=h>, which actually broke things.

Very sorry about that miss-attribution.


> > your current version is:
> >     return (($encodingA && $encodingB) and ($encodingA ne $encodingB));
>
>Yes.  That works again, and uses the "and" Terje seems to love :)
>
> > I think that my original version was correct, yes?
> > I don't understand why you want to make a difference between
> > the first logical 'and' and the second logical 'and', both
> > are equivalent.

I wanted to say that the computation we are trying to do
is just an operation of logical ands of three things,
without any further inherent structure. So there is no
reason to use && in one instance and 'and' in another
instance, and using different operators only clouds
what's going on.

>No, "and" and "&&" are *not* the same in Perl. See man perlop for
>details.  But I agree that I put in too many parens there.  Just for
>fun, try the script at the end of this message for a demonstration about
>the logical and operator precedence.
>
>That's why I personally never use the "and" form.  Mixing "and" and "&&"
>is always IMHO either 1) wrong 2) hard to read correctly.
>
> >     return $encodingA && $encodingB && ($encodingA ne $encodingB);
> >
> > Please change it to your preferred version.
>
>Ok, this one it is.
>
>----------------------------------------------------------------------------
>#!/usr/bin/perl
>
>sub conflict1 {
>   my $encodingA = shift;
>   my $encodingB = shift;
>   return $encodingA && $encodingB && $encodingA ne $encodingB;
>}
>
>sub conflict2 {
>   my $encodingA = shift;
>   my $encodingB = shift;
>   return $encodingA && $encodingB and $encodingA ne $encodingB;
>}
>
>print conflict1('utf-8', 'utf-8') ? "yes c1" : "no c1", "\n";
>print conflict2('utf-8', 'utf-8') ? "yes c2" : "no c2", "\n";

It should say:
no c1
yes c2
because the second one is interpreted as
   (return $encodingA && $encodingB) and $encodingA ne $encodingB;

And that's of course not what we want.
Thanks for finding that bug; I'm not sure I would have found
it easily.

Regards,   Martin.



