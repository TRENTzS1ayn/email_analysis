docno="lists-018-12241557"
received="Thu Jun  5 05:00:25 2003"
isoreceived="20030605090025"
sent="Thu, 5 Jun 2003 11:00:20 +0200 "
isosent="20030605090020"
name="Kay, Michael"
email="Michael.Kay@softwareag.com"
subject="RE: Query use case: dynamically subselecting a sequence of named  elements"
id="DFF2AC9E3583D511A21F0008C7E62106073DCECE@daemsg02.softwareag.de"
inreplyto="Query use case: dynamically subselecting a sequence of named  elements"
expires="1"


To:"'Ellis Cohen'"<e.cohen@acm.org>,public-qt-comments@w3.org


> Suppose the element Stuff were defined as
> 
>    <!ELEMENT Stuff (Thing1, Thing2, ...., Thing99)>
> 
> If $aStuff identified a Stuff element node
> and $parts contained the sequence ('Thing24', 'Thing27', 'Thing82')
> 
> one would be sorely tempted to write  $aStuff/$parts
> to get the corresponding sub-elements of the Stuff node
> 
> That wouldn't work, but how easy would it be write the 
> necessary expression (preferably in XPath alone) given 
> $aStuff and $parts?

This kind of expression is very common in XSLT. The answer is:

  $aStuff/*[name()=$parts]

Michael Kay



