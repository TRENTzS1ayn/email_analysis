docno="lists-018-4034853"
received="Tue Apr 15 09:31:49 2003"
isoreceived="20030415133149"
sent="Tue, 15 Apr 2003 15:31:02 +0200"
isosent="20030415133102"
name="Tobias Reif"
email="tobiasreif@pinkjuice.com"
subject="Re: node-equal(), nodeidentical()"
id="3E9C0996.4020705@pinkjuice.com"
charset="UTF8"
inreplyto="DFF2AC9E3583D511A21F0008C7E62106073DCD6A&#64;daemsg02.softwareag.de"
expires="1"


To:"Kay, Michael"<Michael.Kay@softwareag.com>
CC:public-qt-comments@w3.org


Kay, Michael wrote:

> There will be some renaming and repackaging of these functions in the next
> draft.


I see. I hope my suggestions/requests will be incorporated.


> I think the response to your use case is that you can recurse down the tree
> using deep-equal at each level.


Yes, I already use deep-equal() to test if both trees are equal.

But if they aren't equal, I need to find out the place of the first 
difference; I need to walk through the tree in document order. If I 
would do that using deep-equal(), lots of time would be wasted AFAICS; 
some nodes would be tested hundreds of times, no? The two trees can be 
large so I need to walk the tree only once (in this second optional 
test), and test each node pair only once.

> In fact deep-equal might not help you much,


It seems to work quite well to see if the two trees are equal. Now I 
just need to find out where the test fails if it does.


> you may well be better off programming the tree traversal yourself looking
> for the differences that matter to you.


That's what I want to do for the second more detailed test (which will 
only take place if the trees are not equal). For this, I'd like to walk 
the nodes of both trees and test each pair of corresponding nodes. For 
this, I need some node-equal() function or operator (equality not 
identity, shallow not deep (compare only the two nodes, not trees)).

(I do two steps since a) often, the second one won't be necessary, and 
b) the deep-equal() that's offered by the XSLT processor is likely to be 
much faster than my own traversal routine AFAICS. This can mean that in 
some cases, many node pairs get tested twice, but that's not too much 
overhead; overall, this should be faster, since most often, the second 
test pass won't be required.)

> It's very hard to come up with a
> single definition of deep-equal that suits everyone,


I'm quite happy with the current deep-equal() as implemented in Saxon 
7.4. (but it doesn't solve the problem where I need to find out which 
the first different node is).

What I need is a function node-equal() which compares two nodes for 
equality, not for identity (the latter is the case in the current 
draft), and perhaps also (not for this use-case) a function 
node-identical() which tests for identity.

> and there have been
> some suggestions that we should therefore scrap it


It's useful for me; I am using it, and it works. In this particular 
case, I want to exclude comments and whitespace from being compared, so 
I filter the trees first; no problem.

I would think that since it is a function which is part of the spec, it 
can be implemented to be much faster than a user function written in XSLT.

> and make people write
> their own.


I planned on doing that anyways, but I would still use deep-equal() in 
the first test pass and probably in many other cases. Please don't scrap 
it; it's useful. It could be made even more useful if it (or some 
version) would return the first different node in the second argument tree.

~~~

$tree1 =
<a>
  <b/>
  <c/>
</a>

$tree2 =
<a>
  <b/>
  <c/>
</a>

$tree2_different
<a>
  <b/>
  <d/>
  <c/>
</a>

deep-equal($tree1,$tree2) returns true
deep-equal($tree1,$tree2_different) returns <d/>

or s.th. like

deep-equal($tree1,$tree2) returns true
deep-equal($tree1,$tree2_different) returns false
deep-equal-return-first-difference($tree1,$tree2_different) returns <d/>

But my real request is a function node-equal() which compares two nodes 
for equality, not for identity.

Tobi

-- 
http://www.pinkjuice.com/



