docno="lists-018-9316338"
received="Fri Feb 21 11:38:51 2003"
isoreceived="20030221163851"
sent="Fri, 21 Feb 2003 11:38:17 0500"
isosent="20030221163817"
name="Jonathan Robie"
email="jonathan.robie@datadirecttechnologies.com"
subject="Re: question regarding element types in function   definitions/XQuery"
id="5.2.0.9.0.20030221113042.032c6318@ncmail.datadirecttechnologies.com"
charset="usascii"
inreplyto="001001c2d9c2$5d01b130$0201a8c0&#64;qodfathr"
expires="1"


To:"Todd A. Mancini"<todd.mancini@daxat.com>,<public-qt-comments@w3.org>


At 11:00 AM 2/21/2003 -0500, Todd A. Mancini wrote:

>I know this has been answered in one way or another over the past year
>or so, but I'm still having trouble understanding the specifications as
>the language and semantic specs. don't seem to exactly agree, and the
>publicly available issue resolution is somewhat unreadable.
>
>If I define a function as follows:
>
>define function foo($i as element my:elementdef) { 1 }
>
>does this raise a static type error if I have not imported a schema
>defining element my:elementdef ?

Yes.

>However, if I define a function as follows:
>
>define function foo($i as element my:elementdef of type xs:integer) { 1
>}
>
>does this raise a static type error if I have not imported a schema
>defining element my:elementdef?

I believe the documents currently disagree. We are aware of this, and hope 
to be fixing it in the next drafts.

My favorite answer is that this is *not* a type error. If you specify only 
the element name, then the element name should be used to nominate a type 
based on the schema definition of the element, so if the element name is 
not found, there is a type error - you can't find the type. But if the type 
is given explicitly, then it might be an element in well-formed content 
that has an explicit type given with xsi:type, so a type error seems overly 
restrictive. And you don't need to read the schema to find the type, the 
declaration is telling you that type.

Would you like that answer if the WG could be persuaded to agree with it?

>Conversely, what if I have defined an
>element my:elementdef?  Provided xs:integer is a subtype of the type of
>the globally defined my:elementdef, is this acceptable?  Or, does this
>signature imply that the argument need only have the element name
>my:elementdef, with a type xs:integer, regardless of the existence of
>my:elementdef as a global element definition?

I am beginning to think that the element name is just a name. If no type is 
given explicitly, the element name nominates a type from the in-scope 
schema definitions, or raises a type error if there is no definition for 
the name.

So if the name and type are given explicitly, who cares about the 
definition in the schema - this might be an element for or from a different 
document, or in a merely well-formed portion of the document, or whatever.

>PS: Another difference between the language and semantic specifications
>relates to untyped function arguments and function return values.  The
>language spec has them as xs:anyType whereas the semantic spec has them
>as item*.  Although the difference is subtle, I believe that item*
>matches more values than xs:anyType.  (e.g.  (element foo, attribute
>bar) matches item* but not xs:anyType, whose value space has all
>attributes preceding all elements, assuming I'm correctly interpreting
>3.2.4 in semantic spec.)

Subtle indeed. I have been assuming that xs:anyType and item* really are 
the same.

Jonathan 



