docno="lists-018-9338872"
received="Fri Feb 21 12:09:03 2003"
isoreceived="20030221170903"
sent="Fri, 21 Feb 2003 09:08:31 0800"
isosent="20030221170831"
name="Michael Rys"
email="mrys@microsoft.com"
subject="RE: question regarding element types in function   definitions/XQuery"
id="5C39F806F9939046B4B1AFE652500A3A047AC7C4@RED-MSG10.redmond.corp.microsoft.com"
charset="usascii"
inreplyto="question regarding element types in function   definitions/XQuery"
expires="1"


To:"Jonathan Robie"<jonathan.robie@datadirect-technologies.com>,"Todd A. Mancini"<todd.mancini@daxat.com>,<public-qt-comments@w3.org>


Item also subsumes comment, processing instruction, text etc. xs:anyType
does not.

Best regards
Michael

> -----Original Message-----
> From: Jonathan Robie
[mailto:jonathan.robie@datadirect-technologies.com]
> Sent: Friday, February 21, 2003 8:38 AM
> To: Todd A. Mancini; public-qt-comments@w3.org
> Subject: Re: question regarding element types in function
> definitions/XQuery
> 
> 
> At 11:00 AM 2/21/2003 -0500, Todd A. Mancini wrote:
> 
> >I know this has been answered in one way or another over the past
year
> >or so, but I'm still having trouble understanding the specifications
as
> >the language and semantic specs. don't seem to exactly agree, and the
> >publicly available issue resolution is somewhat unreadable.
> >
> >If I define a function as follows:
> >
> >define function foo($i as element my:elementdef) { 1 }
> >
> >does this raise a static type error if I have not imported a schema
> >defining element my:elementdef ?
> 
> Yes.
> 
> >However, if I define a function as follows:
> >
> >define function foo($i as element my:elementdef of type xs:integer) {
1
> >}
> >
> >does this raise a static type error if I have not imported a schema
> >defining element my:elementdef?
> 
> I believe the documents currently disagree. We are aware of this, and
hope
> to be fixing it in the next drafts.
> 
> My favorite answer is that this is *not* a type error. If you specify
only
> the element name, then the element name should be used to nominate a
type
> based on the schema definition of the element, so if the element name
is
> not found, there is a type error - you can't find the type. But if the
> type
> is given explicitly, then it might be an element in well-formed
content
> that has an explicit type given with xsi:type, so a type error seems
> overly
> restrictive. And you don't need to read the schema to find the type,
the
> declaration is telling you that type.
> 
> Would you like that answer if the WG could be persuaded to agree with
it?
> 
> >Conversely, what if I have defined an
> >element my:elementdef?  Provided xs:integer is a subtype of the type
of
> >the globally defined my:elementdef, is this acceptable?  Or, does
this
> >signature imply that the argument need only have the element name
> >my:elementdef, with a type xs:integer, regardless of the existence of
> >my:elementdef as a global element definition?
> 
> I am beginning to think that the element name is just a name. If no
type
> is
> given explicitly, the element name nominates a type from the in-scope
> schema definitions, or raises a type error if there is no definition
for
> the name.
> 
> So if the name and type are given explicitly, who cares about the
> definition in the schema - this might be an element for or from a
> different
> document, or in a merely well-formed portion of the document, or
whatever.
> 
> >PS: Another difference between the language and semantic
specifications
> >relates to untyped function arguments and function return values.
The
> >language spec has them as xs:anyType whereas the semantic spec has
them
> >as item*.  Although the difference is subtle, I believe that item*
> >matches more values than xs:anyType.  (e.g.  (element foo, attribute
> >bar) matches item* but not xs:anyType, whose value space has all
> >attributes preceding all elements, assuming I'm correctly
interpreting
> >3.2.4 in semantic spec.)
> 
> Subtle indeed. I have been assuming that xs:anyType and item* really
are
> the same.
> 
> Jonathan



