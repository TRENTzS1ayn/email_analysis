docno="lists-019-0303756"
received="Wed May  7 09:38:29 2003"
isoreceived="20030507133829"
sent="Wed, 7 May 2003 14:38:09 +0100"
isosent="20030507133809"
name="David Carlisle"
email="davidc@nag.co.uk"
subject="May F&amp;O: 15.2.1.1 Deep Equality of Nodes"
id="200305071338.OAA32384@penguin.nag.co.uk"
expires="-1"


To:public-qt-comments@w3.org



In comments on earlier drafts I commented that deep-equality ought to be
moved to the user-defined examples appendix as it will almost always be
the case that specific applications need to tweak this definition
to have different behaviour with respect to comments, white space,
in scope namespaces etc etc. 

However whether the definition is moved to the appendix or left as a
core function in this section, there are some XPath corrections.


  if (fn:node-kind($parameter1) ne fn:node-kind($parameter2)) 
  then false
 else


"false" here (and in all the other sections of this definition0
should be fn:false() to return the boolean false rather than the
value obtained by selecting an element called false.


  If the two nodes are text nodes, comment nodes, processing instruction
  nodes, or namespace nodes, then the result is true if and only if the
  two nodes have equal string-values, when compared using the selected
  collation. 
  
  if (some $n in ("text", "comment", "processing-instruction", "namespace")
           satisfies $n eq fn:node-kind($parameter1)
      and fn:compare
          (fn:string($parameter1), fn:string($parameter2), $collation) ne 0)
  then false
  else


the code section only implements half of the "if and only if".
If it is a text, comment, etc node and fn:compare() does return 0
you want to return fn:true() not move on to the else branch (I think)


if (empty($parameter1/*) and empty($parameter2/*))

empty should be fn:empty for consistency.

  Otherwise, the result is true if and only if the children of node
  $parameter1 are pairwise deep-equal to the children of node
  $parameter2, ignoring comment and processing instruction nodes in both
  cases.

this particular choice (ignoring comments) leads to some surprises,
for example if white space stripping is happening eg xsl:strip-space
or equivalents in other methods of building a data model

1: <a> x</a>
2: <a> <!-- -->x</a>
3: <a>x</a>

2 and 3 are equal, but not equal to 1.

and why compare top level comments? If
<x><!-- a --></x> is deep-equal to <x><!-- b --></x> then why not
declare all comments deep-equal so that <!-- a --> is deep-equal
to <!-- b --> for consistency?

David

________________________________________________________________________
This e-mail has been scanned for all viruses by Star Internet. The
service is powered by MessageLabs. For more information on a proactive
anti-virus service working around the clock, around the globe, visit:
http://www.star.net.uk
________________________________________________________________________



