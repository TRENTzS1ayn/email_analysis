docno="lists-019-0451135"
received="Thu May  8 06:58:40 2003"
isoreceived="20030508105840"
sent="Thu, 08 May 2003 12:57:25 +0200"
isosent="20030508105725"
name="Tobias Reif"
email="tobiasreif@pinkjuice.com"
subject="Re: May F&amp;O: 15.2.1.1 Deep Equality of Nodes"
id="3EBA3815.6060005@pinkjuice.com"
charset="us-ascii"
inreplyto="May F&amp;O: 15.2.1.1 Deep Equality of Nodes"
expires="-1"


To:public-qt-comments@w3.org
CC:davidc@nag.co.uk


re
http://lists.w3.org/Archives/Public/public-qt-comments/2003May/0053.html
"In comments on earlier drafts I commented that deep-equality ought to 
be moved to the user-defined examples appendix as it will almost always 
be the case that specific applications need to tweak this definition to 
have different behaviour with respect to comments, white space, in scope 
namespaces etc etc."

I'm using deep-equal() as it is; it's very useful. The requirement you 
describe exists, but doesn't mean that it should cease to be a core 
function.

For example, I'm doing

   ...
   <xsl:variable name="output_filtered_for_comparison">
     <xsl:apply-templates select="$output_raw"
       mode="filter_for_comparison"/>
   </xsl:variable>
   ...
       test="deep-equal(
       $output_filtered_for_comparison,
       $desired_output_filtered_for_comparison
       )">
[1]

I like deep-equal(), leave it in there :)

It's also handy when it can be used as it is, without tweaking or 
filtering; no function needs to be defined, no filters written. People 
can simply use it.

Tobi

[1] the simple and short filter:
<xsl:template priority="1" mode="filter_for_comparison"
match="comment()"/>
<xsl:template mode="filter_for_comparison" match="@* | node()">
   <xsl:copy>
     <xsl:apply-templates mode="filter_for_comparison"
       select="@* | node()"/>
   </xsl:copy>
</xsl:template>
<xsl:template mode="filter_for_comparison"
match="text()[string-length(normalize-space())=0]"/>

-- 
http://www.pinkjuice.com/



