docno="lists-019-3554971"
received="Tue Nov 11 03:38:27 2003"
isoreceived="20031111083827"
sent="Tue, 11 Nov 2003 08:38:22 +0000"
isosent="20031111083822"
name="Jeni Tennison"
email="jeni@jenitennison.com"
subject="Re: Need of another function, any()"
id="271464861970.20031111083822@jenitennison.com"
charset="us-ascii"
inreplyto="20031110153257.41811.qmail&#64;web20701.mail.yahoo.com"
expires="-1"


To: Mukul Gandhi<mukulgw3@yahoo.com>
Cc:public-qt-comments@w3.org


Hi Mukul,

> I am feeling the need of a built-in function, any() in XSLT..
>
> please look, at the following e.g.
>
> <xsl:for-each select="x-path">
>   <xsl:if test="./@a='1' = any()/@='1'">
>   </xsl:if>
> </xsl:for-each>
>
> any() function, would match to any node in the
> preceding-sibling::, and following-sibling::  *axis*
>
> any() function, would be equivalant to (preceding-sibling:: or
> self:: or following-sibling:: )
>
> I am wondering, if this might be appropriate ??

Personally, I don't think so. As you say, the "any()" function, as
you've defined it, doesn't do anything new, just provides a shorthand
for accessing all the sibling nodes of the context node. Probably the
easiest way to do this now is with:

  ../node() except .

(Get the child nodes of the parent of the context node, and remove the
context node from that sequence.)
  
Your example would become something like:

<xsl:for-each select="x-path">
  <xsl:if test="(@a = '1') = ((../* except .)/@* = '1')">
  </xsl:if>
</xsl:for-each>

If you feel the need for an "any()" function, you can always define it
yourself as a stylesheet function:

<xsl:function name="my:any" as="node()*">
  <xsl:param name="node" as="node()" />
  <xsl:sequence select="$node/../node() except $node" />
</xsl:function>

Since it has an uncomplicated equivalent, and you can create it
yourself without problems, I don't think "any()" needs to be a
built-in function.

Cheers,

Jeni

---
Jeni Tennison
http://www.jenitennison.com/



