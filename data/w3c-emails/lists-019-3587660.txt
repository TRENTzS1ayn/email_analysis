docno="lists-019-3587660"
received="Tue Nov 11 09:39:43 2003"
isoreceived="20031111143943"
sent="Tue, 11 Nov 2003 09:37:33 -0500"
isosent="20031111143733"
name="Jonathan Robie"
email="jonathan.robie@datadirect.com"
subject="Re: [XQuery] Computed CDATA constructor"
id="6.0.0.22.2.20031111092736.041ebc30@ncmail.datadirect.com"
charset="us-ascii"
inreplyto="BF0AC873-13E8-11D8-BD38-000A278462D6&#64;apple.com"
expires="-1"


To: Sarah Wilkin<swilkin@apple.com>, Michael Rys<mrys@microsoft.com>
Cc:public-qt-comments@w3.org


At 08:45 PM 11/10/2003, Sarah Wilkin wrote:
>But according to the spec, CDATA is not just for the need of 
>non-entitizing: "An implementation may choose to serialize text that was 
>constructed using a CDATA section constructor by means of a CDATA section 
>in the serialized output, but it is not obliged to do so." I realize that 
>it doesn't exist in the data model, but it should be up to the implementor 
>to define whether or not the information is retained, as the spec suggests.

If we could place any text we want in the content of an element or the 
value of an attribute, we would not use CDATA sections. Once the CDATA 
section gets the text into the data model, it has done its work. Here's 
what the XML Rec says about CDATA sections:

>[Definition: CDATA sections may occur anywhere character data may occur; 
>they are used to escape blocks of text containing characters which would 
>otherwise be recognized as markup. CDATA sections begin with the string 
>"<![CDATA[" and end with the string "]]>":]

So in XQuery, the purpose of a computed CDATA constructor would be to 
escape text that contains characters which would otherwise be recognized as 
markup. But for computed text, I can't think of any context in which a 
computed CDATA constructor is needed for this. Some people think of CDATA 
sections as the boundaries for code examples, but you should use elements 
for that.

At any rate, the boundaries of CDATA marked sections are not available in 
the XML Information Set, so they are not available for our data model. 
Implementations will not generally recognize CDATA sections in input - and 
if they do, they do so in an implementation-dependent manner which we do 
not define. To me, it would be very strange to add features for 
constructing things that do not exist in our data model.

I have some sympathy for Mike Kay's suggestion that we remove the 
XML-syntax CDATA constructors as well, but they are very convenient when 
cutting and pasting XML text as a template for an XQuery.

Jonathan 



