docno="lists-019-3597806"
received="Tue Nov 11 14:23:50 2003"
isoreceived="20031111192350"
sent="Tue, 11 Nov 2003 11:23:50 -0800"
isosent="20031111192350"
name="Sarah Wilkin"
email="swilkin@apple.com"
subject="Re: [XQuery] Computed CDATA constructor"
id="94266886-147C-11D8-9651-0003935B7D94@apple.com"
charset="US-ASCII"
inreplyto="6.0.0.22.2.20031111092736.041ebc30&#64;ncmail.datadirect.com"
expires="-1"


Cc:public-qt-comments@w3.org, Michael Rys<mrys@microsoft.com>
To: Jonathan Robie<jonathan.robie@datadirect.com>


On Nov 11, 2003, at 6:37 AM, Jonathan Robie wrote:

> So in XQuery, the purpose of a computed CDATA constructor would be to 
> escape text that contains characters which would otherwise be 
> recognized as markup. But for computed text, I can't think of any 
> context in which a computed CDATA constructor is needed for this. Some 
> people think of CDATA sections as the boundaries for code examples, 
> but you should use elements for that.

I appreciate the reasoning here. However, simply because a person 
*should* use elements for something does not mean they will. XQuery 
should be a first class citizen for working with XML, yet small issues 
like this make it an unacceptable solution for creating generic XML 
documents. It's unfortunate that this is not a requirement of XQuery, 
as in general creating XML with XQuery is much easier and faster than 
other programatic methods.

> At any rate, the boundaries of CDATA marked sections are not available 
> in the XML Information Set, so they are not available for our data 
> model. Implementations will not generally recognize CDATA sections in 
> input - and if they do, they do so in an implementation-dependent 
> manner which we do not define. To me, it would be very strange to add 
> features for constructing things that do not exist in our data model.

Any implementation that uses Xerces, libxml2, or another DOM-derived 
model will most likely retain CDATA on input. Again, it is not a 
requirement of XQuery, but reasonable for users to request of an 
implementation that a document they input would have identical output.

Perhaps with a "standard" enhancement package to XQuery implementors 
can agree on ways to create arbitrary XML, evaluate XQuery statement 
strings within XQuery, and convert strings to nodes and vice versa. 
XQuery is a brilliant language but I'm afraid that without 
standardization on the features likely to be added by many implementors 
it will be difficult for users to switch vendors.

Thanks for explaining the design decisions,
--Sarah



