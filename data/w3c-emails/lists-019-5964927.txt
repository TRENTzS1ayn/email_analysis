docno="lists-019-5964927"
received="Thu Nov 27 07:03:24 2003"
isoreceived="20031127120324"
sent="Thu, 27 Nov 2003 12:02:57 GMT"
isosent="20031127120257"
name="David Carlisle"
email="davidc@nag.co.uk"
subject="Re: DM expressing until-like queries in XPath 2.0"
id="200311271202.MAA13645@penguin.nag.co.uk"
inreplyto="20031126164801.A22637&#64;marx.science.uva.nl"
expires="-1"


To:marx@science.uva.nl
Cc:public-qt-comments@w3.org



I believe that your requirement is already expressible in Xpath 1

"find all nodes with l=no such that all their ancestors do not have l=no"

<P name="a" l="yes">
 <P name="a1" l="no">
   <P name="a11" l="no"/>
   <P name="a12" l="yes"/>
   <P name="a13" l="no"/>
 </P>
 <P name="a2" l="yes">
   <P name="a21" l="yes"/>
   <P name="a22" l="no"/>

 </P>
</P>

In this example you want to find a1 and a22 I think.



<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
<xsl:for-each select="//*
  [@l='no' and not(ancestor::*/@l='no')]/@name">
[<xsl:value-of select="."/>]
</xsl:for-each>
</xsl:template>

</xsl:stylesheet>



$ saxon luk.xml luk.xsl
<?xml version="1.0" encoding="utf-8"?>
[a1]

[a22]



In this case you can phrase things to use the implicit existential
quantification of = in xpath 1, although in more complicated cases
that gets difficult/impossible, so then the xpath2 quantifiers some every
would probably help.


David [Not a member of the WG]


________________________________________________________________________
This e-mail has been scanned for all viruses by Star Internet. The
service is powered by MessageLabs. For more information on a proactive
anti-virus service working around the clock, around the globe, visit:
http://www.star.net.uk
________________________________________________________________________



