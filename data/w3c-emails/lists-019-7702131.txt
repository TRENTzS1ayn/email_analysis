docno="lists-019-7702131"
received="Wed Oct 15 22:54:58 2003"
isoreceived="20031016025458"
sent="Wed, 15 Oct 2003 20:00:14 -0700"
isosent="20031016030014"
name="Michael Brundage"
email="xquery@comcast.net"
subject="RE: XQuery"
id="000401c39391$9f959ff0$6501a8c0@xpider"
charset="us-ascii"
inreplyto="DFF2AC9E3583D511A21F0008C7E62106073DD1D2&#64;daemsg02.software-ag.de"
expires="-1"

To:"'Kay, Michael'"<Michael.Kay@softwareag.com>,"'Guido Moerkotte'"<moerkotte@informatik.uni-mannheim.de>,<public-qt-comments@w3.org>
Cc:<mrys@microsoft.com>,<moer@pi3.informatik.uni-mannheim.de>


I think you missed my point.
 
Guido stated in his previous email that XQuery "should be deterministic",
and his query below proves that point.
 
A user cannot expect any reliable outcome from this query -- it might error
or it might not.  I find that even more troublesome than the fact that it
might fail at all.
 
-----Original Message-----
From: public-qt-comments-request@w3.org
[mailto:public-qt-comments-request@w3.org] On Behalf Of Kay, Michael
Sent: Wednesday, October 15, 2003 7:23 PM
To: Michael Brundage; 'Kay, Michael'; 'Guido Moerkotte';
public-qt-comments@w3.org
Cc: mrys@microsoft.com; moer@pi3.informatik.uni-mannheim.de
Subject: RE: XQuery



It's true that a helpful implementation might not barf on this query. But
that's not much help to the user, who has a requirement that no conformant
implementation will barf on it.

Michael Kay 

> 
> As I understand it, this query (like almost all queries that 
> raise dynamic errors) is nondeterministic -- XQuery allows an 
> implementation to return the name of the single matching 
> person without error (for example, if the implementation has 
> indexed on age and thus compares only the one person). 
> 
> As section 2.5.3 says, "the detection and reporting of 
> dynamic errors is implementation dependent.  When an 
> implementation is able to evaluate an expression without 
> evaluating some subexpression, the implementation is never 
> required to evaluate that subexpression solely to determine 
> whether it raises a dynamic error." 
> 
> Because an implementation does not need to evaluate the where 
> clause for every node just to exclude the ones that cannot 
> match (and yet still produce results consistent with the 
> formal semantics), the type error need not be raised. 
> 
> 
> Cheers, 
> michael brundage 
> 
> -----Original Message----- 
> From: public-qt-comments-request@w3.org 
> [mailto:public-qt-comments-request@w3.org] On > Behalf Of Kay, 
> Michael 
> Sent: Wednesday, October 15, 2003 8:02 AM 
> To: Guido Moerkotte; Kay, Michael; public-qt-comments@w3.org 
> Cc: mrys@microsoft.com; moer@pi3.informatik.uni-mannheim.de 
> Subject: RE: XQuery 
> 
> 
> > The remaining question is when is data correct or incorrect. 
> Clearly there are different ways of defining this. One way is 
> that data is correct if it matches the state of the real 
> world (if the data says my date of birth is 13 Nov 1980, it 
> is incorrect). I was using the term "bad data" to mean "data 
> that violates the assumptions that my query/stylesheet makes 
> about what constitutes good data". In general this is a 
> stricter requirement than "valid according to a schema/DTD" 
> since there are many constraints that cannot be expressed in 
> a schema or DTD - not only cross-document constraints, but 
> also contextual constraints (a date must be in the future) 
> and constraints that are too complex to express in a given 
> schema language (e.g. if @x=1 then @y must be present). 
> > If there is a schema (XSchema,DTD) against which it is to be 
> > validated, then I would tend to define data as correct if and 
> > only if it validates correctly. If there is no schema, data 
> > is correct if it is well-formed. 
> > 
> > The above document is well-formed and (if you agree) correct data. 
> > 
> > I don't see anything wrong with the following query: 
> > 
> > for $p in document("p.xml")//person 
> > where $p/@age = 3 
> > return $p/@name 
> > 
> > Why should it fail? 
> I think you have found a bug. I don't think this query should 
> fail simply because the untyped attribute @age contains a 
> value that cannot be converted to a double. I think the 
> comparison should return false. My colleagues may disagree; 
> but certainly, if this fails, it is a nasty incompatibility 
> with XPath 1.0. Michael Kay 
> 



