docno="lists-019-8145323"
received="Tue Oct 21 10:02:19 2003"
isoreceived="20031021140219"
sent="Tue, 21 Oct 2003 10:01:24 -0400"
isosent="20031021140124"
name="Jonathan Robie"
email="jonathan.robie@datadirect.com"
subject="Re: Partial type-assignment and ambiguous RELAX NG schema"
id="6.0.0.22.2.20031021095528.020534b0@ncmail.datadirect.com"
charset="us-ascii"
inreplyto="20031021223226.9304.EB2M-MRT&#64;asahi-net.or.jp"
expires="-1"


To:"MURATA Makoto (FAMILY Given)"<EB2M-MRT@asahi-net.or.jp>,public-qt-comments@w3.org
Cc: MURATA Makoto<eb2m-mrt@asahi-net.or.jp>


At 09:44 AM 10/21/2003, MURATA Makoto (FAMILY Given) wrote:

>I am wondering if it the data model spec allows partial type-assignment:
>assigning types to some (but not all) of the elements or attributes.  Such
>partial type-assignment is particularly useful for RELAX NG schemas,
>which are allowed to be ambiguous.

Hi Makoto,

Every element or attribute node in the data model has a type annotation. 
This type annotation may name a very general type, such as xs:anyType, or 
it may convey that a node is untyped, e.g. xdt:untypedAny. Would assigning 
a very general type meet your needs?

>For example, consider a RNG schema (in the compact syntax) as follows.
>
>start =
>   element root {(aWithOptB, aWithB) | (aWithB, aWithOptB)}
>aWithB    = element a {b}
>aWithOptB = element a {b?}
>b = element b {xsd:int}
>
>This schema is ambiguous: it allows two interpretations of
><root><a><b>3</b></a><a><b>4</b></a><root>.  Although this schema is a bit
>artificial, it is created by computing the difference of two schemas
>by hand (i.e., a schema with optional <b>s and a schema without <b>s).
>
>We cannot uniquely determine the type of the two <a>s in the document,
>but we can determine the type of the two <b>s.  Obviously, they are
>of the type xsd:int.  Does the data type spec allow such partial type
>assignment?

You could assign the nearest common root type to the two <a>s, which may be 
as general as xs:anyType. I don't know what you want to do with this data, 
so I can't tell if this is adequate. If the types are atomic types, then 
assigning a very general type and relying on XQuery's implicit casts could 
do the trick.

Jonathan 



