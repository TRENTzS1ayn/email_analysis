docno="lists-019-9371552"
received="Wed Sep 10 07:56:06 2003"
isoreceived="20030910115606"
sent="Wed, 10 Sep 2003 12:52:19 +0100"
isosent="20030910115219"
name="Emerson"
email="emerson@harvestman.net"
subject="Re: Inability of location steps to support multiple axes"
id="000a01c37791$ff5d8c70$b03e353e@genesis"
charset="us-ascii"
inreplyto="Inability of location steps to support multiple axes"
expires="-1"

To:<public-qt-comments@w3.org>



I think the part that you are missing is that we are dealing with
location step's not sequences.

http://www.w3.org/TR/xpath20/#doc-PathExpr

As you can plainly see from (http://www.w3.org/TR/xpath20/#doc-StepExpr)
the Xpath 2.0 specification does
Not allow anything other than axis/node-test specifiers within a
location step.

The good news is ive added the filter expression support to my Xpath 1.0
implementation and it works a treat.  Ive also taken the liberty to
convert literals and functions which return strings into node-tests and
numbers into abreviated child::*[n] type step expressions (as is done in
Xpointer)

emerson

-----Original Message-----
From: Oliver Becker [mailto:obecker@informatik.hu-berlin.de] 
Sent: Tuesday, 9 September 2003 5:29 PM
To: emerson@harvestman.net; public-qt-comments@w3.org
Subject: Re: Inability of location steps to support multiple axes


Emerson wrote: 

> For example, in the current Xpath expresssions the following is
> cumbersome:
> 
> "parent::a/following-sibling::*//text() |
> parent::a/preceding-sibling::*//text()"
> 
> An obvious solution to the problem which I would like to propose is to
> allow Xpath filter expressions to occur as location steps.  This is
easy
> to implement and does not deviate from the purpose of the filter
> expression which is to take a function or an expression which returns
a
> node-set and filter it by optional predicates, just like a location
> step.
> 
[...]
> So the above example would become:
> 
> "parent::a/(following-sibling::* | preceding-sibling::*)//text()"
> 
> Which in my opinion is logically much more concise...

It could be that I am missing something, but I believe your proposal
is possible in XPath 2.0.
Check out the third item *before* 3.3 Sequence Expression (in reverse
document order ;-) ) for an example.
http://www.w3.org/TR/xpath20/#id-sequence-expressions

The parse tree for that is a little bit lengthy, but basically you can
reduce a StepExpr -> PrimaryExpr -> ParenthesizedExpr -> ...
-> '(' OrExpr ')' -> ... (many steps using always the first non
terminal) ... 
-> '(' UnionExpr ')'
-> ... -> '(' PathExpr '|' PathExpr ')'
There you are!

Cheers,
Oliver
(not a WG member)


/-------------------------------------------------------------------\
|  ob|do        Dipl.Inf. Oliver Becker                             |
|  --+--        E-Mail: obecker@informatik.hu-berlin.de             |
|  op|qo        WWW:    http://www.informatik.hu-berlin.de/~obecker |
\-------------------------------------------------------------------/



