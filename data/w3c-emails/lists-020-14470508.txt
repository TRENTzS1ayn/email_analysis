docno="lists-020-14470508"
received="Wed Jun  9 18:56:41 2004"
isoreceived="20040609225641"
sent="Wed, 9 Jun 2004 15:57:07 -0700"
isosent="20040609225707"
name="Howard Katz"
email="howardk@fatdog.com"
subject="RE: REX evaluation"
id="IKEOLCDFPBBPPAHGNKKOEEDLEMAA.howardk@fatdog.com"
charset="us-ascii"
inreplyto="CFE388CECDDB1E43AB1F60136BEB49730280DA&#64;rome.ad.networkinference.com"
expires="-1"

To:"Rob Shearer"<Rob.Shearer@networkinference.com>,<kendall@monkeyfist.com>
Cc:"RDF Data Access Working Group"<public-rdf-dawg@w3.org>




> From: public-rdf-dawg-request@w3.org
> [mailto:public-rdf-dawg-request@w3.org]On Behalf Of Rob Shearer
> Sent: Wednesday, June 09, 2004 2:25 PM
> To: kendall@monkeyfist.com
> Cc: RDF Data Access Working Group
> Subject: RE: REX evaluation
>

[ snip ... ]

> > > 4.4 User-Specifiable Serialization
> > > FULLY SUPPORTED
> > > One of the strengths of the language.
> >
> > I don't understand this; can you say more about it?
>
> XQuery FLWOR statements have extremely robust capabilities for
> formatting results. Effectively, the result is a sequence, each element
> of which is the result of evaluation of an XQuery expression with a set
> of variables bound to a particular set of values.
> In the absolute simplest case, you can write any XML expression (known
> in XQuery as a "direct constructor"), and then plug in variable names
> somewhere in the XML which will be substituted for that variable's
> binding.

I don't understand all of what Rob is saying. I do agree 155% that XQuery
(not just the FLWOR statement per se) has "extremely robust capabilites for
formatting results." Yup.

XQuery lets you free-format your output in just about any way you choose.
You're essentially generating an ad hoc report on your results, as well as
the results themselves, all in the query itself. An XQuery result set is
just a sequence of "items" (a formal, technical term in the lexicon), each
of which can be pretty well whatever you like. Some of those items might be
element constructors (XML elements (attributes too) constructed on the fly
in the query, used to "structuralize", ie group, other items), the latter of
which can be strings used to label/annotate pieces of the result set or
force line feeds for formatting, actual nodes which have been retrieved from
the repository (what you might think of as the traditional "product" of
querying), integers used to provide running totals, and in general just
about anything that's either an XML node of any type (constructed or
retrieved) or an xsd data value, ordered and laid out as you wish. Pretty
good stuff IYAM.

Here's the result of a query (which I won't show, but easily could if
anybody wanted to see it):

<sampleSillyOutput purpose="I'm a grouping element">
       Here's a silly sample resultset,
       most of the text and formatting having been built right in the query,
       which has ostensibly been used to find two nodes in the database:

       <someNode nodeNum="1">some content</someNode>
       <anotherNode nodeNum="2/>some other content</anotherNode>

       "some content" and "some other content" in this scenario are actual
content
       retrieved from the db. The @nodeNum attributes were generated and
auto-inc'ed
       in the query for use in post-processing, as was this delightful text.
</sampleSillyOutput>

Howard



