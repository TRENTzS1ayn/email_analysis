docno="lists-020-14957083"
received="Sat Jun 12 16:16:13 2004"
isoreceived="20040612201613"
sent="Sat, 12 Jun 2004 21:15:45 +0100"
isosent="20040612201545"
name="Seaborne, Andy"
email="andy.seaborne@hp.com"
subject="RE: REX evaluation"
id="000201c450ba$0d68fd20$0a01a8c0@atlas"
charset="us-ascii"
inreplyto="CFE388CECDDB1E43AB1F60136BEB49730280D8&#64;rome.ad.networkinference.com"
expires="-1"

To:"'Rob Shearer'"<Rob.Shearer@networkinference.com>,"'RDF Data Access Working Group'"<public-rdf-dawg@w3.org>




-------- Original Message --------
> From: public-rdf-dawg-request@w3.org <>
> Date: 09 June 2004 19:59
> 
> Just thought it was worth evaluating a form of the XQuery
> syntax we're using at NI to query the knowledge encoded in
> OWL ontologies. I'll refer to the RDF version of the syntax
> as "RDF Extensions to XQuery", or REX.

Rex, rex, regem, regis, regi, rege :-)

> 
> The language really does nothing but add a few new functions
> to XQuery:
> 
> individuals() returns a sequence of all the URIs used as
> either subjects or objects in triples,
> properties() returns a sequence of all the URIs used as
> predicates in triples
> dataValues() returns a sequence of all possible datavalues
> (for now, assume they are just the values used as objects in
> triples) related(x, y, R) is a boolean predicate representing
> the existence of the triple 'x R y'
> 
> (This is actually a somewhat simplified version of the
> syntax, but it will do for now.)

What do XQuery path expressions mean in this language?  There have been
various different uses for xpaths elsewhere - what does REX do?

> 
> A query to find all working group members and their names would be:
> 
> for $i in individuals()
> for $d in dataValues()
> where related($i, #DAWG, #memberOf)
>   and related($i, $d, #hasName)
> return <Member><uri>{$i}</uri><name>{$d}</name></Member>
> 
> 
> 3.1: RDF Graph Pattern Matching
> FULLY SUPPORTED
> Each 'related' clause is nothing but a triple which might
> include variables, and you can string them together with
> 'and', so I think a 'where' clause qualifies as a 'graph pattern'.

How does REX interact with XQuery typing? A case I don't understand is:

    :x :p :z .
    :x :p "1" .

and related($x, $z, :p)

How do I write the "for $z in ...." and match both triples?  Is there a way
of getting all the nodes in the graph?  Does it even matter that $z can be
either a datavalue or a URI handled?

> 3.4: Subgraph Results
> FULLY SUPPORTED
> Results can easily be formattted as a subgraph of the
> original graph: <rdf:RDF xmlns:rdf="..."> {
>   for $i in individuals()
>   for $d in dataValues()
>   where related($i, #DAWG, #memberOf)
>     and related($i, $d, #hasName)
>     and isCommonlyMisspelled($d)
>   return <rdf:Description rdf:id={$i}>
>            <memberOf rdf:resource="#DAWG"/>
>            <hasName>{$d}</hasName>
>          </rdf:Description>
> }</rdf:RDF>

It is only one case of subgraph results - it is a client-defined RDF.  The
server isn't able to contribute as in a "describe" query ("tell me about") -
this does not cover the description queries (see the motorcycle parts UC).

----

General questions about REX's client-defined return syntax:
(These may be XQuery questions, rather than REX ones)

1/ How does the XML output a qname from the property URI?

Eg. How do I write:

  related($s, $o, $p)
  return <rdf:Description rdf:id={$s} xmlns:???=????>
            <$p>{$o}<$p>               <--- what should be here for "$p"?
         </rdf:Description>

2/ How is correct syntax of the results assured?  Or is it a execution time
error for a syntax error in the XML form of the results?

> 4.4 User-Specifiable Serialization
> FULLY SUPPORTED
> One of the strengths of the language.

My reading of 4.4 "the serialization format of query results" would be
closer to Kendall's example of users-specifiable serialization which is
about going beyond defined MIME types.  I don't read "serialization format"
(protocol issue) as "formatting" (shaping the results).

However, arbitrary XML expressions, in the style of CONSTRUCT, would be good
to see in "DAWL-QL" so as to generate XML fragments at the server (but as
non-normative feature - this would not be a requirement nor design
objective).



