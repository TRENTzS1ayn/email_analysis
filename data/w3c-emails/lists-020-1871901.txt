docno="lists-020-1871901"
received="Mon Jan 19 02:10:05 2004"
isoreceived="20040119071005"
sent="Sun, 18 Jan 2004 23:09:52 -0800"
isosent="20040119070952"
name="Per Bothner"
email="per@bothner.com"
subject="Re: recursive imporged variable declarations"
id="400B82C0.1070900@bothner.com"
charset="us-ascii"
inreplyto="6.0.0.22.2.20040115162957.02eb7230&#64;gmstimap.oraclecorp.com"
expires="-1"


To: Jim Melton<jim.melton@acm.org>
Cc:public-qt-comments@w3.org,w3c-xml-query-wg@w3.org


Jim Melton wrote:

> The W3C XML Query WG has considered your comment (archived at 
> http://lists.w3.org/Archives/Public/public-qt-comments/2003Nov/0186.html).  
> This message contains the official response of that WG.
> 
> We believe that your question ("Is there anything to prevent the 
> following?") is answered in the Last Call Working Draft of XQuery 1.0: 
> An XML Query Language (http://www.w3.org/TR/2003/WD-xquery-20031114/) in 
> Section 4.8, "Variable Declaration".  In that section, the third 
> paragraph contains the provision that "If an initializing expression 
> cannot be evaluated because of a circularity (for example, it depends on 
> a function that in turn depends on the value of the variable that is 
> being initialized), a dynamic error is raised."

I don't think this is a good answer.  The only reason I can think of
for requiring that a "variable may appear in the expression part of a
variable declaration only if that variable is declared or imported
earlier in the Prolog than the declaration in which it is used" is
to prevent cycles.  If you're going to require a dynamic check
for cross-module variables dependencies, that I don't see much
point in requiring variables to be defined before use.

Furthermore, requiring a dynamic cycle check seems to preclude "direct"
compilation of variable reference.  One cannot compile it to a direct 
field access, nor can variable initialization be done "eagerly" at
initialization time.  Instead, it appears that variable initialization
needs to be done lazily, on first reference, which means the compiler
must generate a function call.

Why not require a static check instead?
It is a static error if V depends on V (itself), where:
V1 depends on V2 iff V2 appears in V1's initialization expression.
V depends on F is there is a call to F in V's initialization expression.
F depends on V if V appears in the body of F.

Catching a cycle at compile time seems better than doing it at run-time.
-- 
--Per Bothner
per@bothner.com   http://per.bothner.com/



