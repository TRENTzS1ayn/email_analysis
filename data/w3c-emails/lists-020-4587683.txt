docno="lists-020-4587683"
received="Thu Jan 29 17:24:31 2004"
isoreceived="20040129222431"
sent="Thu, 29 Jan 2004 14:24:05 -0800"
isosent="20040129222405"
name="Michael Rys"
email="mrys@microsoft.com"
subject="RE: [XPath] Legal vaues for a satisfies expression in a quantifier?"
id="EB0A327048144442AFB15FCE18DC96C701E2BD59@RED-MSG-31.redmond.corp.microsoft.com"
charset="us-ascii"
inreplyto="[XPath] Legal vaues for a satisfies expression in a quantifier?"
expires="-1"


To:"Roger L. Costello"<costello@mitre.org>,<scott_boag@us.ibm.com>,<public-qt-comments@w3.org>


I think you want to bind ors inside the satisfy clause. I agree with
Scott that the current grammar seems to give the right precedence... A
PathExpr is also a ExprSingle.

Best regards
Michael

> -----Original Message-----
> From: public-qt-comments-request@w3.org [mailto:public-qt-comments-
> request@w3.org] On Behalf Of Roger L. Costello
> Sent: Thursday, January 29, 2004 1:36 PM
> To: scott_boag@us.ibm.com; public-qt-comments@w3.org; Costello,Roger
L.
> Subject: Re: [XPath] Legal vaues for a satisfies expression in a
> quantifier?
> 
> 
> Hi Scott,
> 
> Hmm, I am not sure where you are getting that expansion - where does
it
> say
> the value of a quantifier's satisfies expression is a "PathExpr"?  I
am
> looking at section 3.9 of the latest XPath 2.0 spec and it says that
the
> value
> of a quantifier's satisfies expression is "ExprSingle", not
"PathExpr",
> i.e.,
> 
> QuantifiedExpr    ::=    (("some" "$") | ("every" "$")) VarName "in"
> ExprSingle ("," "$" VarName "in" ExprSingle)* "satisfies" ExprSingle
> 
> Note the use of "ExprSingle" in three places.
> 
> That said, PathExpr makes good sense.  So, I believe that section 3.9
> needs to
> be corrected to:
> 
>  QuantifiedExpr    ::=    (("some" "$") | ("every" "$")) VarName "in"
> PathExpr
> ("," "$" VarName "in" PathExpr)* "satisfies" PathExpr
> 
> Agree?  /Roger
> 
> 
> 
> scott_boag@us.ibm.com wrote:
> 
> > Hi Roger.  I may be misunderstanding your question, but I think the
> answer
> > is that OrExpr recurses down PathExpr.  You can follow the recursion
> > basically by clicking on the first member of the right hand side of
the
> > BNF productions.  This particular cascade is what implements the
built-
> in
> > precedence.  Anyway, I believe the BNF to be correct, and the
structure,
> > dumped from the diagnostics of the test parser, is:
> >
> > |XPath
> > |   Expr
> > |      QuantifiedExpr
> > |         Every every $
> > |         VarName part
> > |         In in
> > |         PathExpr
> > |            RootDescendants //
> > |            StepExpr
> > |               NodeTest
> > |                  NameTest
> > |                     QName part
> > |         Satisfies satisfies
> > |         PathExpr
> > |            VarName part
> > |            StepExpr
> > |               At @
> > |               NodeTest
> > |                  NameTest
> > |                     QName discounted
> >
> > Note that the test parser reduces many of the unneeded steps, for
> instance
> > for ExprSingle to PathExpr, as I think you would for most ASTs.
> >
> > -scott
> 
> 



