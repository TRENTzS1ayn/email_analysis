docno="lists-021-2741158"
received="Tue Mar  9 17:14:54 2004"
isoreceived="20040309221454"
sent="Tue, 09 Mar 2004 16:15:55 -0600"
isosent="20040309221555"
name="Dan Connolly"
email="connolly@w3.org"
subject="RDF in parts of XHTML documents"
id="1078870555.21445.30600.camel@dirk"
expires="-1"

To:public-rdf-in-xhtml-tf@w3.org
Cc: Ben Adida<ben@mit.edu>



At the Best Practices & Deployment meeting last week
  http://www.w3.org/2004/03/04-SWBPD
Ben gave a nifty presentation about Creative Commons,
including their struggles with RDF in HTML.
Technical discussion followed, with another fly-by of the
GRDDL talk
  http://www.w3.org/2003/g/talk/all.htm
and of the "XHTML and RDF" document
  http://www.w3.org/MarkUp/2004/02/xhtml-rdf.html

Ben brought up a scenario I hadn't considered
before: suppose you're generating just part of an XHTML
document, where the <head> and such are out of your control;
they're generated by some templating system or some such.
Ben asked about fully qualifying the rel="..." attribute.
It appealed to me at the time; let's see if I can remember
the details...

Here's a summary of the initial GRDDL design, in psuedo-code:

def gleanXHTML(doc):
  statements = []
  if 'http://www.w3.org/2003/g/data-view' in doc.head.profile.split():
    for tx_ptr in doc.link[rel="transformation"]/@href:
      tx = http.GET(tx_ptr)
      statements += tx(doc)
  return statements

In the general XML case, it becomes:

def gleanXML(doc):
  statements = []
  v = doc.root.attrVal(data-view:transformation):
  if v:
    for tx_ptr in v.split():
      tx = http.GET(tx_ptr)
      statements += tx(doc)
  return statements

We've talked about pushing the tx_ptr down into the profile
or namespace document; I think Dom implemented that (and I
have an action from another forum to make sure there are
running tests...) in that case, it looks like:

def glean_ns(doc):
  statements = []
  ns = doc.root.namespace-name()
  nsDoc = http.GET(ns)
  for tx_ptr in nsDoc.rdfparse().each(subject=ns,
pred=data-view:transformation):
      tx = http.GET(tx_ptr)
      statements += tx(doc)
  return statements

I want to do that for the HTML profile case too; e.g. add
one pointer from the XFN profile document to grokXFN.xsl,
so we don't need a pointer to grokXFN.xsl from each
XFN document. In that case, I think it looks like:

def glean_profile(doc):
  statements = []
  for profile_ptr in doc.head.profile.split():
    profDoc = http.GET(profile_ptr)
    prof_graph = glean(profDoc)
    for tx_ptr in prof_graph.each(subject=ns,
pred=data-view:transformation):
      tx = http.GET(tx_ptr)
      statements += tx(doc)
  return statements

Now the question is: just like we pushed the grokXFN.xsl
pointer into the profile document, can we somehow push the
profile pointer down into the license link? i.e. change

  This page is licensed with a <a
  href="http://creativecommons.org/licenses/by-nd/1.0/"
  rel="cc-license">Creative Common License</a> allowing copy and
  redistribution with attribution to the author, and disallowing derivative
  works.

to something like...

  This page is licensed with a <a
  href="http://creativecommons.org/licenses/by-nd/1.0/"
  rel="http://www.w3.org/2003/12/rdf-in-xhtml-xslts/grokCC#license">Creative Common License</a> allowing copy and
  redistribution with attribution to the author, and disallowing derivative
  works.

But... what trigger does a client use to extract data from such
links? hmm...

def glean_links(doc):
  statements = []
  for elt in doc.link + doc.a:
    if ':' in elt.rel: # KLUDGE to detect fully qualified rel names?
      tx = http.GET(elt.rel)
      statements += tx(doc)
  return statements

Is is it reasonable to look at any fully-qualified link relationship
as a pointer to a data view transformation? That seems like a stretch.

-- 
Dan Connolly, W3C http://www.w3.org/People/Connolly/
see you at the WWW2004 in NY 17-22 May?



