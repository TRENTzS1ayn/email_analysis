docno="lists-024-6638561"
received="Thu Apr 17 08:57:08 2003"
isoreceived="20030417125708"
sent="Thu, 17 Apr 2003 07:56:53 -0500"
isosent="20030417125653"
name="Smith, Michael K"
email="michael.smith@eds.com"
subject="RE: Remarks on OWL Guide and question about AS&amp;S"
id="B8E84F4D9F65D411803500508BE322141553922D@USPLM207"
charset="iso-8859-1"
inreplyto="Remarks on OWL Guide and question about AS&amp;S"
expires="-1"


To: Antoine Isaac<aisaac@ina.fr>,public-webont-comments@w3.org


Antoine,

Thanks again for your comments. In this message I have tried
to either answer your questions or propose an editorial change 
that I think addresses them.

> After the reading of the last versions of OWL Guide and OWL AS&S, I 
> have some basic remarks, some of them due to typo errors, others not. 
> Maybe they are mainly due to some english (or more fundamental) 
> misunderstandings of mine.
> 
> Concerning OWL Guide :
> 
> -> sections 3.2.2 and 3.2.3
> 
> In section, 3.2.2, yearValue is specified has having a 
> xsd:positiveInteger range. In the next section, the individual 
> Year1998 id defined by :
> 
> [
> <VintageYear rdf:ID="Year1998">
>   <yearValue rdf:datatype="&xsd;positiveInteger">1998</yearValue>
> </VintageYear>
> ]
> 
> Is the specification of rdf:datatype="&xsd;positiveInteger" mandatory?

Yes, if we want 1998 to be considered a positive integer.

> Is is linked to RDF syntax considerations or just an examplification 
> of what could optionnally be written? Is

> <VintageYear rdf:ID="Year1998">
>   <yearValue>1998</yearValue>
> </VintageYear>
> 
> correct?

No.  Not if you want '1998' to be an integer.  1998 as above is a 'plain 
literal' as opposed to a 'typed literal'.  See 
http://www.w3.org/TR/2003/WD-rdf-concepts-20030123/#dfn-plain-literal
We expect tools to help with these verbose constructs.

> -> section 3.3, InverseFunctionalProperty subsection
> 
> [
> <owl:ObjectProperty rdf:ID="producesWine">
>   <rdf:type rdf:resource="&owl;InverseFunctionalProperty" />
>   <owl:inverseOf rdf:resource="#hasMaker" />
> </owl:ObjectProperty>                                     ?
> 
> Think of the elements of the range in an inverse functional property 
> as defining a unique key in the database sense. owl:InverseFunctional 
> implies that the elements of the range provide a unique identifier for 
> each element of the domain. ]
> 
> In this case, a Wine can be used to identify a Winery, but it is not a
> *unique* key, since several wines can be produced by a single winery 
> (which seems to be allowed by the last sentence of the previous 
> section).

You are right.  This is phrased incorrectly.  The idea was that a 
'unique key' applies to a tuple and the text should not have stated 
that it is a unique identifier for the domain elements.

Suggested rewording:

[
Think of the elements of the range in an inverse functional property 
as defining a unique key in the database sense. owl:InverseFunctional 
implies that the elements of the range provide a unique identifier for 
each pair contained in the property. ]

> I have understood that there has been lots of arguing about the 
> meaning of this property (I know this issue has been largely discussed 
> in the rdf-logic list, but I do not find the thread....). Indeed I 
> believed I had got it, until I saw the two last paragraph of the 
> subsection. In my understanding of the definitions, an 
> InverseFunctionalProperty gives a key provided it has an exactly-one 
> cardinality restriction on its range.

Yes.  Your understanding was correct.

> -> section 3.4.1
> 
> [
> The maker of a Wine must be a Winery. The allValuesFrom restriction
> is on the hasMaker property of this Wine class only. Makers of Cheese
> are not constrained by this local restriction. ]
> 
> Indeed makers of Cheeses should NOT be concerned, for in 3.3 (and in
> wine.owl) producesWine has been defined by :
> 
> [
> <owl:ObjectProperty rdf:ID="producesWine">
>   <owl:inverseOf rdf:resource="#hasMaker" /> </owl:ObjectProperty> ]
> 
> That implies that any cheese that would be made by a maker of cheese 
> would be in the range of a "producesWine" property, which is quite 
> disturbing.

Formally, both hasMaker and producesWine have range and domain of 
owl:Thing.  So cheese would be fine.  It would have been better to 
use the name "produces" rather than "producesWine".  I will 
rename "producesWine" to "produces".

> -> section 3.4.2
> 
> [
> owl:maxCardinality can be used to specify an upper
> bound. owl:minCardinality can be used to specify a lower bound. In 
> combination, the two can be used to specify a range. ]
> 
> Perhaps a typo : "cardinality" (or "owl:cardinality") instead of 
> "range" ?

I'm using range in the [n...m] sense.  Will change to "numeric range".

> -> section 5.1
> 
> [
> 
>  <owl:Class rdf:ID="ConsumableThing" />
> 
>   <owl:Class rdf:ID="NonConsumableThing">
>     <owl:complementOf rdf:resource="#ConsumableThing" />
>   </owl:Class>
> 
> The class of NonConsumableThing includes as its members all 
> individuals that do not belong to the extension of ConsumableThing. 
> This set includes all Wines, Regions, etc ]
> 
> Is a wine non consumable ? Anyway, when I searched in wine.owl for 
> further examplification I couldn't find the above definitions. I found 
> it in food.owl, only to discover it was not a subclass of 
> PotableLiquid. If it is a modelisation choice, it looks strange.

Typo.  Should have been Wineries.  ConsumableThing is defined 
in food.owl. PotableLiquid is a subclass of ConsumableThing, 
but disjoint from EdibleThing.

> -> appendix C
> 
> [
> <owl:ObjectProperty rdf:ID="&vin;regionOf">
>     <rdf:type rdf:resource="&owl;FunctionalProperty" />
>     <owl:inverseOf rdf:resource="&vin;hasRegion"/>
>     <owl:range rdf:resource="&vin;Country"/> </owl:ObjectProperty> ]
> 
> There is a typo. the range is "&vin;region", as it is specified in the 
> following triple definition :

> [
> vin:hasRegion owl:range vin:Region.
> ]

Corrected.

Please reply to the mailing list as to whether the above changes 
adequately address your comments.

- Mike

Michael K. Smith, Ph.D., P.E.
EDS - Austin Innovation Centre
98 San Jacinto, #500
Austin, TX  78701

phone: +01-512-404-6683
email: michael.smith@eds.com
  


-----Original Message-----
From: Antoine Isaac [mailto:aisaac@ina.fr] 
Sent: Friday, April 11, 2003 9:50 AM
To: public-webont-comments@w3.org
Subject: Remarks on OWL Guide and question about AS&S



Hi folks,

After the reading of the last versions of OWL Guide and OWL AS&S, I have
some basic remarks, some of them due to typo errors, others not. Maybe they
are mainly due to some english (or more fundamental) misunderstandings of
mine.

Concerning OWL Guide :

-> sections 3.2.2 and 3.2.3

In section, 3.2.2, yearValue is specified has having a xsd:positiveInteger
range. In the next section, the individual Year1998 id defined by :

[
<VintageYear rdf:ID="Year1998">
  <yearValue rdf:datatype="&xsd;positiveInteger">1998</yearValue>
</VintageYear>
]

Is the specification of rdf:datatype="&xsd;positiveInteger" mandatory? Is is
linked to RDF syntax considerations or just an examplification of what could
optionnally be written? Is <VintageYear rdf:ID="Year1998">
  <yearValue>1998</yearValue>
</VintageYear>
correct?


-> section 3.3, InverseFunctionalProperty subsection

[
<owl:ObjectProperty rdf:ID="producesWine">
  <rdf:type rdf:resource="&owl;InverseFunctionalProperty" />
  <owl:inverseOf rdf:resource="#hasMaker" />
</owl:ObjectProperty>                                     ?

Think of the elements of the range in an inverse functional property as
defining a unique key in the database sense. owl:InverseFunctional implies
that the elements of the range provide a unique identifier for each element
of the domain. ]

In this case, a Wine can be used to identify a Winery, but it is not a
*unique* key, since several wines can be produced by a single winery (which
seems to be allowed by the last sentence of the previous section).

I have understood that there has been lots of arguing about the meaning of
this property (I know this issue has been largely discussed in the rdf-logic
list, but I do not find the thread....). Indeed I believed I had got it,
until I saw the two last paragraph of the subsection. In my understanding of
the definitions, an InverseFunctionalProperty gives a key provided it has an
exactly-one cardinality restriction on its range. Now I am not sure of
anything...


-> section 3.4.1

[
The maker of a Wine must be a Winery. The allValuesFrom restriction is on
the hasMaker property of this Wine class only. Makers of Cheese are not
constrained by this local restriction. ]

Indeed makers of Cheeses should NOT be concerned, for in 3.3 (and in
wine.owl) producesWine has been defined by :

[
<owl:ObjectProperty rdf:ID="producesWine">
  <owl:inverseOf rdf:resource="#hasMaker" /> </owl:ObjectProperty> ]

That implies that any cheese that would be made by a maker of cheese would
be in the range of a "producesWine" property, which is quite disturbing.


-> section 3.4.2

[
owl:maxCardinality can be used to specify an upper bound. owl:minCardinality
can be used to specify a lower bound. In combination, the two can be used to
specify a range. ]

Perhaps a typo : "cardinality" (or "owl:cardinality") instead of "range" ?


-> section 5.1

[

 <owl:Class rdf:ID="ConsumableThing" />

  <owl:Class rdf:ID="NonConsumableThing">
    <owl:complementOf rdf:resource="#ConsumableThing" />
  </owl:Class>

The class of NonConsumableThing includes as its members all individuals that
do not belong to the extension of ConsumableThing. This set includes all
Wines, Regions, etc ]

Is a wine non consumable ? Anyway, when I searched in wine.owl for further
examplification I couldn't find the above definitions. I found it in
food.owl, only to discover it was not a subclass of PotableLiquid. If it is
a modelisation choice, it looks strange.


-> appendix C

[
<owl:ObjectProperty rdf:ID="&vin;regionOf">
    <rdf:type rdf:resource="&owl;FunctionalProperty" />
    <owl:inverseOf rdf:resource="&vin;hasRegion"/>
    <owl:range rdf:resource="&vin;Country"/> </owl:ObjectProperty> ]

There is a typo. the range is "&vin;region", as it is specified in the
following triple definition :

[
vin:hasRegion owl:range vin:Region.
]


Concerning OWL AS & S

I have not clearly understood the goal of section 4.1 (I must recognize I am
far from being an expert in those matters). If it is to obtain (when
possible) equivalent RDF triples for OWL definitions, why not using RDF
abilities at best ? In particular, could an equivalent for
"EquivalentClasses (D1...Dn)" be
"T(Di) rdfs:subclassOf T(Di+1); T(Di+1) rdfs:subClassOf T(Di),1<=i<n" or
would a RDFS-guru find it really stupid ?

Regards.

Antoine Isaac



