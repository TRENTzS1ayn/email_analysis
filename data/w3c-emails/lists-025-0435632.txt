docno="lists-025-0435632"
received="Fri Apr 11 17:52:53 2003"
isoreceived="20030411215253"
sent="Fri, 11 Apr 2003 14:52:48 -0700"
isosent="20030411215248"
name="Burdett, David"
email="david.burdett@commerceone.com"
subject="RE: Internal processes and/or external choreographies (was RE: Ev  ents  and States ..."
id="C1E0143CD365A445A4417083BF6F42CC053D1986@C1plenaexm07.commerceone.com"
inreplyto="Internal processes and/or external choreographies (was RE: Ev  ents  and States ..."
expires="-1"


To:"'Assaf Arkin'"<arkin@intalio.com>
Cc:"Burdett, David"<david.burdett@commerceone.com>,"'Martin Chapman'"<martin.chapman@oracle.com>,"'Cummins, Fred A'"<fred.cummins@eds.com>,jdart@tibco.com,public-ws-chor@w3.org


Assaf

You seem to have a very clear idea of how both requirements (internal and
external definitions) can be met by one language based on pi-calculus.

Unfortunately I, and probably many others on this list, are not familiar
with pi-calculus.

So can you provide an example (see below for the use case) in a single
language that meets the requirements for internal and external definitions.
I agree that we don't yet want an implementation, but understanding how it
is possible will be useful in determining what we *should* do.

Here's a very simple use case involving order placement - my favorite ;)

**THE SINGLE EXTERNAL DEFINITION**

CHOREOGRAPHY (This is the external definition)
BUYER               SELLER
1. Order ------------>
... then either ...
2. <------------ Order Response (to indicate the extent to which the order
can be satisfied)
... or ...
2. <------------ Error Response (if there is a problem with the order which
means it cannot be processed)

**THE TWO INTERNAL DEFINITIONS**

BUYER PROCESSING 
1. The Buyer's ERP system determines that an order needs to be placed
2. The Buyer's system sends an Order to the Seller
3. If an Order Response is received then it is forwarded to the Buyer's ERP
system
4. If an Error Response is received, then details are emailed to the IT
department to investigate
5. If no response is received after some time, then an email is sent to a
user to phone the seller.

SELLER PROCESSING
1. The seller receives the Order
2. The seller checks the order for validity.
4. If there is an error then the Seller sends an Error Response to the Buyer
5. If there are no errors then the Seller sends a credit check query to an
external credit checking agency
6. If the credit check fails, then the Seller sends an Order Response to the
Buyer indicating this
7. If the credit check is OK, then:
  a) The Seller checks for stock availability with the Fulfillment system
reserving stock as appropriate
  b) The results from the fullfillment system are used create an Order
Response
  c) The Order Response is sent to the Buyer

Do you think this example is OK?

David



-----Original Message-----
From: Assaf Arkin [mailto:arkin@intalio.com]
Sent: Friday, April 11, 2003 12:34 PM
To: Assaf Arkin
Cc: Burdett, David; 'Martin Chapman'; 'Cummins, Fred A';
jdart@tibco.com; public-ws-chor@w3.org
Subject: Re: Internal processes and/or external choreographies (was RE:
Ev ents and States ...


I want to re-iterate my point of view on this subject.

Q: Can you define a language that can express all types of processes 
with different levels of detail and abstraction, ranging from the most 
abstract high-level choreography to the most fine-grained detail of 
implementation (in fact down to the IP packet flow)?

A: This has been proven mathematically as part of a large body of 
research. I accept any evidence that the mathematical proof is flawed, 
but until then I'm inclined to believe it is correct, and this in fact 
can be done.

Q: Do you want to define a language that does that?

A: Definitely not. Such a language already exists (e.g. pi-calculus, 
join calculus) but is too generic and so not very useful. I would prefer 
to see a language that is expressed in terms of Web services. If that 
means we can't describe how IP packets flow, or the gory details you 
will find in a piece of Java code, so be it. There's more than enough 
utility in a language that is defined at the level of Web services.

Q: Can one language define both choreographies and recusrive composition 
of services, and constrain one definition to the other?

A: A language defined at the level of Web services still has the ability 
inherit from mobile process calculus to define choreographies, recursive 
composition of services, and constrain/validate one definition against 
the other.

Q: Do you want to define a language that covers both use cases?

A: That's an open question. Maybe that language provides so much utility 
it that it's the best way to leverage our time & eneregy. With just 
minor extensions we can cover more ground and provide so much more 
capability. Maybe time is of the essence and doing less but on a shorter 
time frame is better (see 80/20 rule). We'll move such capabilities to a 
future time and just focus on choreography in this iteration. Maybe 
there is a political issue - providing such a language may stand in 
competition to other languages that specifically address implementation, 
and we want to promote variety and it's best to stay clear of this space.

Q: Assuming a choreography language that is not turing complete and any 
number of implementation languages that are turing complete, can a 
definition given in one be used to constrain/verify a definition given 
in the other?

A: You can prove at design-time or check at run-time that a more 
complete specification (the turning complete implementation) in fact 
conforms to the less complete specification (the non-complete 
choreography). Bi-simulation is one way to prove it. The whole space of 
mobile process calculus is intended to provide mathematical models for 
making such proofs at design-time and checks at run-time, and also helps 
us determine when such proofs are P problems and when they are NP problems.

Q: Can you show that by example?

A: Yes I can. But there is an infinite number of examples out there: 
order-to-pay, hire-to-fire, package-to-deliver, etc. If we try to cover 
all possible use cases by example we'll never get anything accomplished. 
If we pick some specific and interesting examples, we need to keep 
focusing on them and not constantly switch examples, as we're currently 
doing. Pick two/three examples, specify them in precise term that 
everyone agrees on, and then explore them.

But it's far more interesting to look at all possible use cases at once 
by picking up a model that describes all of them. Instead of working one 
example at a time, we work on all possible use cases at once. That's the 
benefit of using models, it gives you so much leverage in exploring a 
wider problem space and accounting for both current and future use cases.

Q: Has anyone ever done this before?

A: There are a variety of research projects and running systems based on 
mobile process calculus that anyone can download and experiment with. 
And there are several products in the market that are already taking 
advantage of these models and technologies.



