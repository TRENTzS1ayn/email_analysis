docno="lists-025-7347660"
received="Wed Feb 26 21:26:54 2003"
isoreceived="20030227022654"
sent="Wed, 26 Feb 2003 18:25:17 -0800"
isosent="20030227022517"
name="Assaf Arkin"
email="arkin@intalio.com"
subject="RE: Dubray paper comments + questions"
id="IGEJLEPAJBPHKACOOKHNCEEBDEAA.arkin@intalio.com"
charset="iso-8859-1"
inreplyto="00d701c2ddf5$40222220$b8eafea9&#64;PC1"
expires="-1"

To:"bhaugen"<linkage@interaccess.com>,<public-ws-chor@w3.org>





> -----Original Message-----
> From: public-ws-chor-request@w3.org
> [mailto:public-ws-chor-request@w3.org]On Behalf Of bhaugen
> Sent: Wednesday, February 26, 2003 4:15 PM
> To: Assaf Arkin; public-ws-chor@w3.org
> Subject: Re: Dubray paper comments + questions
>
>
>
> > > Conversational workflow models:  Winograd, Action Workflow, Dooley
> > > Graphs.
> >
> > I have not read those with detail. At some point I had a hundred or so
> > bookmarks to different models and tons of printed stuff, so I decided
> to
> > borrow from Google's page rank system. The models that were referenced
> the
> > most had the higher rank, the more obscure or less used one were
> removed.
>
> I'd be surprised if pi-calculus had higher page rank than:
> http://hci.stanford.edu/~winograd/
> http://hci.stanford.edu/~winograd/action.html
> http://hci.stanford.edu/~winograd/papers/language-action.html

Duh.

I use keywords like formal models, processes, distributed systems, SOA,
fault tolerance, concensus, proofs, etc. So obviously this didn't hit the
radar screen. But I'm also interested in linguistics and semantics and
exploring the relations between the two. I'm sure this has popped up
somewhere, but I have yet to compile a list of reference. Anyway, I'm sure
to add this one to the list ;-)

In exploring the relation between semantics and processes and between
linguistics and action structure one of the issue that comes around is an
understanding of the meaning of a message based on the context in which it
is used. We've discussed that point before when I explained how a semantic
state can be inferred from a combination of messages exchanged.

Similary Winograd explores this relationship in the paper you reference. He
begins with the definition of a Coordinator system (section 4.1). If you
look at it, it in fact expresses a user's participation in the conversation
in much the same way as process models, what we could call one-sided view:
user receives request (input), user decides what to do next (based on its
state), user selects some action (output).

In fact, the Coordinator works just like the mythical pi-calculus machine.
It determines where in the process you are, inputs act like guards to
further processes (states) and then you are limited in a choice of action
between replicating processes (no state change) and non-replicating
processes (state change). Surprising?

In section 4.2 is even more interesting. The basic unit of work is a
conversation not a message. Absolutely true. Messages and conversly pi-c
actions are means for communication not for achieving anything. What is
interesting is the process in which the communication takes place - the
conversation.

Unless I am reading it all wrong, in 2) he then goes on to describe a
conversation as an I/O automaton for each participant, again defined from
the point of view of that participant.

I may be totally wrong about this article, but I did read one about
conversation theory before. It started with a very basic example, something
like a student talking to a teacher which one could say was modeled as BPSS
does, I mean exchanges in which one is speaker and one is listener.

Then it extended that to an example for a social coordinator. It then
switched to describing a conversation as a collection of conversing
processes, in which each participant was either hearing something, or
deciding based on its state what to say next. Each participant was only
hearing when it was referenced (by its name, group, etc) and could decide
who to speak to and could speak to anyone if it knew their name. Also, a
participant could decide which conversation to follow based on what was
said.

So in effect, a language for expressing a conversation looked something like
this:

conversation := parallel | choice | decision |
hear(topic,details).conversation | say(name,topic,details).conversation |
nothing
parallel := convesation, conversation, ...
choice := hear(sometopic,details).conversation or
hear(sometopic,details).conversation
decision := if ... then conversation or conversation

Sounds familiar?

arkin


>
>
>
>



