docno="lists-025-8953518"
received="Wed Jul 16 09:50:29 2003"
isoreceived="20030716135029"
sent="Wed, 16 Jul 2003 23:52:10 +1000"
isosent="20030716135210"
name="Andrew Berry"
email="andyb@whyanbeel.net"
subject="Re: The degenerate pi-calc use case"
id="B2270628-B794-11D7-9009-0003936786BC@whyanbeel.net"
charset="US-ASCII"
inreplyto="The degenerate pi-calc use case"
expires="-1"

To:public-ws-chor@w3.org




Jeff Lansing <jeff@polexis.com> wrote:
> This example is interesting, but it seems like a lot of machinery to
> describe what is essentially just connecting to something like a
> GetStockQuote service.
>
> What if you try to do something just a little harder, such as pulling
> (or pushing) the results of a StockQuote service through a
> CurrencyConverter service?
>
> Does the amount of pi-calculus machinery then become so cumbersome, in
> that case, that it starts to loose its intuitive appeal?

I certainly found this to be the case when attempting to formalise work 
on a coordination language.  There were a variety of issues, but mostly 
because pi-calculus is designed for describing the behaviour of a 
concurrent program and not the cooperative behaviour of autonomous 
distributed participants.  As noted in my first post 
(http://lists.w3.org/Archives/Public/public-ws-chor/2003Jul/0065.html) 
the solution was to develop a formalism reflecting the higher-level 
semantic concepts.  I did consider building that formalism on top of 
the pi-calculus or other process algebra, but found other limitations 
as well (global state assumption, interleaved concurrency model, 
difficult to model locality).

Ciao,

AndyB



