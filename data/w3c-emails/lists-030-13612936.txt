docno="lists-030-13612936"
received="Fri Jan 24 12:49:02 2003"
isoreceived="20030124174902"
sent="Fri, 24 Jan 2003 12:48:54 -0500"
isosent="20030124174854"
name="Joseph Reagle"
email="reagle@w3.org"
subject="Re: Python Tool for excerpting schema/examples into XHTML spec"
id="200301241248.54583.reagle@w3.org"
charset="iso-8859-1"
inreplyto="4.3.2.7.2.20030124111634.01e741f8&#64;172.27.10.30"
expires="-1"

To: Paul Grosso<pgrosso@arbortext.com>, David Carlisle<davidc@nag.co.uk>
Cc:spec-prod@w3.org



On Friday 24 January 2003 12:30, Paul Grosso wrote:
> Schema-validity should, of course, be doable.

I expect at some point we'll have XHTML+XInclude. I believe that's a feature 
of XHTML2.0, but also expect there might be an intermediary 
identifier/namespace/DTD from XHTML1.* .

> This is what XInclude's parse="text" attribute is for.  Quoting [1]:
> ...
> I'm not sure what xpointer support would have to do with this.
> When you use parse="text", the "resource is treated as plain text"
> so xpointer is irrelevant.

The tricky bit is actually between these two requirements.  I know a common 
source of errata in my specs is typos between the in-line and external 
schema and in the in-line examples. Consequently, it'd be better to 
maintain the schema and examples externally, and keep them all valid. 
(Which means not in little fragments.) So, when I want to include part of 
an example or schema I want to use xptr to select the relevant part and 
include it. If I understand, I can't do that if the parse type is text; and 
if it's not text then it is returned as XML. What I'd need it a: 
parse="xml" return="text"?

So in my script I evaluate the XPath, Canonicalize the result,and return the 
encoded XML (e.g., '<', '>','&') in a <pre> element:

nodes = expression.evaluate(context)
...
  for node in nodes:
    chunk = Canonicalize(node,unsuppressedPrefixes=[])   
    chunk = '<pre class="%s">%s</pre>' % (hclass, encode(chunk))



