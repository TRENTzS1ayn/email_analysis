docno="lists-037-11488157"
received="Sat Mar  1 02:48:22 1997"
isoreceived="19970301074822"
sent="Fri, 28 Feb 1997 22:48:11 PST"
isosent="19970301064811"
name="Larry Masinter"
email="masinter@parc.xerox.com"
subject="Re: range locking not used in GroupWise"
id="3317DF3B.1E8B@parc.xerox.com"
charset="iso-8859-1"
inreplyto="Pine.SGI.3.95.970227215703.27197A-100000&#64;shellx.best.com"
expires="-1"


To:"Gregory J. Woodhouse"<gjw@wnetc.com>
CC: Yaron Goland<yarong@microsoft.com>,"'Steve Carter'"<SRCarter@gw.novell.com>,"'w3c-dist-auth@w3.org'"<w3c-dist-auth@w3.org>

What you were calling a "validator" is called an "ETag" in HTTP/1.1
(because we got into a knot over the meaning of 'validation'), and
the ETag for a "version" of a resource is for the whole resource
and not for any particular byte range.

> The problem is that if
> resource R is represented by a 1000 byte entity, and person A has already
> obtained byte ranges B1 and B2 representing bytes 0-500 and 501-1000
> respectively, and both are available in cache, then if that person wants to
> GET the resource (not a byte range), then the corresponding entity E is the
> union of B1 and B2, and so it should not be necessary to transer the whole
> entity, a revalidation should be sufficient. But how can this be done? Even
> if the byte ranges have their own validators e1 and and e2, there is no
> relationship between the pair (e1,e2) and a validator e for R.?

The ETag returned is that for the entire entity and not for the
subranges. It was important that caches be able to stitch together
whole entities from partial ranges in order to satisfy subsequent
requests. So byte ranges *don't* have their own "validators".



--
http://www.parc.xerox.com/masinter



