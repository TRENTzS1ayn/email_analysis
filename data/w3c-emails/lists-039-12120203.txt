docno="lists-039-12120203"
received="Thu Nov 25 19:05:12 1999"
isoreceived="19991126000512"
sent="Fri, 26 Nov 1999 00:37:56 +0100"
isosent="19991125233756"
name="Jim Davis"
email="jrd3@alum.mit.edu"
subject="Re: Write Locks on Collections"
id="4.1.19991126003117.00b1add0@pop.xs4all.nl"
charset="us-ascii"
inreplyto="9911241646.AA09038&#64;tantalum"
expires="-1"


To:w3c-dist-auth@w3.org

At 11:46 AM 11/24/99 -0500, Geoffrey M. Clemm wrote:
>   How so?  please provide a sequence of operations that would be impossible
>   under this interpretation.
>
>I lock a collection, because I'm going to be adding members
>to that collection.  If a depth:0 lock applies to all the
>immediate members of a collection as well, then I have prevented
>anyone from updating the state of one of the existing internal members of
>that collection.  

But that's not what I asked about, or at least not what I thought I asked
about.

If I lock a collection with depth infinity lock, then create a new
interrnal member of that collection  (e.g. with PUT) I have to provide the
lock token to do the PUT, and the new internal member is added to the lock.

We all agree on this, right?

Now  suppose the lock were depth 0 not depth infinity.

1) to add a new internal member, I still have to provide the lock token, right?

2) Previously exising members are not affected.  I can PUT or PROPPATCH to
them at my whim, right?

3) However, I can't DELETE them without the lock token, right?

So where we seem to disagree is:

If I add a new internal member, is it added to the lock, or not? 

I interpret 7.5 as saying Yes.  You seem to think that the answer is, or
should be, no.

Can you please explain this?  I don't see how this depth 0 lock would
prevent anyone from updating the state of existing members.

with all best wishes

Jim



