docno="lists-039-12231806"
received="Mon Nov 29 10:20:22 1999"
isoreceived="19991129152022"
sent="Mon, 29 Nov 1999 09:55:42 -0500"
isosent="19991129145542"
name="jamsden@us.ibm.com"
email="jamsden@us.ibm.com"
subject="Re: Write Locks on Collections"
id="85256838.00520B4F.00@d54mta03.raleigh.ibm.com"
charset="us-ascii"
inreplyto="Write Locks on Collections"
expires="-1"

To:w3c-dist-auth@w3.org




I agree with everything below except the conclusion that depth:0 locks are
inherited. The behavior is determined  by the lock on the collection, not
any of its members. So for example, say you create a new member with PUT.
This will require the lock token for the collection as it is locked to
control its namespace. Now anyone can PUT to the new resource without any
lock token as no new member is created, and the new resource is not locked.
However, the lock token for the collection must be specified in order to
delete this, or any other resource from the collection as this is effecting
the collection's namespace. So in this sense, the behavior of the lock is
"inherited" by the new resource, but I wouldn't look at it this way. I
think this is just the meaning of a lock on a collection.

See details below in <jra> tags.





Jim Davis <jrd3@alum.mit.edu> on 11/25/99 06:37:56 PM

To:   w3c-dist-auth@w3.org
cc:

Subject:  Re: Write Locks on Collections



At 11:46 AM 11/24/99 -0500, Geoffrey M. Clemm wrote:
>   How so?  please provide a sequence of operations that would be
impossible
>   under this interpretation.
>
>I lock a collection, because I'm going to be adding members
>to that collection.  If a depth:0 lock applies to all the
>immediate members of a collection as well, then I have prevented
>anyone from updating the state of one of the existing internal members of
>that collection.

But that's not what I asked about, or at least not what I thought I asked
about.

If I lock a collection with depth infinity lock, then create a new
interrnal member of that collection  (e.g. with PUT) I have to provide the
lock token to do the PUT, and the new internal member is added to the lock.

We all agree on this, right?
<jra>
Agreed
</jra>

Now  suppose the lock were depth 0 not depth infinity.

1) to add a new internal member, I still have to provide the lock token,
right?
<jra>
Yes because this is changing the collection's members or its managed
namespace.
</jra>

2) Previously exising members are not affected.  I can PUT or PROPPATCH to
them at my whim, right?
<jra>
Yes, you or anyone else subject to their own individual locks and access
controls of course.
</jra>

3) However, I can't DELETE them without the lock token, right?
<jra>
True, but this doesn't mean the lock in inherited. This is just the meaning
of a lock on a parent collection. You can't change the locked collection's
members without the lock token.
</jra>

So where we seem to disagree is:

If I add a new internal member, is it added to the lock, or not?
<jra>
Not added to the lock. You're confusing the notion of a lock on a resource
with the meaning of a lock on its parent collection.
</jra>

I interpret 7.5 as saying Yes.  You seem to think that the answer is, or
should be, no.

Can you please explain this?  I don't see how this depth 0 lock would
prevent anyone from updating the state of existing members.

with all best wishes

Jim



