docno="lists-039-12329571"
received="Tue Nov 30 00:59:06 1999"
isoreceived="19991130055906"
sent="Tue, 30 Nov 1999 00:02:42 -0800"
isosent="19991130080242"
name="David M. Chandler"
email="5chandlers@home.com"
subject="RE: are depth 0 locks inherited by newly created children?"
id="000101bf3b09$47e3f750$d6f00218@c786448-a.cdrrpd1.ia.home.com"
charset="iso-8859-1"
inreplyto="4.1.19991130013916.00ac3740&#64;pop.xs4all.nl"
expires="-1"

To:<w3c-dist-auth@w3.org>


> Is any one else on this list paying any attention to this?
> Or is it just
> the five of us?

Well, since you asked, yes, someone else is paying attention. For clarity, I
think 7.5 should specify a depth infinity lock if that is in fact what the
authors intended (I don't know whether that might be true). As far as the
"bad" behavior which might result when newly-added children inherit depth-0
locks, I propose the following scenario. Please forgive me if this is
obviously wrong. Suppose the following hierarchies of resources:

a/
a/b
a/b/d/
a/b/d/q
a/b/d/r

c/
c/j
c/k

Suppose a/b/ is write-locked depth 0. My understanding is that a/b/d and its
members are not locked at this point.

Now suppose we move collection /c with its members under /a/b, as in the
example of 7.5. Now we have

a/
a/b
a/b/c/
a/b/c/j
a/b/c/k
a/b/d/
a/b/d/q
a/b/d/r

If we interpret 7.5 to mean that the write-locks are inherited even for
depth 0, then /a/b/c becomes locked, but /a/b/d is not locked, which seems
inconsistent to me because the lock has developed memory--pre-existing
internal members are not locked, but newly-added ones are.

Furthermore, what about new members of /a/b/c? Wouldn't /a/b/c/x and
/a/b/c/y inherit the depth-0 write-lock from /a/b/c while /a/b/c/j and
/a/b/c/k remain unlocked? It's the same case, just another level down. I
think you could end up with a depth-0 lock locking some resources down to
depth infinity by virtue of the fact they were added after /a/b/ was locked.

Or I'm just completely lost, which is a real possibility.

> Look, I quote 7.5
>
>    If a lock owner causes the URI of a resource to be added as an
>    internal member URI of a locked collection then the new resource MUST
>    be automatically added to the lock.  This is the only
>    mechanism that allows a resource to be added to a write lock.  Thus,
for
>    example, if the collection /a/b/ is write locked and the resource /c
>    is moved to /a/b/c then resource /a/b/c will be added to the write
lock.
>
> It does not say "locked depth infinity" it just says "locked".

David Chandler



