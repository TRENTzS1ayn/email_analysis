docno="lists-039-14673879"
received="Tue Jan  4 12:49:29 2000"
isoreceived="20000104174929"
sent="Tue, 4 Jan 2000 09:48:27 -0800 "
isosent="20000104174827"
name="Yaron Goland"
email="yarong@Exchange.Microsoft.com"
subject="RE: Precepts of Goland"
id="7DE119D3D0E15543874F7561EECBDBED0261A021@BEG.platinum.corp.microsoft.com"
inreplyto="Precepts of Goland"
expires="-1"


To:"'Jim Davis'"<jrd3@alum.mit.edu>,w3c-dist-auth@w3.org

So Spoke Jim Davis:

> First is procedural.  RFC 2518 exists, and has a fixed and 
> known set of
> authors.  When we have discussions like this, is the 
> underlying assumption
> that the conceptual model of RFC 2518 was either unclear, internally
> inconsistent, or mistaken (perhaps because it can't be 
> extended to support
> new ideas like BIND?)  another way to say this, are we trying to
> retroactively induce a consistent conceptual model for something that
> already exists, or design something for the future.
> 

My own goal would be to establish what the object model for DAV SHOULD be.
If that requires us to violate RFC 2518, so be it. That is why it is called
a Proposed Standard. That means it can and will change. But, BTW, we should
not be to ready to change RFC 2518. If we do we will be required, if not by
IETF process then by common sense/market pressures, to make changes in such
a way that RFC 2518 clients/servers can continue to operate correctly.

> Precept #1a - An HTTP client sends an HTTP request message  
> to a server
> (which is a process running on a specific host at a specific 
> port).  The
> server interprets the URL in the request.  If the URL identifies a
> resource, the server relays the method to the resource.  If 
> not, server
> interprets the method. For some methods, a 404 is issued.  For others,
> something else happens.  What that something else is depends, 
> on a case by
> case basis.
> 
> This precept is more complicated, but does not require the 
> ficticious "null
> resource" neeed in Corollary #1.3  
> 

What is the difference between throwing in a new object, called a server,
and describing an instance of a resource called the null resource? They are,
point for point, the exact same idea. The big difference is that a null
resource allows us to leverage an object model with a single object and
describe behaviors with it. Talking about the server throws us into a lot of
really awful questions about how an implementation is put together. What
happens when a proxy is involved? What happens when I have a server farm?
What about a three tier system? I generally prefer to opt for the cleanest
abstraction, I believe that declaring there is one and only one object - a
resource and then basing everything off that single object will be the
cleanest way to go. Therefore I strongly prefer Precept #1.

Yaron



