docno="lists-039-14785969"
received="Wed Jan  5 23:25:36 2000"
isoreceived="20000106042536"
sent="Wed, 5 Jan 2000 23:25:29 -0500"
isosent="20000106042529"
name="Geoffrey M. Clemm"
email="geoffrey.clemm@rational.com"
subject="Re: Translation in the Tower of Babble"
id="10001060425.AA18642@tantalum"
inreplyto="7DE119D3D0E15543874F7561EECBDBED0261A043&#64;BEG.platinum.corp.microsoft.com"
expires="-1"


To:w3c-dist-auth@w3.org


   From: Eric Sedlar [mailto:esedlar@us.oracle.com]
   Well the bottom line is whether or not Geoff is interested in 
   using such a model ;-)

   From: Yaron Goland <yarong@Exchange.Microsoft.com>
   A'int that the truth.
   Although I'm now in negotiations for a new position at MS that would allow
   me to return my attentions to WebDAV. So Geoff, don't get too comfy. =)

Well, I'm far more interested in getting it right than being
comfortable (:-), so I'm all for any change that increases Yaron's
participation.

Now, as for the object model.  I am an enthusiastic supporter of
the creation of an object model, and support most of Yaron's first
pass at such a beast (except for the semantics of DELETE).

In fact, his model clearly illustrates (to me, anyway :-) the
problems associated with trying to postulate a "null resource"
that handles methods applied to URL's that are not bound to a
"real" resource.

For example, consider the PUT method.  Yaron models this as:
   PUT(N,G):
   R = NR(N);
   If (R != NULL) {
      R.GET = G; // Future responses to GET will be G
      return;  }
   R' = R.CreateNewResource();
   NR(N) = R';
   R'.GET = G;
   return;

Note that this is not modeled as functions on resources,
but rather as a computation being performed by some other
entity (I'll call it a "server") that has the key piece of
data, "NR", which defines the current name-to-resource mapping
defined by that server.  But to be fair, we should examine
whether this function could be recast as a function on the
current resource identified by that URL.

I'm willing to let the "R = NR(N)" slide, and agree that could
be modeled as the implicit dereferencing of a name that is
automagically performed before any request is "handled".

The "If" statement could be just a placeholder for a type dispatch,
and then the R.GET=G is clearly a method on the resource, so we're
fine until then.

But then we get to the case where the method is being handled by
the "null resource" (R == NULL).  Having "CreateNewResource" as
a method on R is somewhat suspect, but I probably could live with that.
It's the next line, "NR(N) = R", that illustrates the problem.
Where did NR come from?  My answer would just be that the PUT method
is really being handled by the *server* (which has an "NR" feature),
and is only dispatched to a resource when there already is a resource
bound to the specified name.

The DELETE method is also clearly handled by the object that owns the
NR map (i.e. what I'm calling the server).  Here, I'll use my
definition of DELETE (but the same argument applies to Yaron's
definition):

   DELETE(N):
   If (NR(N) == NULL) {
      error("no resource at specified URL");
      return;
   }
   NR(N) = NULL;
   return;

Again, DELETE is a method that is handled by the server (i.e. the
object that owns the NR attribute), not by the resource currently
bound to the specified URL.

As Jason points out though, Yaron's initial model (which I think
is a good model for HTTP, and so I'll call it "the HTTP model")
does not adequately model the collection semantics of WebDAV.
To do so, we have to supplement the "NR" feature of a server with
the "bindings" feature of a collection.  Since this is probably
a separate thread, I'll address this in a subsequent message.

Cheers,
Geoff



