docno="lists-041-2091859"
received="Tue Apr 30 03:45:21 2002"
isoreceived="20020430074521"
sent="Tue, 30 Apr 2002 09:12:30 +0200"
isosent="20020430071230"
name="Stefan Eissing"
email="stefan.eissing@greenbytes.de"
subject="Re: HTTP If-* headers, etags"
id="A2640A46-5C09-11D6-BBE9-00039384827E@greenbytes.de"
charset="US-ASCII"
inreplyto="86bsc2e6pc.fsf&#64;unx51.staff.flyingcroc.net"
expires="-1"

Cc:w3c-dist-auth@w3c.org
To: Erik Seaberg<erk@flyingcroc.com>



Am Montag den, 29. April 2002, um 19:49, schrieb Erik Seaberg:

> Jason Crawford <ccjason@us.ibm.com> writes:
>
>> One thing I was concerned about is resources whose GET output
>> changes often in hard to predict ways[....] But I think the answer
>> to that is, you don't do a PUT against the live resource.
>
> Are servers commonly expected to keep GET on a source resource bitwise
> identical with the last PUT?  It seemed transcoding, canonicalizing,

Not at all. Etags are no CRC on the content - a client cannot
calculate an ETag before the PUT.

> or other postprocessing at PUT time would be expected to routinely
> change strong ETags (in fact we do that sort of thing to deter abuse
> of a free hosting service).  Are common clients unable to accomodate
> this?

Etags are not to be touched by caching proxies. With transcoding 
proxies,
I'm not sure what they should do.

To answer your question: I don't think that any plain HTTP or WebDAV
client will be confused by rapidly changing Etags as such.

However, the other side of the coin is that it makes sense for editable
content (say a PDF document) to keep their ETag between PUTs. Clients
can then use the ETag (and are indeed encouraged to do this) to check
for unexpected changes to the document they are about to replace.

//Stefan



