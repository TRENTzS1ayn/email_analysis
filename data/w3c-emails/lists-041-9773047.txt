docno="lists-041-9773047"
received="Tue Aug 20 06:43:04 2002"
isoreceived="20020820104304"
sent="Tue, 20 Aug 2002 12:42:32 +0200"
isosent="20020820104232"
name="Julian Reschke"
email="julian.reschke@gmx.de"
subject="RE: New RFC2518bis draft, COPY / MOVE of live properities"
id="JIEGINCHMLABHJBIGKBCEEOFFCAA.julian.reschke@gmx.de"
charset="us-ascii"
inreplyto="6584FB7C-B3BA-11D6-8317-0003931036B4&#64;adobe.com"
expires="-1"

To:"Dan Brotsky"<dbrotsky@adobe.com>,<w3c-dist-auth@w3c.org>



> From: w3c-dist-auth-request@w3.org
> [mailto:w3c-dist-auth-request@w3.org]On Behalf Of Dan Brotsky
> Sent: Monday, August 19, 2002 11:27 PM
> To: w3c-dist-auth@w3c.org
> Subject: Re: New RFC2518bis draft, COPY / MOVE of live properities
>
>
>
> On Thursday, August 1, 2002, at 09:49 AM, Jason Crawford wrote:
> > Unless I hear otherwise, I'm going to mark COPY_LIVE_PROPS as
> > resolved...
>
> Sorry to react so late to this; I've been on sabbatical.
>
> > Resolved: 8/1/02: COPY should do the equivalent of a GET/PROPFIND
> > followed by PUT/PROPPATCH. - MOVE should maintain the integrity of the
> > resource in that all live properties and behaviors should remain live
> > and have the same semantics at the new location as at the old location.
> > If there is any doubt "same" is defined according to the resource
> > author's concept of "this resource".
>
> I'm not saying I necessarily disagree, but I'm worried by the fact that
> this definition distinguishes between COPY and MOVE in a way that's
> quite different from what many other (well-implemented) specs do.
> Consider the following:
>
> 1. Many specs define MOVE as the atomic equivalent of COPY followed by
> DELETE.  Wait a minute, actually 2518 does too!  Wouldn't this
> "clarification" break this?

Yes.

> 2. (Separate but related issue; don't think it's on the issue list.)
> There is no reason to *require* COPY to create a *new* resource; in
> fact, that's quite a problem for servers that implement copy-on-write
> semantics.  I believe the key sentences in the current RFC are:
>
> Subsequent alterations to the destination resource will not modify
>     the source resource.  Subsequent alterations to the source resource
>     will not modify the destination resource.
>
> which of course there are many ways to implement.

Yes, but that's an implementation detail. Even if you implement the copy as
copy-on-write, for the *client* it will be a new resource nevertheless.

> ...



