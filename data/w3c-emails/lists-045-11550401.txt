docno="lists-045-11550401"
received="Thu Aug  2 15:02:19 2001"
isoreceived="20010802190219"
sent="Thu, 2 Aug 2001 15:01:08 -0400"
isosent="20010802190108"
name="edsimon@xmlsec.com"
email="edsimon@xmlsec.com"
subject="RE: Re: Re: XPath Expression"
id="3B5F179F0000314D@mail.san.yahoo.com"
charset="iso-8859-1"
inreplyto="7874BFCCD289A645B5CE3935769F0B520C3441&#64;tigger.PureEdge.com"
expires="-1"


To: John Boyer<JBoyer@PureEdge.com>, merlin<merlin@baltimore.ie>
Cc:reagle@w3.org,bdournaee@rsasecurity.com,w3c-ietf-xmldsig@w3.org

Thanks John,

I was always curious why the XSLT identity transform specified "node() |
@*" if node() matches attributes.  I think your explanation solves the mystery.

Ed
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Hi Ed, 

<ed> 
One more question, is node() in XPath supposed to match attributes?  When

I read XPath, it seems like it should but my experience with XSLT makes

it seem like node() matches all node types but attributes.  
</ed> 

<jb> 
node() will match anything, but the problem is that it will only match nodes
on the axis being used. The axes for elements (child, descendant, ancestor,
parent, etc.) purposefully exclude attributes and namespaces.  However,
if you are on an attribute or namespace axis, then node() matches the nodes
on that axis.  So, node() is kind of useless on these axes because the axes
don't contain multiple types of nodes.

</jb> 




-----------------------------------------------------------------------------------------------
Ed Simon
XMLsec Inc.

Interested in XML Security Training and Consulting services?  Visit "www.xmlsec.com".



