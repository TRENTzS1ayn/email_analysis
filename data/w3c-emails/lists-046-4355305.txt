docno="lists-046-4355305"
received="Fri Mar 15 06:59:39 2002"
isoreceived="20020315115939"
sent="Fri, 15 Mar 2002 12:55:43 +0100"
isosent="20020315115543"
name="Gregor Karlinger"
email="gregor.karlinger@iaik.at"
subject="RE: New XPath Filter Transform"
id="00c101c1cc18$57196cd0$51981b81@iaik.at"
charset="us-ascii"
inreplyto="20020314210510.13F624422C&#64;yog-sothoth.ie.baltimore.com"
expires="-1"

To:"'merlin'"<merlin@baltimore.ie>,"'John Boyer'"<JBoyer@pureedge.com>
Cc:"'TAMURA Kent'"<kent@trl.ibm.co.jp>,<w3c-ietf-xmldsig@w3.org>,<reagle@w3.org>


> -----Original Message-----
> From: w3c-ietf-xmldsig-request@w3.org 
> [mailto:w3c-ietf-xmldsig-request@w3.org] On Behalf Of merlin
> Sent: Thursday, March 14, 2002 10:05 PM
> To: John Boyer

[...]

> I strongly feel that the current specification is wrong. I 
> don't think that it will be materially faster, and I do think 
> is is non-intuitive and that it goes against the spirit of 
> the transform model. Adding more options that perform 
> similar, but subtlely different operations will only serve to 
> confuse matters.
> 
> However, this is just my opinion; I'm open to input from others!

I agree with Merlin regarding the feeling that the current speci-
fication does not fit in the general idea of having a chain of
transforms, where the second transform operates on the output of
the first transform.

Of course - as John does - it can be argued that the XPath Filter
transform does not violate the model in principal, but I am SURE
that it will cause lots of misunderstandings since people think
that the XPath filter transform will operate on the result of 
the previous transform in the chain, and not on the whole 
document.

To make my feeling clear, consider the following example:

<root>
  <child1>
    <grandChild1/>
    <grandChild2/>
  </child1>  
  <child2>
    <grandChild1/>
    <grandChild2/>
  </child2>
</root>

If I were a programmer using XMLDSIG and not knowing the inherent 
secrets ;-) of the XPath filter transform, I would use the following
transfroms to select

  <child1>
    <grandChild1/>
  </child1>   

(1) Use a XPath filter transform "include" to select the child1.
(2) Use a XPath filter transform "exclude" to exclude grandChild2.

But, as the transform is currently specifed the actual result would
be:   

<root>
  <child1>
    <grandChild1/>
  </child1>  
  <child2>
    <grandChild1/>
    <grandChild2/>
  </child2>
</root>

John: Could you please explain in more detail, where you expect the
big difference regarding performance between the current include/exclude
and a set intersection/exclusion as Merlin suggests?

Regards,
Gregor




application/x-pkcs7-signature attachment: smime.p7s




