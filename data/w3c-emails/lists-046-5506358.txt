docno="lists-046-5506358"
received="Wed Jul 10 13:27:56 2002"
isoreceived="20020710172756"
sent="Wed, 10 Jul 2002 13:27:49 -0400"
isosent="20020710172749"
name="Joseph Reagle"
email="reagle@w3.org"
subject="Re: Comments on XPath Filter 2.0 draft (2002-06-20)"
id="200207101327.49541.reagle@w3.org"
charset="iso-8859-1"
inreplyto="02f001c22813$4253c0f0$2305a8c0&#64;iaik.at"
expires="-1"

To:"Gregor Karlinger"<gregor.karlinger@iaik.at>,<merlin@baltimore.ie>,"'John Boyer'"<JBoyer@PureEdge.com>
Cc:"XMLSigWG"<w3c-ietf-xmldsig@w3.org>



On Wednesday 10 July 2002 09:11 am, Gregor Karlinger wrote:
> Fine again.

I tried to reflect these in [1], but I'm not sure if the tweaks intended to 
elide the previous second and third points -- Marlin later said he wanted 
the second point retained. So let me know if I got it right. Also, what is 
meant by "passed" below?



[1]http://www.w3.org/Signature/Drafts/xmldsig-filter2/Overview.html#sec-ProcModel
$Revision: 1.20 $ on $Date: 2002/07/10 17:25:01 $ GMT by $Author: reagle $
    * Process each node in the input node-set document, adding each node
       to the output node-set F if a flag Z is true. The flag is computed
       as follows:
          + Z is true if and only if the node is present in any
            subtree-expanded union node-set and all subsequent
            subtree-expanded intersect node-sets but no subsequent
            subtree-expanded subtract node-sets, or false otherwise. If
            there are no subsequent intersect or subtract node-sets, then
            that part of the test is automatically passed.
          + Presence in a subtree-expanded node-set can be efficiently
            determined without actually expanding the node-set, by simply
            maintaining a stack or count that identifies whether any
            nodes from that node-set are an ancestor of the node being
            processed.
          + The initial value of Z is irrelevant because it will be
            automatically computed when the first document node is
            processed.

   Implementers MAY further observe that, if this transform is followed
   by a canonicalization operation, the described filter computation can
   be efficiently commingled with the document-order canonicalization
   processing.



