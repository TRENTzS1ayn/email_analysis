docno="lists-047-13651742"
received="Thu Jun 28 13:23:38 2001"
isoreceived="20010628172338"
sent="Thu, 28 Jun 2001 17:56:34 +0100"
isosent="20010628165634"
name="Graham Klyne"
email="Graham.Klyne@Baltimore.com"
subject="Re: Of &quot;reification&quot; (and sealing wax?)"
id="5.0.2.1.2.20010628170041.03891240@joy.songbird.com"
charset="us-ascii"
inreplyto="v04210106b760ff0c4f15&#64;[205.160.76.181]"
expires="-1"


To: pat hayes<phayes@ai.uwf.edu>
Cc:w3c-rdfcore-wg@w3.org

At 10:51 AM 6/28/01 -0500, pat hayes wrote:
>Yes, and I was here assuming that the inner triples in the reification 
>were intended to be RDF. I still think they should be, but lets go along 
>with your idea for now.

Thanks... this is intended as an exploration of an idea, not a proposal.

>>I now see that my use of the notation (p s o) was wrong.
>>
>>I was intending to use (p s o) as a function application in this 
>>case.  Thus, I was trying to say something like:
>>
>>  I(" id rdf:type rdf:Statement .
>>      id rdf:predicate p .
>>      id rdf:subject s .
>>      id rdf:object o . " )
>>
>>      = (= id (I("p") I("s") I("o")))      [NOTE1] [NOTE2]
>>
>>where I("p"), I("s") and I("o") are provided by some other part of the 
>>interpretation, and I("p") is a binary predicate.  In words, the 
>>quadruple above means that the symbol "id" is bound to some binary 
>>predicate associated with "p" applied to argument values associated with 
>>"s" and "o" respectively.
>
>OK, but what does that mean? In normal logic, the result of applying a 
>binary predicate to two arguments is a truthvalue (T if the pair of 
>arguments is in the extension of the relation, F otherwise.) So do you 
>mean here to identify id with a truthvalue? (I doubt it :-)

Yes, that was what I intended... "id" is identified with the truthvalue 
obtained by evaluating (I("p") I("s") I("o")). ...

>  Or do you mean to say that id is the sentence? Or do you mean something 
> else, like a proposition? (Exactly what a proposition is, is debateable, 
> but one widely used notion is that it is a function from possible worlds 
> to truthvalues.) The only thing that actually has the *syntax* still 
> intact is the sentence (in one form or another: we could quibble about 
> whether a sentence is a string or a set of triples or whatever, but let's 
> not.)  It's just like a function call in a programming language: once you 
> actually evaluate the thing, all you have is the value. If you want to 
> keep the code around, then you'd better not call it.

... but this is interesting.  If the original "s" and "o" are constants 
then I don't think anything is gained by preserving information about the 
structure of the expression.  But if they are variables (i.e. their 
denotation is not defined by the Interpretation alone) then I suppose the 
interpretation has to take this into account.

(This takes me back into the part of model theory that I'm struggling to 
fully comprehend.  The pieces make sense, but I fail to quite grasp how 
they all work together.)

The closest I can come at this time is that the interpretation (I("p") 
I("s") I("o")) is not so much a truth value as a "recipe" for obtaining a 
truth value, which may depend on a variable substitution function.  Let D 
be the domain of interpretation, then:
   I("p") : D -> ( D -> TruthValue )
   I("s") : D
   I("o") : D

If "s" is a constant, then I("s") is a value defined directly by the domain.
If "s" is a (free) variable, then I("s") is a value defined by some 
variable subtitition, say V("s").  Then, given some variable substitution 
function V, (I("p") I("s") I("o")) evaluates as a TruthValue.  Similarly 
for "o".

The Scott/Strachey approach to programming language semantics uses 
something like this:

   I("s") : N+D
   I("o") : N+D
   I("p") : D -> ( D -> ( V -> TruthValue ) )
            { so (I("p") Vsub) yields a TruthValue, for any variable 
substitution Vsub }

where:
   D is the domain of interpretation
   N is a domain of variable names
   V : N+D -> D   is a domain of variable substitutions

Then:

  I(" id rdf:type rdf:Statement .
      id rdf:predicate p .
      id rdf:subject s .
      id rdf:object o . " )

      =  (= I("id") ((lambda (v)) (I("p") (v I("s")) (v I("o")))))

Now, the interpretation of "id" is bound to a function from a variable 
substition to a TruthValue:

    I("id") : V -> TruthValue


>>[NOTE1] I'm assuming here that I("id") = id -- that identifiers in the 
>>language represent the same identifier in the domain of interpretation -- 
>>is this valid?
>
>Well, we can define I in any way we like; but this is, shall we say, unusual.

OK, probably a bad idea.


>>Then using your definition (lambda (x y)(if x then T else y)) for 'or', 
>>and 'id' as above:
>>
>>  (or id id) = (or (I("p") I("s") I("o")) (I("p") I("s") I("o")) )
>>               ((lambda (x y)(if x then T else y))
>>                        (I("p") I("s") I("o"))
>>                        (I("p") I("s") I("o")))
>>               ... etc.
>
>You stopped just when it was getting interesting. Now evaluate that 
>lambda-expression. You bind x and y both to (I("p") I("s") I("o")), then 
>you ask if x, ie (I("p") I("s") I("o")), is true. Well, is it? If that 
>denotes a truthvalue the question at least makes sense, but what if it 
>does not?

Before I introduced variable substitutions, I think this would have worked 
just fine, as a truthvalue was intended.  Now I think I'd need to define an 
alternative version of "or" here that accepts and applies the variable 
subsitution:

  (lambda (x y)
     (lambda (v) (if (v x) then T else (v y))))

#g


------------------------------------------------------------
Graham Klyne                    Baltimore Technologies
Strategic Research              Content Security Group
<Graham.Klyne@Baltimore.com>    <http://www.mimesweeper.com>
                                 <http://www.baltimore.com>
------------------------------------------------------------



