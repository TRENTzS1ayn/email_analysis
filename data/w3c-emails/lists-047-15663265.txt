docno="lists-047-15663265"
received="Mon May 21 11:28:24 2001"
isoreceived="20010521152824"
sent="Mon, 21 May 2001 16:27:55 +0100"
isosent="20010521152755"
name="Brian McBride"
email="bwm@hplb.hpl.hp.com"
subject="Re: A shot at      http://www.w3.org/2000/03/rdf-tracking/Overview.html#rdfms-resource-semantics"
id="3B0933FB.9BD2C1A6@hplb.hpl.hp.com"
charset="us-ascii"
inreplyto="5.0.2.1.2.20010511155742.03ed3430&#64;joy.songbird.com"
expires="-1"


CC:w3c-rdfcore-wg@w3.org

Graham Klyne wrote:
> 
> I kind of like this general approach, but there's one thing I would pick up
> on at this point...

> 
> I would say there is a mapping D : (RxP) -> E,  where "P" is some arbitrary
> set of parameter data.  I think something like this is needed to capture
> the idea that there may be an arbitrary number of entities associated with
> a resource, varying over time, content negotiation, location, identity of
> enquirer, etc., etc.

I agree with this.  I left it out for simplicity.  I think of D as a lambda
expression of your function with the P arguments bound in.

This also extends to define a meaning for reification.  Given a resource RS,
which is a reified statement, then D(RS) = (p, s, o) for some p, s and o.

> >     D((p,s,o)) <=> D(p)(D(s),D(o))
> 
> I don't follow this last bit.

Yes, got that bit wrong.  What I had in mind was define an interpretation
function for statements.

There is an Interpretation Function I : Statements -> REL that

   I((p,s,o)) = D(p)(D(s),D(o))

where REL is the set of binary relations D(R) x (D(R) u L), L = the set of
literals,
which, forgiving a little slopiness of expression, is basically saying that
a statement is interpretted as an relationship between a resource and either
another resource, or a literal.

And of course:

  I({s1, s2, ... sn}) = I(s1) & I(s2) & ... & I(sn)

Which is how I make sense of some of the recent discussions on RDF logic re
reification.

What does the following mean, i.e. what is that value of I:

  {(rdf:type, rs, rdf:Statement),
   (rdf:subject, rs, theSky),
   (rdf:predicate, rs, hasColor),
   (rdf:object, rs, blue),
   (foo:signedBy, rs, Brian)}

 D(rs) = (hasColor, theSky, blue)

so we have:

  D(foo:signedBy)(D(rs), D(Brian)) & ... [omitting unnecesary bits - i.e.
handwaving]

= D(foo:signedBy((hasColor, theSky, blue), D(Brian))

Which is not the same as;

  D(foo:signedBy(D(hasColor)(D(theSky), D(blue)), D(Brian))

Certainly one of the issues that keeps coming up on RDF logic is that a way
to represent both of the above expressions is needed, and they perceive
that RDF only gives them one.

Brian



