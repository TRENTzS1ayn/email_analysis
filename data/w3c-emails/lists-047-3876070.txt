docno="lists-047-3876070"
received="Sun Dec 16 20:20:44 2001"
isoreceived="20011217012044"
sent="Mon, 17 Dec 2001 03:20:34 +0200"
isosent="20011217012034"
name="Patrick.Stickler@nokia.com"
email="Patrick.Stickler@nokia.com"
subject="RE: DATATYPING: second draft"
id="A03E60B17132A84F9B4BB5EEDE57957B160B44@trebe006.NOE.Nokia.com"
charset="iso-8859-1"
inreplyto="DATATYPING: second draft"
expires="-1"


To:bwm@hplb.hpl.hp.com,melnik@db.stanford.edu,w3c-rdfcore-wg@w3.org

> And this led me to wondering about Patrick's suggestion that 
> a literal is 
> in fact a pair.

The literal is not the pair, rather the pairing is an abstract
construct that may be defined by various idioms -- but the pairing
unambiguously infers/denotes/identifies a single mapping as defined
in Sergey's draft. 

See the attached graphic for how I view the relation between mapping 
and pairing. Both uniquely identify a value, and a pairing denotes
a specific mapping, but an explicit representation of a mapping would
require a canonical representation of the value yet the pairing avoids
this need by only pointing to the lexical form and data type, and
relying on the defined semantics of data typing (as outlined in 
Sergey's draft) to ensure that only one unique value (and mapping)
is unambiguously denoted by the pairing.

> So what if  ...
>                   we extended n-triples so that literals MAY have an 
> associated datatype.

This seems, in a way, to be a reduction of PDU to just PU (and the 
pronounciation does not necessarily mean the idea "stinks" ;-)

>  ...
> 
> to a processor that 'understands' the xsd:integer and eg:oct 
> datatypes.

My concern is that (a) we are employing vocabulary/semantics from
XML Schema which may not be meaningful to other data typing schemes
and (b) the kind of processing involved requires understanding of
the data types themselves, so in what way is it within the scope
of the RDF graph proper, more so than the semantics of any particular
application-specific vocabulary (I am viewing a given data type and
its associated semantics/characteristics as no different from an
application specific ontology, and if applications wish to make use
of knowledge expressed in specific data types/ontologies, then they
must know what those data types/ontologies "mean"). The RDF graph
simply captures the expression of that knowledge, not its interpretation,
per se.

Finally, even if we are able to handle some entailment issues
without executing the actual mappings (or expressing them explicitly
in the graph) I don't see how we can't handle entailment relating to 
the N:1 mapping from lexical space to value space (i.e. is "010" the
same value as "10") without either normalizing the lexical space to a 
canonical lexical space or to a canonical application value space; and 
determination of such entailment then seems outside the scope of RDF 
if RDF is to remain a fully generic and application independent
formalism.

Eh?

Cheers,

Patrick

--
               
Patrick Stickler              Phone: +358 50 483 9453
Senior Research Scientist     Fax:   +358 7180 35409
Nokia Research Center         Email: patrick.stickler@nokia.com





application/octet-stream attachment: data-types.png




