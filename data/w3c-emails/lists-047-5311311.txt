docno="lists-047-5311311"
received="Thu Jul 12 12:54:23 2001"
isoreceived="20010712165423"
sent="Thu, 12 Jul 2001 17:51:57 +0100"
isosent="20010712165157"
name="Brian McBride"
email="bwm@hplb.hpl.hp.com"
subject="Re: rdfms-literal-is-xml-structure: Why?"
id="3B4DD5AD.337F9EC2@hplb.hpl.hp.com"
charset="us-ascii"
inreplyto="EMEKICCGFEKJFGKMFLEPIELKDAAA.rdaniel&#64;interwoven.com"
expires="-1"


To: Ron Daniel<rdaniel@interwoven.com>
CC:connolly@w3.org, RDF Core<w3c-rdfcore-wg@w3.org>



Ron Daniel wrote:
[...]
> I note that 'Jena' is one implementation that already provides access
> to a list of the declared namespaces. I think that is enough to meet
> this requirement.

I wish that were true.  Jena currently just returns
a list of the namespaces used in predicates in a model.

What I think is needed here is that an RDF parser, when it encounters a
parseType="Literal" would need to encode any active namespace prefix's
in the literal representation, e.g.

  <rdf:Description xmlns:foo="http://foo">
    <foo:property rdf:parseType="Literal">
      <foo:bar>foobar</foo:bar>
    </foo:property>
  </rdf:Description>

its not enough for the literal just to represent "<foo:bar>foobar</foo:bar>".
It must also represent xmlns:foo="http://foo".

Jena/RDFFilter don't do this at present :(  

Interesting problems arise when one mixes such literals with inconsistent 
namespace prefix definitions, e.g. merge the above with a model:


  <rdf:Description xmlns:foo="http://bar">
    <foo:property rdf:parseType="Literal">
      <foo:bar>foobar</foo:bar>
    </foo:property>
  </rdf:Description>

and write it out as RDF/XML

Or possibly also:

  <rdf:Description xmlns:foo="http://bar">
    <foo:property rdf:parseType="Literal">
      <foo:bar foo:attr="foo:attrv">
    </foo:property>
  </rdf:Description>

Brian



