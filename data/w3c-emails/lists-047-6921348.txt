docno="lists-047-6921348"
received="Sun Jul 22 06:47:44 2001"
isoreceived="20010722104744"
sent="Sun, 22 Jul 2001 11:44:59 +0100"
isosent="20010722104459"
name="Brian McBride"
email="bwm@hplb.hpl.hp.com"
subject="Re: N-Triples: Naming anonnodes"
id="3B5AAEAB.FD4BFFD@hplb.hpl.hp.com"
charset="us-ascii"
inreplyto="200107220330.f6M3UUF05968&#64;theinfo.org"
expires="-1"


To: Aaron Swartz<me@aaronsw.com>
CC:w3c-rdfcore-wg@w3.org



Aaron Swartz wrote:
[...]
> Today I came up with the idea that we could define anonymous
> nodes as having a special representation in the abstract syntax,
> but define the N-Triples conversion from RDF as having a
> well-defined set of names for them. IOW, an algorithm such as
> the one used by SiRPAC or CARA to generate anonymous nodes in
> order could be specified somehow (using XSLT, for example), and
> all RDF/XML parsers which outputted N-Triples could follow this
> specification. That way, comparison of N-Triples documents could
> be reduced to a simple sort/diff operation, while still
> retaining the semantics of anonymous nodes.
> 
> An example:
> <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
> <rdf:Description>
>    <rdf:value>foo</rdf:value>
> </rdf:Description>
> </rdf:RDF>
> 
> could be unambiguously defined as:
> 
> _:g0 rdf:value "foo" .
> 
> as parsers would use anonymous node names in the form of _:gn
> where n begins at zero and increments for each anonymous node
> reached in the XML.
> 
> Obviously this wouldn't work for N-Triples output from a data in
> which ordering information had been lost (I have some ideas on
> that one too, but they are less formed) but it would work for
> any RDF/XML -> N-Triples conversion.

Nice idea.  Basically this would allow easy compare of models that
came from the same RDF/XML serialization.

One thing it wouldn't handle is the following example:

 <rdf:Description>
  <foo:bar>foobar</foo:bar>
 </rdf:Description>
 <rdf:Description>
  <bar:foo>barfoo</bar:foo>
 </rdf:Description>

compared to:

 <rdf:Description>
  <bar:foo>barfoo</bar:foo>
 </rdf:Description>
 <rdf:Description>
  <foo:bar>foobar</foo:bar>
 </rdf:Description>

These are representations of equivalent graphs which graph compare
will find equivalent.

What about:

  <rdf:Description>
    <foo:type rdf:about="http://foo#Class">
    <foo:bar>
      <rdf:Desription/>
    </foo:bar>
  </rdf:Description>

and

  <foo:Class>
    <foo:bar>
      <rdf:Description/>
    </foo:bar>
  </foo:Class>

If they are to compare equivalent, the element number cannot be used.

This approach would also seem to imply that the ordering of the RDF/XML
is significant.  So if two processors were to have an internal
representation of the same model, would they have to write it out in
the same order to ensure that the RDF/XML produced compared equal.
If so, we are back into the complexities of graph theory.

Brian



