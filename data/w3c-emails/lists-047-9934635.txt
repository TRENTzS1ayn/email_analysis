docno="lists-047-9934635"
received="Tue Jun 12 22:00:21 2001"
isoreceived="20010613020021"
sent="Tue, 12 Jun 2001 19:26:14 -0700"
isosent="20010613022614"
name="Sergey Melnik"
email="melnik@db.stanford.edu"
subject="Hammer vs. tweezers"
id="3B26CF46.BADD8407@db.stanford.edu"
charset="us-ascii"
expires="-1"


To: RDFCore WG<w3c-rdfcore-wg@w3.org>

I'm sorry to intrude into the issue-resolving process with a hammer
rather than tweezers. Although we are bound to backward compatibility in
many respects, I think we still have a chance to nail down some shaky
pieces of the frame. Putting off the metaphors, I'd like to suggest
several incremental layers for the RDF model spec, and a way of building
advanced languages on top of those. The idea is to keep each layer thin,
and to provide model-theoretic semantics a la
http://www.daml.org/2001/03/model-theoretic-semantics.html for each
layer. Application developers may choose to support a certain subset of
layers. Tentatively, I could imagine the following layering:

- Layer 1: Abstract syntax based on resources and triples only (no
literals, no predefined vocabulary, no reification). Namespaces are part
of the formal model (missing in current spec). Interpretation
(semantics) is specified using a model-theoretic approach.

- Layer 2: Literals are declared as a specific kind of resources
belonging to a certain namespace (e.g. http://www.w3.org/.../Literal).
Literals may be used as subjects (this is an extension).

- Layer 3: Reification added to abstract syntax (e.g. as a symbol for a
partial function). Interpretation of the reification function maps DxDxD
to D (D is domain of discourse). The corresponding vocabulary elements
(subject, predicate, object) may be defined here (rdf:type still
missing). Reified statements are first-class objects in the model, i.e.
applications may implement them as Java classes, database tuples with
IDs etc. Statements are directly mapped to individuals in the domain of
discourse, no resources/URI that identify them are required per se
(identifiers for statements can be introduced later on if needed).

- Layer 4: rdf:type is introduced as a basic typing mechanism (broader
than class instantiation).

- Layer 5: defines e.g. containers (for backward compatibility only. I
think containers are a topic of its own, and belongs to the issues like
representing order, aggregation etc.)

- (more model features...)

This proposal might seem radical, but I think most of the suggestions
are incremental. The features listed above (namespaces, literals,
reification etc.) are intended to be backward compatible and may be
introduced in a different order. The semantics of a language "built on
top of RDF" (like DAML/OIL) can be defined by restricting interpretation
functions used in the existing layers or by defining new ones.
Specifying "new" semantics in this way may result in a larger or smaller
number of valid interpretations. The set of statements that are subject
of semantic interpretation can be selected in an unspecified,
application-specific way.

Since semantics proved to be a highly controversial issue, I would
suggest to strictly split each layer into abstract syntax (+ examples) /
formal semantics part. The developers who care about running apps more
than about formal semantics may ignore the parts they don't want to deal
with.

Sergey



