docno="lists-048-1180704"
received="Wed Nov  7 05:39:04 2001"
isoreceived="20011107103904"
sent="Wed, 7 Nov 2001 12:38:47 +0200 "
isosent="20011107103847"
name="Patrick.Stickler@nokia.com"
email="Patrick.Stickler@nokia.com"
subject="RE: datatypes: inheritence in schema RE: datatypes and MT"
id="2BF0AD29BC31FE46B7887732114404316216FA@trebe003.NOE.Nokia.com"
charset="iso-8859-1"
inreplyto="datatypes: inheritence in schema RE: datatypes and MT"
expires="-1"


To:jjc@hplb.hpl.hp.com,w3c-rdfcore-wg@w3.org



> -----Original Message-----
> From: ext Jeremy Carroll [mailto:jjc@hplb.hpl.hp.com]
> Sent: 07 November, 2001 12:03
> To: w3c-rdfcore-wg@w3.org
> Subject: datatypes: inheritence in schema RE: datatypes and MT
> 
> 
> >
> > The alternate is to impose the requirement that all lexical
> > forms of all data types be valid lexical forms for all
> > superordinate types of that data type. Ouch. Tough to
> > verify...
> >
> > Granted, XML Schema seems to comply with such a requirement
> > (I haven't checked rigorously though). But whether we
> > could actualy empose such a requirement (either reasonably
> > or practically) is questionable.
> >
> 
> 
> 
> So, the simple types do appear to follow this.
> 
> The  derived types satisfy this by construction.
> 
> Derivation by restriction
> http://www.w3.org/TR/xmlschema-2/#derivation-by-restriction
> satisfies this by construction.
> 
> 
> Derivation by list
> http://www.w3.org/TR/xmlschema-2/#derivation-by-list
> and by union
> http://www.w3.org/TR/xmlschema-2/#derivation-by-union
> satisfies this by virtue of not having a superclass (other than
> anySimpleType)
> 
> 
> The primitive datatypes inherit from anySimpleType, which appears by
> definition to be a union of all the other types, and hence Patrick's
> condition is satisfied.

Right. But just because XML Schema types satisfy this
condition (possibly by intent, possibly by coincidence)
I'm not sure we can impose such a condition on any 
arbitrary data types.

Thus, should one wish to use hex notation for integers,
and defines a subclass of xsd:integer called xxx:hex it would
not have a lexical form that is valid for xsd:integer.

I think we need instead to take an approach by which
all typed data literals are specified locally for type
and range definitions are only prescriptive for locally
typed values.

> The complex types (which have XML elements - see message 
> later this morning)
> seem more difficult, and I think in general Patrick's 
> condition is false. I
> am new to XML schema though, having only read part 2 last 
> week, and parts 0
> and 1 last night.

I never intended to include complex types insofar as
the above condition was stated. Though, as complex types
must at some point terminate in simple types, the condition
still applies.

Though it opens up the can of worms about what it means
to say that some subgraph is of a given XML Schema complex
type, when the purpose of that complex type is to define
an XML subtree, not an RDF subgraph.

I would interpret our charter to mean that we relate RDF to
XML Schema *simple* data types only, as they apply to literals,
and not complex data types (but I may very well be wrong there).

Cheers,

Patrick



