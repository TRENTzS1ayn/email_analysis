docno="lists-048-1304500"
received="Wed Nov  7 07:47:25 2001"
isoreceived="20011107124725"
sent="Wed, 7 Nov 2001 14:47:09 +0200 "
isosent="20011107124709"
name="Patrick.Stickler@nokia.com"
email="Patrick.Stickler@nokia.com"
subject="RE: incomplete datatyping (was: Re: datatypes and MT)"
id="2BF0AD29BC31FE46B788773211440431621701@trebe003.NOE.Nokia.com"
charset="iso-8859-1"
inreplyto="incomplete datatyping (was: Re: datatypes and MT)"
expires="-1"


To:jjc@hplb.hpl.hp.com,Graham.Klyne@MIMEsweeper.com,phayes@ai.uwf.edu
Cc:melnik@db.stanford.edu,w3c-rdfcore-wg@w3.org



> -----Original Message-----
> From: ext Jeremy Carroll [mailto:jjc@hplb.hpl.hp.com]
> Sent: 07 November, 2001 13:23
> To: Graham Klyne; Pat Hayes
> Cc: Sergey Melnik; w3c-rdfcore-wg@w3.org
> Subject: RE: incomplete datatyping (was: Re: datatypes and MT)
> 
> 
> >
> > Suppose that in addition to:
> >
> >    monthOfBirth rdfs:range xxd:EnglishCalendarMonth .
> >
> > we can also presume:
> >
> >    monthOfBirth rdfs:range xxd:decimalInteger .
> >
> > (this being legit RDF) ... might the allow us to write:
> >
> >    _y monthOfBirth "July" .
> >
> > OR
> >
> >    _y monthOfBirth "7" .
> >
> > ?
> >
> > There are two points I see here:  (a) multiple datatype 
> classes might
> > permit ambiguity in the value denoted by a given literal string,
> > and (b) a
> > literal value might not have a defined mapping under some
> > presumed datatype
> > class.
> >
> 
> 
> I believe these issues are addressed by using an XML Schema 
> union and then
> following the example at
> 
> http://www.w3.org/TR/xmlschema-2/#union-datatypes
> [[[
> 
> For example, given the definition below, the first instance 
> of the <size>
> element validates correctly as an integer (?3.3.13), the 
> second and third as
> string (?3.2.1).
> 
>   <xsd:element name='size'>
>     <xsd:simpleType>
>       <xsd:union>
>         <xsd:simpleType>
>           <xsd:restriction base='integer'/>
>         </xsd:simpleType>
>         <xsd:simpleType>
>           <xsd:restriction base='string'/>
>         </xsd:simpleType>
>       </xsd:union>
>     </xsd:simpleType>
>   </xsd:element>
> 
>   <size>1</size>
>   <size>large</size>
>   <size xsi:type='xsd:string'>1</size>
> 
> ]]]
> 

Ahhh... here's where it gets really interesting...

Do we mirror this derived type definition in the RDFS defined
class hierarchy? I.e., do we need to define xsd:integer and
xsd:string as a subClassOf xxx:size, so that folks can
define values such as [ rdf:value "1"; rdf:type xsd:integer ]
for properties with a range of xxx:size?

Or should an RDF/RDFS engine testing range constraints also
be an XML Schema data type engine able to parse and understand
native XML Schema derived type defintions?

And that example of "1" being defined as a xsd:string is
pretty nasty, showing that even with explicit XML Schema 
type definitions you can have logical gotchas. Yowza! 

Of course, by asserting that all literals be specified for
type, we can put the burden of accuracy on the content 
producer and reduce the potential for ambiguity in interpretation.
Thus, even though <size xsi:type='xsd:string'>1</size> is
technically valid, it's a logical error that the content producer
is responsible for, yet the error is explicit and not "missed"
because it is has some possible interpretation according to
the union of allowed data types.

Of course, it also shows bad design in that in reality, the string
sub-type is more likely an enumeration of a controlled token set 
and not just a string, so the "1" as a string should be caught
as an error ;-)

Patrick



