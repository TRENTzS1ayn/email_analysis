docno="lists-048-1317653"
received="Wed Nov  7 07:47:45 2001"
isoreceived="20011107124745"
sent="Wed, 07 Nov 2001 12:42:52 +0000"
isosent="20011107124252"
name="Brian McBride"
email="bwm@hplb.hpl.hp.com"
subject="Re: ACTION 2001-11-02#02: Datatyping use-cases from CC/PP"
id="3BE92C4C.90901@hplb.hpl.hp.com"
charset="us-ascii"
inreplyto="2BF0AD29BC31FE46B7887732114404316216FE&#64;trebe003.NOE.Nokia.com"
expires="-1"


To:Patrick.Stickler@nokia.com
CC:phayes@ai.uwf.edu,w3c-rdfcore-wg@w3.org



Patrick.Stickler@nokia.com wrote:
[...]


>>
> 
> Well, I'm presuming that if no rdfs:subClassOf statements
> were encountered which define that relation prior to 
> testing the range constraint, that one could not know for
> sure that the type absolutely was not a subtype, ever,
> but insofar as the knowledge present at hand, it would not 
> be and the test of the constraint should fail.


Or you could just infer that the value must be of that type as well.

Validation is kinda tricky in RDFS.  If I understand it correctly, RDFS has no 
means of expressing negation, so can't express a contradiction.

You can define validation to mean that there is specific confirmation that all 
domain and range constraints are met.  I guess that is what you had in mind. 
RDFS does not currently define any concept of validation.


> 
> This is of course, presuming that the type is defined locally
> and a range is defined, otherwise the test can't even be made.
> 
> But this is a good thing. After all, constraints are how we
> ensure proper operation of our systems. If I define a range
> constraint that says that some property value must be
> an xsd:integer and thus my system expects decimal notation, and 
> I get [ rdf:value "12"; rdf:type foo:bar ] where I have no clue 
> what data  type 'foo:bar' corresponds to, then I can't be *sure* 
> that I have a lexical form that corresponds to an integer expressed
> in decimal notation. It could be a value in hexidecimal notation. 
> So the constraint fails as it should, since in this case, an RDFS
> processor cannot satisfy that foo:bar is a subClassOf xsd:integer
> and the data is rejected as unreliable. That's what constraints 
> are for. Right?


They can be used in that way.


> 
> If I later load some schema that says that foo:bar is a 
> subclass of e.g. xsd:decimal, great, now the constraint is
> satisfied and I know both that the value is a valid xsd:integer 
> (since xsd:decimal is a subClassOf xsd:integer) and I know that 
> the lexical form follows decimal notation. OK, now I can use it.
> 
> It's all about having the information needed to interpret
> the lexical form. Some of that information is local. Some is
> in the schema. Both are needed.


In the case of the P proposal that is true, because RDF/XML does not allow 
literals as subjects.  It is not true in the case of the S or X proposals which 
permit the information needed to represent a lexical form to represented without 
a schema.

It really helps understand these points if we are specific about which proposal 
we are talking about.

Brian



