docno="lists-048-14113367"
received="Tue Sep 18 07:19:45 2001"
isoreceived="20010918111945"
sent="Tue, 18 Sep 2001 11:57:52 +0100"
isosent="20010918105752"
name="Graham Klyne"
email="Graham.Klyne@MIMEsweeper.com"
subject="Re: rdfs:Literal question"
id="5.1.0.14.2.20010918115336.00a090d0@joy.songbird.com"
charset="us-ascii"
inreplyto="p0510100fb7cc2088587f&#64;[205.160.76.175]"
expires="-1"


To: Pat Hayes<phayes@ai.uwf.edu>
Cc:w3c-rdfcore-wg@w3.org

At 04:57 PM 9/17/01 -0500, Pat Hayes wrote:
>>My take is that it provides a way of characterizing the things that 
>>literals denote.
>>
>>So even if
>>   LLL rdf:type rdfs:Literal .
>>is not valid syntax, I think it's reasonable to be able to say that LV
>>(as in XL: qLiteral -> LV) is the same as ICEXT(I(rdfs:Literal)).
>
>Well, there is something very odd about having a constraint that is 
>perfectly clear, perfectly natural, and assumed in the semantics, but 
>being unable to say it in the formal language, especially when its 
>perfectly clear HOW to say it in the formal language. (Its a bit like not 
>being able to assert subclass loops, in fact :-)

Well, yes.  I sort-of assume the shackles will one day be removed from 
literals-as-subjects, but I'm just trying to make sense of that with which 
we are given to deal.

It did occur to me that, after I wrote the comment above, the capability is 
arguably redundant now we have a formal model theory to work with.  Our 
predecessors maybe had to introduce rdfs:Literal to give themselves some 
vocabulary to talk about what you constructed with ( XL : qLitereal -> LV )?

#g


------------------------------------------------------------
Graham Klyne                    MIMEsweeper Group
Strategic Research              <http://www.mimesweeper.com>
<Graham.Klyne@MIMEsweeper.com>
------------------------------------------------------------



