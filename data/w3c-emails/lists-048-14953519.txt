docno="lists-048-14953519"
received="Thu Sep 20 18:42:15 2001"
isoreceived="20010920224215"
sent="Fri, 21 Sep 2001 00:41:55 +0100"
isosent="20010920234155"
name="jos.deroo.jd@belgium.agfa.com"
email="jos.deroo.jd@belgium.agfa.com"
subject="Re: model theory publication draft"
id="OF51C1CDA6.762DF7E6-ON41256ACD.007F1245@bayer-ag.com"
charset="us-ascii"
inreplyto="model theory publication draft"
expires="-1"

To:phayes@ai.uwf.edu
Cc:w3c-rdfcore-wg@w3.org




>>  and I think it all goes very well except for rule 1.
>> I currently don't see how to implement that with a back-chaining reasoner.
>> Any hint?
> I guess I don't see what the problem is. Can you elaborate?

of course
we want to see the entailment
  |- rdfs:range rdf:type rdfs:Property.
i.e. out of nothing (besides those rules of course)
now we do this with a back-chaining engine
so we try to satisfy
  rdfs:range rdf:type rdfs:Property.
and to satisfy that, we must satisfy
  :s :p :o.
where :p is unbound (if I may speak that way)
and we just don't find a reasonable way to do that

> Pat
>
> PS. Why do you ever need to backchain? I think you can use the rules as
> though they were a production system: as soon as a LHS matches, fire
> the rule (and check its not duplicating anything) then re-start
> searching from the beginning of the list. If you ever get to the end,
> stop.

agreed, that's certainly a possibility, but we
are trying backchaining, and I believe there
is a possiblilty (maybe something like universal
elimination rule generation???)

PS. we have a similar thing for existential introduction rule
    generation for premis and query statements with unlabeled
    nodes and that works amazingly well

Jos



