docno="lists-048-1519135"
received="Wed Nov  7 12:28:05 2001"
isoreceived="20011107172805"
sent="Wed, 7 Nov 2001 19:27:47 +0200 "
isosent="20011107172747"
name="Patrick.Stickler@nokia.com"
email="Patrick.Stickler@nokia.com"
subject="RE: Literals: lexical spaces and value spaces"
id="2BF0AD29BC31FE46B78877321144043162170A@trebe003.NOE.Nokia.com"
charset="iso-8859-1"
inreplyto="Literals: lexical spaces and value spaces"
expires="-1"


To:phayes@ai.uwf.edu
Cc:w3c-rdfcore-wg@w3.org



> -----Original Message-----
> From: ext Pat Hayes [mailto:phayes@ai.uwf.edu]
> Sent: 07 November, 2001 18:42
> To: Stickler Patrick (NRC/Tampere)
> Cc: w3c-rdfcore-wg@w3.org
> Subject: RE: Literals: lexical spaces and value spaces
> 
> 
> Greetings. You again used the term 'prescriptive':
> 
> >ASSERTION:
> >   Range definitions are *only* prescriptive, and *only* when
> >   local type is defined for values. Any assignment of type
> >   for a value must be made locally for each occurrence of the
> >   value.
> 
> Can you say what this means? I am not able to follow what it is you 
> have in mind.

It means, that if you encounter a literal value which
is not specified for type locally, that you cannot (or
rather should not) use any defined range defined for
the property to which the value is bound to determine
the type of the literal.

Thus if one has

   #x foo:someProperty "10" .

   foo:someProperty rdfs:range xsd:integer .

then the range definition does not assign the data
type of xsd:integer to "10", and the constraint
can be said to fail due to lack of information.

However, if one has

   #x foo:someProperty [ rdf:value "10"; rdf:type xsd:string ] .

   foo:someProperty rdfs:range xsd:integer .

then the range property can be tested against the known
data type of the value, and in this case, the constaint
fails to be satisfied.

The reason why a range definition cannot be descriptive
of non-locally typed literals, is because lexical form
is specific to a given data type, and the binding of
a value to a given property may occur by various means
and one can end up with a literal value having a lexical
form that is not compatible with the data type of the
property.

This, of course, presumes that we are not asserting the
global constraint on data types that the lexical space of
any data type must be a proper subset of the lexical space
of all of its superordinate types. 

Is that clearer?

Patrick



