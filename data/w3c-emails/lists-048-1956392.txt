docno="lists-048-1956392"
received="Thu Nov  8 18:41:21 2001"
isoreceived="20011108234121"
sent="Thu, 8 Nov 2001 17:41:31 -0600"
isosent="20011108234131"
name="Pat Hayes"
email="phayes@ai.uwf.edu"
subject="Re: incomplete datatyping (was: Re: datatypes and MT)"
id="p05101016b810c5ec53c8@[65.212.118.147]"
charset="us-ascii"
inreplyto="5.1.0.14.2.20011107100444.03febb90&#64;joy.songbird.com"
expires="-1"


To: Graham Klyne<Graham.Klyne@MIMEsweeper.com>
Cc: Sergey Melnik<melnik@db.stanford.edu>,w3c-rdfcore-wg@w3.org

>There's a wrinkle here that occurs to me...
>
>At 10:32 PM 11/6/01 -0600, Pat Hayes wrote:
>>>_y firstName "Sergey"
>>>_y lastName "Melnik"
>>>_y monthOfBirth "July"
>>>_y dayOfBirth "Tuesday"
>>>
>>>I'd see that as only meaningful if you also said how to interpret 
>>>the literals. So for example I presume it might be kosher to assume
>>firstName rdfs:range xsd:string .
>>lastName rdfs:range xsd:string .
>>but that we might also need something like
>>monthOfBirth rdfs:range xxd:EnglishCalendarMonth
>
>[...]
>
>>>You are saying that as long as there is no schema it's a literal value.
>>>Once a schema is there, it becomes a data value. To satisfy
>>>monotonicity, all data values must then necessarily be literal values,
>>>right?
>>
>>I don't know what a data value is. By literal value I meant the 
>>semantic value of the literal, ie the value of the XL mapping 
>>applied to the literal. So a literal always denotes the same thing 
>>in a given datatype interpretation, but when no schema information 
>>is present, there are several alternative such interpretations 
>>which satisfy the graph, and it might denote something different in 
>>each one.
>>
>>Nothing *changes* when schema information is added, exactly, but 
>>the set of satisfying datatype interpretations is reduced, in the 
>>usual way, and that may be enough to fix the interpretation of the 
>>literal in all the interpretations that satisfy the graph.
>
>Suppose that in addition to:
>
>   monthOfBirth rdfs:range xxd:EnglishCalendarMonth .
>
>we can also presume:
>
>   monthOfBirth rdfs:range xxd:decimalInteger .
>
>(this being legit RDF)

Hmmm, but it wouldn't be legitimate in datatyped RDF (unless those 
two datatypes had a common superordinate datatype) in the sense that 
there would be no datatyped interpretation satisfying it, because the 
semantic conditions on the MT extension would always give 
inconsistent mappings.

This is interesting, and I hadn't noticed it before. The MT extension 
provides a sufficiently strong semantic constraint that it is 
possible to write inconsistent RDF in this extended semantics. But 
you know, I think this is always going to be possible (except with 
the RDV idea), because for example someone could write:

aaa eg:prop _:x
_:x xxd:decimalInteger  foo
_:x xxd:EnglishCalendarMonth foo

and that is legit RDF as well.

>... might the allow us to write:
>
>   _y monthOfBirth "July" .
>
>OR
>
>   _y monthOfBirth "7" .
>
>?
>
>There are two points I see here:  (a) multiple datatype classes 
>might permit ambiguity in the value denoted by a given literal 
>string,

Inconsistency.

>and (b) a literal value might not have a defined mapping under some 
>presumed datatype class.
>
>(a) I see as not really being different from the case where no 
>datatype class information is available, except that it seems to run 
>counter to the conjunctive nature of type information.

I think it is conjunctive and it is more like (P and  (not P)), 
rather than (P or (not P))

>(b) if no mapping is provided by a presumed datatype class, how does 
>this affect the truth of the corresponding statement?

It makes it true in some typed interpretations and false (presumably) 
in others, but you don't know which is the intended one.

Pat


-- 
---------------------------------------------------------------------
IHMC(850)434 8903   home
40 South Alcaniz St.(850)202 4416   office
Pensacola,  FL 32501(850)202 4440   fax
phayes@ai.uwf.edu 
http://www.coginst.uwf.edu/~phayes



