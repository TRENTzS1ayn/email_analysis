docno="lists-048-2046847"
received="Thu Nov  8 20:39:23 2001"
isoreceived="20011109013923"
sent="Thu, 8 Nov 2001 19:39:29 -0600"
isosent="20011109013929"
name="Pat Hayes"
email="phayes@ai.uwf.edu"
subject="RE: Literals: lexical spaces and value spaces"
id="p0510101eb810e18dce4b@[65.212.118.147]"
charset="us-ascii"
inreplyto="2BF0AD29BC31FE46B78877321144043162170A&#64;trebe003.NOE.Nokia.com"
expires="-1"


To:Patrick.Stickler@nokia.com
Cc:w3c-rdfcore-wg@w3.org

>  > -----Original Message-----
>>  From: ext Pat Hayes [mailto:phayes@ai.uwf.edu]
>>  Sent: 07 November, 2001 18:42
>>  To: Stickler Patrick (NRC/Tampere)
>>  Cc: w3c-rdfcore-wg@w3.org
>>  Subject: RE: Literals: lexical spaces and value spaces
>>
>>
>>  Greetings. You again used the term 'prescriptive':
>>
>>  >ASSERTION:
>>  >   Range definitions are *only* prescriptive, and *only* when
>>  >   local type is defined for values. Any assignment of type
>>  >   for a value must be made locally for each occurrence of the
>>  >   value.
>>
>>  Can you say what this means? I am not able to follow what it is you
>>  have in mind.
>
>It means, that if you encounter a literal value which
>is not specified for type locally, that you cannot (or
>rather should not) use any defined range defined for
>the property to which the value is bound to determine
>the type of the literal.
>
>Thus if one has
>
>    #x foo:someProperty "10" .
>
>    foo:someProperty rdfs:range xsd:integer .
>
>then the range definition does not assign the data
>type of xsd:integer to "10",

OK so far ( I disagree, but I know what you are saying), but...

>and the constraint
>can be said to fail due to lack of information.

...I have no idea what that means. What 'constraint'? What does it 
mean to 'fail'? (Do you mean that there is an inconsistency 
somewhere?)

>However, if one has
>
>    #x foo:someProperty [ rdf:value "10"; rdf:type xsd:string ] .
>
>    foo:someProperty rdfs:range xsd:integer .
>
>then the range property can be tested against the known
>data type of the value, and in this case, the constaint
>fails to be satisfied.

This seems to me to be a clear inconsistency, assuming that strings 
cannot be integers.

However, I am at a loss to understand how it is that in the second 
case, the range statement apparently is sufficient to force an 
inconsistency with the local type assertion, while in the first case 
it is insufficient to determine the type. You can't have it both 
ways: the inference to a type clash in the second case depends on the 
same inference path that you are rejecting in the first case.

>
>The reason why a range definition cannot be descriptive
>of non-locally typed literals, is because lexical form
>is specific to a given data type,

true

>and the binding of
>a value to a given property may occur by various means

true

>and one can end up with a literal value having a lexical
>form that is not compatible with the data type of the
>property.

true, if the datayping information given in somehow incorrect. But 
the same can be said for a local type; if you give the wrong datatype 
information, things will go wrong. You have such an example above, in 
fact.  What has that got to do with the local/nonlocal distinction?

>
>This, of course, presumes that we are not asserting the
>global constraint on data types that the lexical space of
>any data type must be a proper subset of the lexical space
>of all of its superordinate types.

Ah, but we must make that assumption; I have already conceded that point.

Pat
-- 
---------------------------------------------------------------------
IHMC(850)434 8903   home
40 South Alcaniz St.(850)202 4416   office
Pensacola,  FL 32501(850)202 4440   fax
phayes@ai.uwf.edu 
http://www.coginst.uwf.edu/~phayes



