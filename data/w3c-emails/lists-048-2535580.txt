docno="lists-048-2535580"
received="Mon Nov 12 15:47:18 2001"
isoreceived="20011112204718"
sent="Mon, 12 Nov 2001 22:46:58 +0200"
isosent="20011112204658"
name="Patrick.Stickler@nokia.com"
email="Patrick.Stickler@nokia.com"
subject="RE: Literals: lexical spaces and value spaces"
id="2BF0AD29BC31FE46B78877321144043162174F@trebe003.NOE.Nokia.com"
charset="iso-8859-1"
inreplyto="Literals: lexical spaces and value spaces"
expires="-1"


To:phayes@ai.uwf.edu
Cc:w3c-rdfcore-wg@w3.org


> >and one can end up with a literal value having a lexical
> >form that is not compatible with the data type of the
> >property.
> 
> true, if the datayping information given in somehow incorrect. But 
> the same can be said for a local type; if you give the wrong datatype 
> information, things will go wrong. You have such an example above, in 
> fact.  What has that got to do with the local/nonlocal distinction?

But if the type is determined by the rdfs:range constraint,
and the type is different between the original property of
the statement and some superordinate property that the literal
is bound to by inference, an error in interpretation can occur,
as one will be determining the data type by the range defined
for the superordinate property which may not have a compatible
lexical space.

The literal may be unparsable or may be misinterpreted.

Thus, given the data

 aaa ex:hexShoeSize "12" .
 ex:hexShoeSize rdfs:subPropertyOf ex:shoeSize .
 ex:hexShoeSize rdfs:range foo:hexInteger .
 foo:hexInteger rdfs:subPropertyOf xsd:integer .
 ex:shoeSize rdfs:range xsd:integer.

And a query

 aaa ex:shoeSize ?x .

Which is satisfied as
 -> x = "12"

Which based on the knowledge

 ex:shoeSize rdfs:range xsd:integer

Gets interpreted as

 int value = parseLiteral(xsd:integer,"12")

 value = 12

BOOM!   (should be 18!)

Eh?   ;-)

Thus, either literals must be bound to types locally,
or literals must be inseperable from their original
predicates.

Both are satisified if statements are the basis for
interpretation and query binding.

> >This, of course, presumes that we are not asserting the
> >global constraint on data types that the lexical space of
> >any data type must be a proper subset of the lexical space
> >of all of its superordinate types.
> 
> Ah, but we must make that assumption; I have already conceded 
> that point.

But XML Schema simple data types fail that requirement. Thus,
we cannot make that assumption. Only value spaces for XML
Schema simple types are proper subsets of the value spaces
of their superordinate types. Lexical space is specific to
each type. I had hoped that was not the case, but it is.

Patrick



