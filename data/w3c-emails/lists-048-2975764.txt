docno="lists-048-2975764"
received="Tue Nov 13 19:38:07 2001"
isoreceived="20011114003807"
sent="Tue, 13 Nov 2001 18:38:08 -0600"
isosent="20011114003808"
name="Pat Hayes"
email="phayes@ai.uwf.edu"
subject="RE: ACTION 2001-11-02#02: Datatyping use-cases from CC/PP"
id="p0510103eb81766ad70fb@[65.212.118.147]"
charset="us-ascii"
inreplyto="2BF0AD29BC31FE46B788773211440431621742&#64;trebe003.NOE.Nokia.com"
expires="-1"


To:Patrick.Stickler@nokia.com
Cc:w3c-rdfcore-wg@w3.org

>  > >  that one could not know for
>>  >sure that the type absolutely was not a subtype, ever,
>>  >but insofar as the knowledge present at hand, it would not
>>  >be and the test of the constraint should fail.
>>
>>  That would not be a valid assumption. In general, you should not make
>>  any closed-world assumptions; more information can always arise
>>  later. If something follows from the knowledge presently at hand,
>>  then it must also follow from any larger set of knowledge; so if a
>>  later addition *could* consistently assert a subClassOf relation,
>>  then you cannot assume that such a relation is false.
>
>I'm not saying it's false. I'm saying the test of the constraint
>fails. Those are very different things.

Then please define the second one (in terms I can understand?). 
RDF(S)  makes assertions; as far as I can tell, that is all it does. 
An assertion is true or false in every interpretation. Where in this 
picture are there any 'constraints' other than assertions?

>At any given time, a system must be able to make decisions
>based on the knowledge it has.

It must be able to draw conclusions. (I do not know what it would 
mean for RDF(S) to make a *decision*, exactly. ) Those conclusions 
should still follow when more information is added (monotonicity), so 
they had better not follow from the limitations or size of the 
system's local knowledge.

>It determines the validity
>or sufficiency of the knowledge relevant to that decision
>at the time the decision must be made. It may make a different
>decision later, if the knowledge changes or expands, but
>the validity or sufficiency of a given statement is not
>the same thing as truth or falsity.

I have no idea what 'sufficiency' of a statement means. Validity 
means preservation of truth; an inference is valid when the 
conclusion is true in every interpretation which makes the 
assumptions true. Adding extra information to the assumptions should 
not make a valid inference become invalid.

>Any knowledge based system, at a single point in time, is
>a kind of closed world.

WRONG, a thousand times wrong. That is a traditional 'database' 
assumption, but it is not appropriate for the semantic web or RDF. 
(Take this up with the higher authorities; it is out of scope for the 
RDF WG to argue this point, I think.)

>  > >This is of course, presuming that the type is defined locally
>>  >and a range is defined, otherwise the test can't even be made.
>>
>>  What sense of 'locally' do you have in mind? (Local to what?)
>
>See my glossary at the start of the X proposal I just sent out.

You don't define the term there either.

>
>>  >So the constraint fails
>>
>>  Why? Nothing 'fails' here; you just have incomplete information.
>
>Right, sorry for sloppy language. The constraint cannot be satisfied
>and therefore the test fails. I.e., insofar as a system that needs
>to make a decision, inability to confirm the validity of a value
>is the same as an invalid value.

No, it is not the same. This is like saying that larger is the same 
as smaller because they both imply not-equal.

>  > >as it should, since in this case, an RDFS
>>  >processor cannot satisfy that foo:bar is a subClassOf xsd:integer
>>  >and the data is rejected as unreliable.
>>
>>  NO!! Absolutely not. You cannot 'reject' data as unsuitable just
>>  because it is incomplete. New data might arise at any time.
>
>YES! YES! YES! ;-)
>
>If my system needs to make a decision, and it can't determine if some
>value is acceptable, then it has every right to reject that value
>as suitable for the task at hand.

What task does RDF(S) ever 'have at hand'?

I really don't have time to argue this very basic point about 
nonmonotonicity with you. RDFS is a monotonic reasoner, period. To 
change that would take us WAY outside our charter, and in any case I 
strongly believe it should not be changed.

>  Rejection doesn't mean deleting
>the knowledge from the knowledge base.
>It just means not using it
>(or knowing what to do with it) at a given point in time.

That doesn't mean ANYTHING. Of course any process is always free to 
NOT use any information at any time.

>I think you are being a little to philosophical in your views here.

I take it that you move in circles in which to be 'too philosophical' 
is an insult, roughly synonymous with 'having head in clouds', 'out 
of touch with reality' , etc.? Believe me, if you want to get 
philosophical, we have hardly even BEGUN.

>Real world systems must make real decisions in real time with
>real knowledge.

I will happily assent to any platitude.

>Yes, that knowledge may change, but inability to verify a critical
>test due to insufficient knowledge is the basically the same as the
>test failing on sufficient knowledge insofar as real time decisions
>are concerned.

I disagree strongly. First, you havn't said what you mean by 'test' 
and 'fail'; but insufficient knowledge is NOT the same as incorrect 
knowledge, and I insist that we do not make the basic error of 
confusing them.

>
>>  >That's what constraints
>>  >are for. Right?
>>
>>  Who mentioned constraints?
>
>Ummm... the RDFS Spec.

Ah, I see. But it is careful to avoid the implications that you are 
putting on the usage of the term (Section 3, 2nd para):

"RDF Schema provides a mechanism for describing such constraints, but 
does not say whether or how an application must process the 
constraint information. For example, while an RDF schema can assert 
that an author property is used to indicate resources that are 
members of the class Person, it does not say whether or how an 
application should act in processing that class information. We 
expect that different applications will use these constraints in 
different ways - e.g., a validator will look for errors, an 
interactive editor might suggest legal values, and a reasoning 
application might infer the class and then announce any 
inconsistencies."

It is clear that as far as RDFS is concerned, a 'constraint' is 
simply an assertion about ranges and domains.

Pat

-- 
---------------------------------------------------------------------
IHMC(850)434 8903   home
40 South Alcaniz St.(850)202 4416   office
Pensacola,  FL 32501(850)202 4440   fax
phayes@ai.uwf.edu 
http://www.coginst.uwf.edu/~phayes



