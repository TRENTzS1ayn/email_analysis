docno="lists-048-3187371"
received="Wed Nov 14 05:48:38 2001"
isoreceived="20011114104838"
sent="Wed, 14 Nov 2001 12:48:30 +0200"
isosent="20011114104830"
name="Patrick.Stickler@nokia.com"
email="Patrick.Stickler@nokia.com"
subject="RE: ACTION 2001-11-02#02: Datatyping use-cases from CC/PP"
id="2BF0AD29BC31FE46B78877321144043114C08E@trebe003.NOE.Nokia.com"
charset="iso-8859-1"
inreplyto="ACTION 2001-11-02#02: Datatyping use-cases from CC/PP"
expires="-1"


To:phayes@ai.uwf.edu
Cc:w3c-rdfcore-wg@w3.org


> >I'm not saying it's false. I'm saying the test of the constraint
> >fails. Those are very different things.
> 
> Then please define the second one (in terms I can understand?). 

I'm trying... believe me...

> RDF(S)  makes assertions; as far as I can tell, that is all it does. 
> An assertion is true or false in every interpretation. Where in this 
> picture are there any 'constraints' other than assertions?

What you suggest is that if we have

  someProperty rdfs:range someType .

and 

  someResource someProperty _:1:"foo" .
  _1:"foo" rdf:type someOtherType .

we end up with

  someResource someProperty _:1:"foo" .
  _1:"foo" rdf:type someOtherType .
  _1:"foo" rdf:type someType .
 
since RDFS only "asserts" things.

Now, if someOtherType is not a subClassOf someType, then
we should flag some sort of error about the incompatible
data types, right?

What this means is that, if rdfs:range is used in
a descriptive sense, you end up with the above
un-flagged conflict.

If  rdfs:range is used in a prescriptive sense, as
a true constraint, it doesn't add the statement

  _1:"foo" rdf:type someType .

but provides the means for determining whether the
statement

  _1:"foo" rdf:type someOtherType .

is acceptable within the scope of the given property.

> >At any given time, a system must be able to make decisions
> >based on the knowledge it has.
> 
> It must be able to draw conclusions. (I do not know what it would 
> mean for RDF(S) to make a *decision*, exactly. ) 

I didn't say that *RDF* makes those decisions. A computer
*SYSTEM* operating on RDF encoded knowledge makes those
decisions.

> I have no idea what 'sufficiency' of a statement means. 

I'm an engineer, and speaking in engineering terms (and
general, loose terms at that). Please try not to read too
much formalism into my explanations. I know that formalism
is good, and would result in better understanding, but
I have to work with the vocabulary I know.

I'm an engineer, not a mathematician, but then, this group 
needs all types, right?

> Validity 
> means preservation of truth; 

As in an XML instance being Valid? ;-)

> >Any knowledge based system, at a single point in time, is
> >a kind of closed world.
> 
> WRONG, a thousand times wrong. That is a traditional 'database' 
> assumption, but it is not appropriate for the semantic web or RDF. 
> (Take this up with the higher authorities; it is out of scope for the 
> RDF WG to argue this point, I think.)

Philosophize all you like, but the *reality* is that at any
given point in time when stuff has to happen in a computer
program, the knowledge it has at hand constitutes a temporally
distinct closed world -- and one may say that independent of
temporal progression it is not a closed world, but that just
doesn't cut it insofar as software operation is concerned.

The benefit of RDF is that it allows for transparent progression
along the sequence of temporally distinct closed worlds without
modification to the software logic.

Whether or not this is within or outside the scope of this WG
is unclear to me, and probably beside the point anyway...

> >  > >This is of course, presuming that the type is defined locally
> >>  >and a range is defined, otherwise the test can't even be made.
> >>
> >>  What sense of 'locally' do you have in mind? (Local to what?)
> >
> >See my glossary at the start of the X proposal I just sent out.
> 
> You don't define the term there either.

I do. Here it is again (with the clarification of property value
versus data type value):


local type

        A data type associated directly with an occurrence of a
        property value serving as the object of a statement


> >
> >>  >So the constraint fails
> >>
> >>  Why? Nothing 'fails' here; you just have incomplete information.
> >
> >Right, sorry for sloppy language. The constraint cannot be satisfied
> >and therefore the test fails. I.e., insofar as a system that needs
> >to make a decision, inability to confirm the validity of a value
> >is the same as an invalid value.
> 
> No, it is not the same. This is like saying that larger is the same 
> as smaller because they both imply not-equal.

From the viewpoint of a computer system at a point in time, it
*is* the same. This is not about philosophy, it is about executing
instructions that accomplish some useful result.

Please stop philosophizing these issues. We are not dealing with
the "UNIVERSE", we are dealing with a set of explicitly reified
statements about some universe which are intended as input to
software applications which execute instructions that accomplish 
some useful result.


> >  > >as it should, since in this case, an RDFS
> >>  >processor cannot satisfy that foo:bar is a subClassOf xsd:integer
> >>  >and the data is rejected as unreliable.
> >>
> >>  NO!! Absolutely not. You cannot 'reject' data as unsuitable just
> >>  because it is incomplete. New data might arise at any time.
> >
> >YES! YES! YES! ;-)
> >
> >If my system needs to make a decision, and it can't determine if some
> >value is acceptable, then it has every right to reject that value
> >as suitable for the task at hand.
> 
> What task does RDF(S) ever 'have at hand'?

Why do you keep interpreting "system" as meaning "RDF"?!

system != RDF

A system, or application, is a set of instructions executed by
a computer. RDF provides an expression of data that may be
meaningful to those instructions. 
 
> I really don't have time to argue this very basic point about 
> nonmonotonicity with you. RDFS is a monotonic reasoner, period. To 
> change that would take us WAY outside our charter, and in any case I 
> strongly believe it should not be changed.

I honestly don't think we are talking about the same things here.
 
> >Yes, that knowledge may change, but inability to verify a critical
> >test due to insufficient knowledge is the basically the same as the
> >test failing on sufficient knowledge insofar as real time decisions
> >are concerned.
> 
> I disagree strongly.

Then I don't think I can ever hope to get you to understand 
anything of import in my postings, because if you don't get
that, you probably won't get any of the rest.

Sorry if that's a bit harsh. I'm sure you could make equally
valid criticisms of my inability to understand or express myself
in mathematics. 

Please try to re-read the above assertion, in terms of the
last clause that begins with "INSOFAR AS" which you seem to
miss in your interpretation of what I am saying, taking my
meaning as the assertion without that final qualifying clause,
which is of course not the assertion I'm making.

> First, you havn't said what you mean by 'test' 
> and 'fail'; 

Sorry. These are common software engineering terms. I hadn't
expected to have to define them explictly.

> but insufficient knowledge is NOT the same as incorrect 
> knowledge, and I insist that we do not make the basic error of 
> confusing them.

I'm not confusing them. See the qualifying clause beginning
with "INSOFAR AS".

Saying that two things are functionally equivalent in a
given context is hardly confusing them (especially since
you must differentiate them first in order to define their
equivalence, eh?)
 
> >
> >>  >That's what constraints
> >>  >are for. Right?
> >>
> >>  Who mentioned constraints?
> >
> >Ummm... the RDFS Spec.
> 
> Ah, I see. But it is careful to avoid the implications that you are 
> putting on the usage of the term (Section 3, 2nd para):
> 
> "RDF Schema provides a mechanism for describing such constraints, but 
> does not say whether or how an application must process the 
> constraint information. For example, while an RDF schema can assert 
> that an author property is used to indicate resources that are 
> members of the class Person, it does not say whether or how an 
> application should act in processing that class information. We 
> expect that different applications will use these constraints in 
> different ways - e.g., a validator will look for errors, an 
> interactive editor might suggest legal values, and a reasoning 
> application might infer the class and then announce any 
> inconsistencies."
> 
> It is clear that as far as RDFS is concerned, a 'constraint' is 
> simply an assertion about ranges and domains.

Yes. An assertion, but not a statement. A constraint does not impart 
*ANY* properties on the resources themselves!

A constraint only says (prescribes) what should be, not what is.

Although the wording of the RDFS spec suggests the possibility of
a descriptive treatment of rdfs:range, its *primary* treatment
is prescriptive.

(and in case I inserted too few above...  ;-) ;-) ;-) ;-) ;-)

Cheers,

Patrick



