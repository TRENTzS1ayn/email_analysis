docno="lists-048-3263911"
received="Wed Nov 14 07:01:05 2001"
isoreceived="20011114120105"
sent="Wed, 14 Nov 2001 07:00:50 -0500 (EST)"
isosent="20011114120050"
name="Dan Brickley"
email="danbri@w3.org"
subject="Re: rdfs:range is primarily PRESCRIPTIVE!"
id="Pine.LNX.4.30.0111140644160.22318-100000@tux.w3.org"
charset="US-ASCII"
inreplyto="2BF0AD29BC31FE46B78877321144043114C08F&#64;trebe003.NOE.Nokia.com"
expires="-1"

To:<Patrick.Stickler@nokia.com>
cc:<phayes@ai.uwf.edu>,<w3c-rdfcore-wg@w3.org>


On Wed, 14 Nov 2001 Patrick.Stickler@nokia.com wrote:

> I can't see how anyone could read the RDFS spec and conclude
> that a *descriptive* application of rdfs:range is the primariy
> application intended!
>
> I quote:
>
> "3.1.3. rdfs:range
> An instance of ConstraintProperty that is used to indicate the
> class(es) that the values of a property *MUST* be members of."
>
> (emphasis added)
>
> Not "should", not "default to", but ***MUST***.

But nowhere is this contextualised to some specific chunk of RDF/XML under
scrutiny. "must" here is best read as "will always". The DTD-ish,
prescriptive version would have been something like "...that the values of
a property must be described as being members of in the RDF/XML under
validation". We didn't say that (thankfully...).

Yes, this is inelegantly specified; that's why we're here working on the
cleaned up version!


> So, to me, it's black and white that rdfs:range is a primarily
> prescriptive (constraint) mechanism that in some contexts *might*
> be used in a descriptive fashion, but that descriptive usage
> is NOT defined by nor required by the spec.

My apologies as RDFS editor for the confusion this has caused! :(


> > What ensures that someone doesn't have 7 fathers is presumably an
> > assertion to the effect the people have one father, or something that
> > entails that. If you want to call that a constraint, I guess that is
> > OK.
>
> A constraint is an assertion by which we can determine the
> acceptability of statements for a given purpose.

RDF is not in the business of enumerating the purposes to which it might
be put. In absence of this, what we count as a 'constraint' is
consequently somewhat underdetermined. rdfs:ConstraintResource is not (was
not) a coherently defined class.

> > >The whole *point* of being able to say that some literal "1010" is
> > >an xsd:integer rather than a foo:binary is so that we can enforce
> > >those constraints on data prior to interpretation so that our systems
> > >don't go BOOOM!
> >
> > That is one use, but it's not the only one. That information about
> > the literal and its datatype might well be useful even to something
> > that never enforces constraints or does any process called
> > 'interpretation', eg an inference engine of some kind.
> >
> > You seem to be making too narrow an assumption here, that the ONLY
> > purpose of manipulating and processing data is to input it into some
> > processor somewhere, as though all of KR was about DB datamodeling.
>
> I'm not making that assumption. But it often seems to me that
> you are disregarding the need for "manipulating and processing data"
> in "some processor somewhere".

I think you're both talking past each other. We all want to use (store,
query, reason about, print out on paper, author, disagree with, store to
read later...) RDF. There are a variety of processing and deployment
models that will get this work done using RDBMS, KR, OO etc tools. One of
the biggest challenges for RDF is that people come to RDF from different
traditions, and even seemingly harmless words like 'model' can cause
endless confusion. Neverthless, we're all trying to manipulate and process
RDF data. And most of us will be using computers of some kind to do so...


> > But more generally in any case, are you saying that RDFS itself
> > should be concerned with 'applying' constraints, worrying about what
> > happens when such tests of adequacy 'fail' and so on? All that seems
> > to me to belong outside of the RDFS world, on the other side of an
> > API somewhere.
>
> No. I'm not saying that "RDFS" does anything. No more so that
> "XML Schema" does anything. Or "Java" does anything. These are models
> for data encoding, not applications. An RDFS Validator will apply
> those constraints, yes, just as an XML Schema validator will apply
> constraints.

RDF Schema and XML Schema differ interestingly in this regard. XML Schema
validation is specified over a particular XML document infoset. An XML
*document* is schema-valid or schema-invalid. XML Schema makes that clear.
RDF simply does not work the same way. It can be used to support
applications that do work in that way. For example, Libby Miller and I
hacked up an RDF system analagous to the XML Schematron system, in which
a collection of tests are applied to some specific RDF graph, with failure
being couched in terms of the actual content of the RDF at hand. RDFS
itself doesn't provide enough to do this, it just puts some basics in
place so that apps (or richer data validation languages) could provide
such facilities.

Dan


-- 
mailto:danbri@w3.org
http://www.w3.org/People/DanBri/



