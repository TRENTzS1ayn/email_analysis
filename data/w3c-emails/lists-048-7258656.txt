docno="lists-048-7258656"
received="Thu Oct 11 18:34:10 2001"
isoreceived="20011011223410"
sent="Thu, 11 Oct 2001 17:34:03 -0500"
isosent="20011011223403"
name="Pat Hayes"
email="phayes@ai.uwf.edu"
subject="Re: new model theory for DAML+OIL"
id="p0510100ab7ebcaa9adf4@[205.160.76.193]"
charset="us-ascii"
inreplyto="20011011144921W.pfps&#64;research.bell-labs.com"
expires="-1"


To:"Peter F. Patel-Schneider"<pfps@research.bell-labs.com>
Cc:joint-committee@daml.org,w3c-rdfcore-wg@w3.org

(IF WG members feel this is going off-topic for RDF, just say so and 
we will stop CCing to RDFcore. - Pat)

>I think that this is getting close to a solution.  However, I have come up
>with a small collection of examples that we might think of handling.  I
>enclose them and their ``status''.
>
>peter
>
>
>Datatyping Examples
>
>
>Here are some datatyping examples, written in an XML-like sytax.  I think
>that these examples should be handled by any datatype extension to RDFS.
>
>Peter F. Patel-Schneider
>Bell Labs Research
>
>
>
>Untyped example:
>
>    The following should be satisfiable:
>
><Person rdf:ID="Mary">
>  <streetAddress>05</streetAddress>
></Person>
>
>    Its models should include models where Mary's streetAddress is an integer
>    and others where Mary's streetAddress is a string.
>
>STATUS:  Not OK?

I think this will work, if we are talking about typed 
interpretations, since the node typing can vary as well as the 
vocabulary. So it depends on what is meant by 'untyped'. If that 
means, in a typed language but no type specified, then its OK. If it 
means, in an untyped language, then not OK; but then you can hardly 
expect it to work in that case, right?

>
>Typing through local type names:
>
>    The following should be satisfiable:
>
><Person rdf:ID="Mary">
>  <streetAddress xsi:type="xsd:string">05</streetAddress>
>  <age xsi:type="xsd:integer">06</age>
></Person>
>
>    Its models should all have Mary's age be the integer 6, and Mary's
>    street address be the string "05".
>
>STATUS:  OK, via local type decoration.

Right

>
>Non-typing through local type names:
>
>    The following should be satisfiable:
>
><Person rdf:ID="Mary">
>  <streetAddress xsi:type="xsd:anyType">05</streetAddress>
></Person>
>
>    Its models should include models where Mary's streetAddress is an integer
>    and others where Mary's streetAddress is a string.
>
>STATUS:  Not OK.  Need types that don't pin down mapping.

Depends on what exactly "xsd:anyType" means. If types are supposed to 
obey class-heirarchy rules then this ought to work, since anyType 
would presumably(?) include all the other types as subclasses, so 
there would be typed interpretations of both kinds that would fit the 
MT constraints. (If types don't obey subclass rules, then all bets 
are off in any case for using things like rdfs:range to specify 
typing, seems to me (?))

>
>Typing through direct range restriction:
>
>   The following should be satisfiable:
>
><Person rdf:ID="Mary">
>  <age>06</age>
></Person>
>
><rdf:Property rdf:ID="age">
>  <rdfs:range rdf:resource="xsd:integer" />
></rdf:Property>
>
>    Its models should all have Mary's age be the integer 6.
>
>STATUS:  Probably OK?  Can type decorations be obtained here?

The model theory should work on this kind of case, this is what it 
was designed for.

>
>Typing through inherited range restriction:
>
>   The following should be satisfiable:
>
><Person rdf:ID="Mary">
>  <age>06</age>
></Person>
>
><rdf:Property rdf:ID="intrelation">
>  <rdfs:range rdf:resource="xsd:integer" />
></rdf:Property>
>
><rdf:Property rdf:ID="age">
>  <rdfs:subPropertyOf rdf:resource="intrelation" />
></rdf:Property>
>
>    Its models should all have Mary's age be the integer 6.
>
>STATUS:  Probably OK?
>

Yes, should be OK. As long as the range information can be inferred 
by legal rdfs it should work the same as the previous case.

Thought occurs to me, could there be an 'indirect' inference of a 
range typing via a different type restriction, so that the range 
restriction was valid but couldn't be inferred in rdfs alone? That 
might be a hard case to handle.

>Inconsistent typing:
>
>    The following should be allowed but unsatisfiable:
>
><Person rdf:ID="Mary">
>  <streetAddress>05</streetAddress>
></Person>
>
><rdf:Property rdf:ID="streetAddress">
>  <rdfs:range rdf:resource="xsd:integer" />
></rdf:Property>
>
><rdf:Property rdf:ID="streetAddress">
>  <rdfs:range rdf:resource="xsd:string" />
></rdf:Property>
>
>STATUS:  OK, through disjointness of integers and strings.
>

Yeeessss... provided that we somehow (how??) know that integers and 
strings are disjoint. OK if that is assumed by meta-magic.

>Typing from XML Schema:
>
>    The following should be allowed:
>
><xsd:element name="item">
>  <xsd:complexType>
>   <xsd:sequence>
>     <xsd:element name="quantity" type="xsd:integer">
>   </xsd:sequence>
>  </xsd:complexType>
></xsd:element name="item">
>
><item>
>  <quantity>1</quantity>
></item>
>
>   Its models should include only models where the item's quantity is the
>   integer 1.
>
>STATUS:  OK, through type decoration from XML data model?

This goes beyond my grasp of XML. However, if we can do cardinality 
restrictions using datatyping, then the datatypes are more expressive 
than the RDFS base language. Oh Ar, 'tis a strainge owld wurld, ennit?

Pat

-- 
---------------------------------------------------------------------
IHMC(850)434 8903   home
40 South Alcaniz St.(850)202 4416   office
Pensacola,  FL 32501(850)202 4440   fax
phayes@ai.uwf.edu 
http://www.coginst.uwf.edu/~phayes



