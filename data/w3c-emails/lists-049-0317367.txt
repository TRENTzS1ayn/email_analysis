docno="lists-049-0317367"
received="Thu Apr 11 06:16:04 2002"
isoreceived="20020411101604"
sent="Thu, 11 Apr 2002 12:22:30 +0200"
isosent="20020411102230"
name="Jeremy Carroll"
email="jjc@hplb.hpl.hp.com"
subject="Re: Denotation of datatype values"
id="MABBLGKMPIJFCKFGDBEPOEKFCAAA.jjc@hplb.hpl.hp.com"
charset="Windows-1252"
inreplyto="Denotation of datatype values"
expires="-1"

To:<w3c-rdfcore-wg@w3.org>


Jeremy:
> [where] the model theory stops there is an implicit and
> ill-articulated extended conceptual model

Patrick:
>  [the conceptual model?] it's meant to
> be explicit

OK. I withdraw the venom of my attack on the conceptual model, it's work in
progress. I (at least) have found your point of view clear and consistent -
although I haven't seen that as the WG's point of view; the earlier messages
in this thread seemed to want to emphasise the stringiness of "25" rather
than it's integer-ness.

Jeremy:
> But the [non-monotonicty]
> argument still stands as far as the conceptual model goes.

Patrick:
> Neither level is non-monotonic, and the datatyping level only clarifies
> but does not change the knowledge at the lower idiom level, so the
> transition between levels also is not non-monotonic.

This seems close to my discussion about non-monotonicity about containers,
so I don't think I will pursue the difference between the levels too much -
except that there is an unnecessarily broad gap. E.g. the TDL model theory
was much closer to the pair of a datatype and a string found in the
conceptual model. The breadth of this gap fails (IMO) our principle charter
goal of clarity.

As for non-monotonicity the datatyping conceptual layer that we are
discussing is non-monotonic in its own right.

e.g.

<Jane> <age> "25" .

delivers the unicode string "25", i.e. <xsd:string,"25">.

<film> <title> "25" .

similarly delivers  <xsd:string,"25">.

At this datatyping conceptual level

<Jane> <age> "25" .
<film> <title> "25" .

allows us to conclude that Jane's age and the film's title are the same.

Then we add the range constraint on <title>

<Jane> <age> "25" .
<film> <title> "25" .
<title> <range> <xsd:string> .

I take it that the range constraint changes nothing, we are still having the
value
<xsd:string,"25"> delivered in both cases, and so we are still concluding
that Jane's age and the film's title are the same.

Now we add the range constraint on <age>

<Jane> <age> "25" .
<film> <title> "25" .
<title> <range> <xsd:string> .
<age> <range> <xsd:integer> .

We now have the film's title delivered as <xsd:string,"25"> the woman's age
delivered as <xsd:integer,"25"> and they are different.
Hence we see defeasible reasoning: in the light of new information we revise
our knowledge that Jane's age is <xsd:string,"25">, which in turn causes us
to revise our conclusion that Jane's age and the film's title are the same.

This is non-mononotonic, and the WG cannot escape that by simply saying that
it is not in the MT. The only escape route is to acknowledge that in the
absence of type information, the datatype is unknown (e.g. xsd:anyType or
maybe xsd:anySimpleType). If we stay aware that
  <xsd:anyType,"25"> != <xsd:anyType,"25">
because anyType does define a mapping, then the problem begins to disappear.

Unfortunately this is bringing untidiness back into the datatyping layer. We
now are reading

<Jane> <age> "25" .

not as 'Jane's age is "25"' but as 'Jane's age can be written as "25"'. That
is rather than having a 'tidy' reading of the triple, we are having an
'untidy' reading.

If we are going to allow untidiness anywhere, it seems to me to be more
consistent and less of a intellectual somersault to allow untidiness at the
lower levels of the analysis (such as in the syntactic graph, or perhaps
only in the first level of interpretation in the model theory) rather than
sneak it in at the last moment in the final less formal layer.

I am sorry that my critique seems to jump all over the place. Fundamentally
the decision by the WG for tidiness was critically wrong. At the time, I
abstained since it felt that we were going to get a samll fudge where we had
syntactic tidiness but untidiness from there on.

As is, now any place where I attack any of the consequences of that decision
I am told that the problem is fixed elsewhere - but IMO the complete
end-to-end picture does not fix the problem.

Fixing the tidiness problem in the datatyping layer is firstly not in the
current proposal, secondly would need to be explicit and examples showing
how these critically conflict with the MT interpretation should be given,
and thirdly it is unnecessarily complicated.

The simplest fix is to allow untidy graphs (in the graph syntax).

The next simplest fix is Pat's simpleDatatypes2, which is a very elegant
fudge.

The next simplest fix is to allow an untidy interpretation of tidy graphs as
the first step in the model theory ('Jane's age can be written as "25"').

Jeremy



