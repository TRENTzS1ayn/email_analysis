docno="lists-049-0740799"
received="Fri Apr 12 03:28:14 2002"
isoreceived="20020412072814"
sent="Fri, 12 Apr 2002 10:30:53 +0300"
isosent="20020412073053"
name="Patrick Stickler"
email="patrick.stickler@nokia.com"
subject="Re: Latest iteration of RDF Datatyping WD (ship it!)"
id="B8DC67DD.12F6B%patrick.stickler@nokia.com"
charset="US-ASCII"
inreplyto="OF91D59A60.BB935102-ONC1256B98.007F3D7F&#64;agfa.be"
expires="-1"

To: ext Jos De_Roo<jos.deroo.jd@belgium.agfa.com>, Dan Connolly<connolly@w3.org>
CC: RDF Core<w3c-rdfcore-wg@w3.org>


On 2002-04-12 3:03, "ext Jos De_Roo" <jos.deroo.jd@belgium.agfa.com> wrote:

> 
>>> For those who are interested, the latest incarnation of the
>>> RDF Datatyping WD can be found at
>>> 
>>>    http://www-nrc.nokia.com/sw/rdf-datatyping.html
>> $Date: 2002/04/11 12:35:11 $
>> 
>> Hmm... on the one hand, I have been looking at each
>> draft saying "well, it doesn't have the use case
>> examples, and that's all I care about; I'll read
>> the next one."
>> 
>> But then I peeked into this one... and I mostly
>> like what I see.
> 
> well, I have concerns about the *either* ... *or* in
> 
> [[[
>  The rdfd:range property imposes a datatyping constraint
>  on its subject such that all values of the constrained
>  property must correspond *either* to a literal node
>  which is a member of the lexical space of the specified
>  datatype (a lexical form), *or* to a non-literal node
>  denoting a member of the value space of the specified
>  datatype (a datatype value) to which is attached by
>  means of either the rdf:lex property or a datatype
>  property a literal node which is a member of the lexical
>  space of the specified datatype.
> ]]]
>  -- http://www-nrc.nokia.com/sw/rdf-datatyping.html
> 
> this sounds like a union...
> and I don't see that as explained in
> http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Mar/0151.html

The semantics of rdfd:range *is* a sort of union -- but it does
not impose the union interpretation on the datatype URI (though
I thought it should) but only on the datatyping interpretation,
which imposes exactly the above constraints.

> and as I still think we should have
> rdfd:range rdfs:subPropertyOf rdfs:range .
> to keep the benefit of RDFS entailment rule3
> { :rule3 . ?s ?p ?o . ?p rdfs:range ?C } log:implies { ?o a ?C } .

This then would preclude the inline idiom. If the class extension
of the datatype URI is the value space, and rdfd:range was
a subPropertyOf rdfs:range, then any occurrence of a literal object
for a property with an rdfd:range would be a range violation.

That was the whole point of keeping rdfd:range and rdfs:range
separate. They are both of type rdfs:ConstraintProperty but
their semantics is fully disjunct.

The rdfd:range constraint *has* a union interpretation.

If we infuse rdfd:range with the semantics of rdfs:range, then
the class extension of datatype URIs must then be the union of
the lexical and value spaces (or we must remove the inline idiom,
either/or) and rdfd:range also then becomes redundant, as we can
attach the datatyping semantics (lexical form constraints)
to the datatype URI itself based on the assertion that
it is of rdf:type rdfd:Datatype.
 
>> For my money, it's good enough for 1st WD.
>> 
>> If they editors (Stickler/Hayes/Melnick)
>> are happy to publish it with their
>> names on it, I'm happy to see it go out.
> 
> --
> Jos
> 
> PS there is also some rdfs:Property stuff instead of rdf:Property

A typo. Thanks.

>  and I think we also dropped rdfs:ConstraintProperty

The discussion was dropped, but apparently not the class. If the
class actually has been dropped, then of course, that should
be changed.

>  also rule2 is not needed given
>    rdfd:range rdfs:range rdfd:Datatype .

True.

>  and rule3b is my above concern

Both rule 3a and 3b trouble me -- in that while it is important to
illustrate the semantic equivalence between the three idioms, I
would not want to see redundancy introduced into the graph simply
for that purpose. The other rules simply make explicit what is
implicit. But rules 3a and 3b say nothing new, insofar as the
datatyping interpretation is concerned (the inline and lexical
form idioms are sufficient on their own without the datatype
property idiom equivalent) and 3b introduces an explicit denotation
(bnode) for the value that is not present in the inline idiom.

Perhaps rules 3a and 3b should be removed and the equivalences
simply addressed in the verbage?

Two additional rules I have been thinking may be needed, are those
that assert the rdf:type of the blank nodes in the lexical form
and datatype property idioms: I.e.

{
   aaa rdfd:range ddd .
   bbb aaa ccc .
   ccc rdfd:lex "LLL" .
}
log:implies
{
   ccc rdf:type ddd .
}

and

{
   ddd rdf:type rdfd:Datatype .
   bbb aaa ccc .
   ccc ddd "LLL" .
}
log:implies
{
   ccc rdf:type ddd .
}



Cheers,

Patrick

--
               
Patrick Stickler              Phone: +358 50 483 9453
Senior Research Scientist     Fax:   +358 7180 35409
Nokia Research Center         Email: patrick.stickler@nokia.com



