docno="lists-049-13040401"
received="Mon Feb 11 11:13:00 2002"
isoreceived="20020211161300"
sent="Mon, 11 Feb 2002 10:13:50 -0600"
isosent="20020211161350"
name="Pat Hayes"
email="phayes@ai.uwf.edu"
subject="Re: type/dtype/subclassing and range/subproperties"
id="p0510147cb88d9d635fb6@[65.212.118.208]"
charset="us-ascii"
inreplyto="OFD9044793.78A41202-ONC1256B5A.0036B22D&#64;agfa.be"
expires="-1"


To:"Jos De_Roo"<jos.deroo.jd@belgium.agfa.com>
Cc:w3c-rdfcore-wg@w3.org

>[...]
>
>>  We may in fact need something like rdfs:drange ("deranged"? ;-)
>>  if rdfs:range only implies rdf:type and not rdf:dtype,
>
>we have that per
>{ ?d a rdf:DataType . ?p rdfs:range ?d . ?s ?p ?o } log:implies { ?o 
>rdf:dType ?d } .

Right, but that is a dtype in the conclusion, right? the rdf:type 
follows by normal rdfs inference, but the range-datatyping is 
something else that requires an extra semantic constraint. I don't 
think we need deranged unless we want to allow some ranges to 'do' 
datatyping and others not. And that can be handled, if someone wants 
to do it, by defining a coextensive class with the datatype and 
making that be the range. Then you get rdf:type inheritance (with one 
extra inference step) but the datatyping is blocked, so no rdf:dtype.

Pat

-- 
---------------------------------------------------------------------
IHMC(850)434 8903   home
40 South Alcaniz St.(850)202 4416   office
Pensacola,  FL 32501(850)202 4440   fax
phayes@ai.uwf.edu 
http://www.coginst.uwf.edu/~phayes



