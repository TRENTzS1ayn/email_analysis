docno="lists-049-1626755"
received="Wed Apr 17 05:07:34 2002"
isoreceived="20020417090734"
sent="Wed, 17 Apr 2002 10:06:19 +0100"
isosent="20020417090619"
name="Jeremy Carroll"
email="jjc@hplb.hpl.hp.com"
subject="RE: RDF Datatyping MT *does* define Datatyped Literal Pairings"
id="JAEBJCLMIFLKLOJGMELDMELACDAA.jjc@hplb.hpl.hp.com"
charset="US-ASCII"
inreplyto="B8E31234.13481%patrick.stickler&#64;nokia.com"
expires="-1"

To:"Patrick Stickler"<patrick.stickler@nokia.com>,"ext Graham Klyne"<Graham.Klyne@MIMEsweeper.com>
Cc:"Pat Hayes"<phayes@ai.uwf.edu>,"RDF Core"<w3c-rdfcore-wg@w3.org>



No it doesn't.

Consider:

<ex:age, rdfd:datatype, xsd:string>
<ex:age, rdfd:datatype, xsd:integer>
<Jenny, ex:age, "10">

Fine by the MT, "10" is in the lexical space of both datatypes.

No "TDL" pair in sight. (Or perhaps the point is that there are two TDL
inconsistent pairs around - but no inconsistency in the MT).

Jeremy


Patrick:
>>> ... the combination of the
>>> inline idiom and the rdfd:range/datatype assertion designates
>>> the pairing <xsd:integer, "10"> and that pairing is the basis
>>> for any datatyping interpretation. I.e., the knowledge in the
>>> graph unambiguously identifies a single value by designating
>>> a datatyped literal pairing. What that actual
>>> value is, we don't know *at this level*. But at a higher level
>>> where the full knowledge of xsd:integer is available, then
>>> we know that the pairing <xsd:integer, "10"> identifies the
>>> value ten.
>>>



