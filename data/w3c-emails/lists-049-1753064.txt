docno="lists-049-1753064"
received="Wed Apr 17 17:14:59 2002"
isoreceived="20020417211459"
sent="Wed, 17 Apr 2002 16:14:56 -0500"
isosent="20020417211456"
name="Pat Hayes"
email="phayes@ai.uwf.edu"
subject="Re: RDF Datatyping MT *does* define Datatyped Literal Pairings"
id="p05101504b8e392682998@[65.217.30.94]"
charset="us-ascii"
inreplyto="B8E31234.13481%patrick.stickler&#64;nokia.com"
expires="-1"


To: Patrick Stickler<patrick.stickler@nokia.com>
Cc:w3c-rdfcore-wg@w3.org

>On 2002-04-16 23:24, "ext Graham Klyne" <Graham.Klyne@MIMEsweeper.com>
>wrote:
>
>>  At 08:09 PM 4/16/02 +0300, Patrick Stickler wrote:
>>
>>>>     Jenny age "10" .
>>>>     age rdfd:range xsd:integer .
>>
>>>  ... the combination of the
>>>  inline idiom and the rdfd:range/datatype assertion designates
>>>  the pairing <xsd:integer, "10"> and that pairing is the basis
>>>  for any datatyping interpretation. I.e., the knowledge in the
>>>  graph unambiguously identifies a single value by designating
>>>  a datatyped literal pairing. What that actual
>>>  value is, we don't know *at this level*. But at a higher level
>>>  where the full knowledge of xsd:integer is available, then
>>>  we know that the pairing <xsd:integer, "10"> identifies the
>>>  value ten.
>>>
>  >> The RDF Datatyping MT is not saying the value is ten. It is
>  >> saying that it is whatever value is identified by the interpretation
>>>  of the lexical form "10" within the context of the datatype
>  >> xsd:integer.

That is meaningless or false, Im not sure which. There is no notion 
of 'context' in RDF, and the interpretation in fact says that the 
value of the property is a string, not an integer.

>  >>
>>>  That may seem like a very slight distinction, but it is
>>>  a very significant one.
>>
>>  Slight, maybe.  Significant, definitely, in the sense that (as far as I can
>>  tell) it goes beyond that which is specified by the model theory.
>
>No, it does not go beyond the MT. It is exactly what the MT states.

The MT does not refer to contexts or pairings, and it does not say 
that the in-line idiom refers to datatype values.

>
>The present datatyping MT says for this particular example:
>
>--
>
>(3) ... if E contains the triples
>
>    <ex:age, rdfd:datatype, xsd:integer>
>    <Jenny, ex:age, "10">
>
>then L2V(I(xsd:integer))("10") is defined;
>i.e. "10" is in the lexical space of I(xsd:integer).

Right. Notice that is ALL it says in this case. It doesn't mention 
the datatype value.

>--
>
>Thus the literal "10" is a member of the lexical space
>of xsd:integer, and there is only one member of the value space of
>xsd:integer represented by "10", therefore according to the
>datatype xsd:integer, the value indicated by the above statements
>is ten.

Im not sure what 'the value indicated' means, but this certainly does 
NOT say that Jenny's age is ten. It says that the ex:age of Jenny is 
the string "10". It doesn't say anything about the datatype value.

>I.e. the datatype-specific interpretation of the above
>RDF knowledge is that Jenny's age is ten.

WRONG. It is the string "10", with or without datatyping.  All that 
the datatyping adds to this is check on the lexical form, which would 
rule out for example

Judy <ex:age> "boodle" .

as ill-typed.

To conclude that Jenny's ex:age is ten would be a mistake, an invalid 
inference. We should make this painfully clear to users, so they do 
not get their RDF in a muddle.

>Granted, the value
>ten has no denotation in the graph, but it is unambiguously
>identified by the idiom, in the context of the full semantics
>of xsd:integer.
>
>Now, some folks seem to assert that all the datatyping MT asserts
>is that "10" is a valid lexical form for xsd:integer,

Yes, exactly. That is all it asserts in this case, and it is very 
important that it does not assert more, or else the DCore-style 
applications will break.

>  but
>given the definition of datatypes, everything else follows
>automatically

?? What else follows automatically?

>so I don't see the real distinction.
>
>It is true that at the RDF MT level, it is not possible to
>know which value is indicated

No, the MT *specifies* which value is indicated. That is what the MT 
is for. And in this case, the value of the property is a string.

>-- but it is possible to
>know that a single specific value is indicated, and know
>that it is the value represented by the particular lexical
>form according to the semantics of a particular datatype.
>
>To state that a given literal is a member of the lexical
>space of a particular datatype is to associate that literal
>with the datatype

Yes, in a sense. Id rather say that the statement arises from a 
particular kind of association, as specified in the RDF graph syntax, 
since different 'associations' have different meanings.

>-- is to define a datatyped literal pairing.

No. Pairings aren't in the syntax and aren't mentioned in the MT.

>
>    L2V(I(xsd:integer))("10") is a datatyped literal pairing.

No, it isn't. In fact, it is a datatype value, viz the number ten 
(obtained by applying the lexical-to-value map L2V(I(xsd:integer)) to 
the argument "10"; the former itself being obtained by applying the 
global L2V mapping to the datatype I(xsd:integer) denoted by the 
uriref.)

>    Datatyped literal pairings thus have definition in the MT.
>
>let me repeat that in case some of you missed it ;-)

I didn't miss it, but its wrong. There are no pairings in the MT. In 
fact there are no expressions anywhere in the document I wrote that 
can possibly be interpreted as referring to such pairings.

Pat
-- 
---------------------------------------------------------------------
IHMC(850)434 8903   home
40 South Alcaniz St.(850)202 4416   office
Pensacola,  FL 32501(850)202 4440   fax
phayes@ai.uwf.edu 
http://www.coginst.uwf.edu/~phayes



