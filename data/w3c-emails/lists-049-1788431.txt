docno="lists-049-1788431"
received="Wed Apr 17 17:38:11 2002"
isoreceived="20020417213811"
sent="Wed, 17 Apr 2002 16:38:08 -0500"
isosent="20020417213808"
name="Pat Hayes"
email="phayes@ai.uwf.edu"
subject="Re: Denotation of datatype values"
id="p05101508b8e39a9012eb@[65.217.30.94]"
charset="us-ascii"
inreplyto="B8E1FC96.13361%patrick.stickler&#64;nokia.com"
expires="-1"


To: Patrick Stickler<patrick.stickler@nokia.com>
Cc:w3c-rdfcore-wg@w3.org

>On 2002-04-16 14:52, "ext Graham Klyne" <Graham.Klyne@MIMEsweeper.com>
>wrote:
>
>>  At 09:27 AM 4/16/02 +0300, Patrick Stickler wrote:
>>>>  I think that this way of phrasing it might be potentially misleading,
>>>>  since it suggests that the pairings are actually in the MT.
>>>
>>>  Perhaps they should be.
>>
>>  [GK wanders over to the stake in the ground, and gives it a hard kick, to
>>  make sure it's still firmly planted...]
>
>Was it? ;-)
>
>Was the kick to test if was firmly planted, or to ensure
>that it remains firmly planted?
>
>>>  But we have been asked, to a certain extent, to provide an answer
>>>  that extends to the point of obtaining a datatype value unambiguously
>>>  and reliably. The present MT does not bring users to that point.
>>>  A datatyped literal pairing does -- insofar as it identifies a single
>>>  value which is obtainable by an application which groks the datatype
>>>  in question.
>>
>>  Having an rdfd:range [[or substitute current vocab]] associated with a
>>  property tells you nothing about the denotation of an object of that
>>  property.  I.e. it does nothing to help "obtaining a datatype value
>>  unambiguously and reliably".  (I found that trying to make it do so leads
>>  to contradictions.)
>>
>>  All it does is limit the allowable literals at the property's sharp end.
>
>I either don't fully follow you, or disagree (or both ;-)
>
>If RDF Datatyping cannot provide a consistent and unambiguous
>interpretation resulting in a specific datatype value, then
>we're just wasting our time.

No no no. This is a misunderstanding. Some idioms provide only 
lexical form checking, other idioms provide unambiguous denotations 
of datatype values. Both are needed (by different user communities, 
maybe, but needed nevertheless.) Some people want both, some people 
want one without the other, some people want to be able to remain 
agnostic. The various idioms provide for all possibilities. Insisting 
that any rational person MUST be involved with finding datatype 
values, and the (for example) the Dublin Core style of using RDF is 
just wasting time, is both wrong and also confusing to the reader.

>If a given approach to reaching that goal results in contradictions,

Ignoring datatype values while being concerned with lexical forms is 
not being involved in a  contradiction. It might be bad style, or 
bone-headed, but some of our customers are like that.

Pat
-- 
---------------------------------------------------------------------
IHMC(850)434 8903   home
40 South Alcaniz St.(850)202 4416   office
Pensacola,  FL 32501(850)202 4440   fax
phayes@ai.uwf.edu 
http://www.coginst.uwf.edu/~phayes



