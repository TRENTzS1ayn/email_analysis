docno="lists-049-4350633"
received="Mon Apr 29 02:34:52 2002"
isoreceived="20020429063452"
sent="Mon, 29 Apr 2002 09:37:58 +0300"
isosent="20020429063758"
name="Patrick Stickler"
email="patrick.stickler@nokia.com"
subject="The place of rdfs:Literal's in the world..."
id="B8F2C4F6.1422C%patrick.stickler@nokia.com"
charset="US-ASCII"
inreplyto="B8F2BD2A.14226%patrick.stickler&#64;nokia.com"
expires="-1"

To: Patrick Stickler<patrick.stickler@nokia.com>, RDF Core<w3c-rdfcore-wg@w3.org>


On 2002-04-29 9:04, "ext Patrick Stickler" <patrick.stickler@nokia.com>
wrote:

>>> .....
>>> 
>>> # Rule 4 (this is new)
>>> 
>>> {
>>>    ?p rdfd:datatype ?d .
>>>    ?s ?p ?l .
>>>    ?l rdf:type rdfs:Literal
>>> }
>>> log:implies
>>> {
>>>    ?s ?p ?o.
>>>    ?o rdfd:lex ?l
>>> } .
>> 
>> I don't think rule 4 is valid. That is, Im not sure quite what
>> ?l rdf:type rdfs:Literal .
>> is intended to convey, but if its supposed to say that the object of
>> the previous triple is a literal, then the rule is not valid.

I would like to (finally) clarify a few things about rdfs:Literal that
have been confusing at least me (and perhaps others) for some time.

A few specific questions:

1. Is it true that rdfs:Literal rdfs:subClassOf rdfs:Resource ?

2. Even if a blank node or URIref denotes a (literal) string, can
   a blank or URIref node be rdf:type rdfs:Literal?

The latest Schema draft says:

rdfs:Literal     This represents the set of atomic values,
                 eg. textual strings.

and 

rdfs:Literal 

rdfs:Literal represents the self-denoting nodes called the 'literals' in the
RDF graph structure. Atomic values such as textual strings are examples of
RDF literals. 

Fair enough, but is a blank node that denotes a literal string
"atomic"? What does it mean for a node to be "atomic"? And if a literal
node is self-denoting, then I would expect that a blank node or URIref
node that denotes a literal is *not* itself of rdf:type rdfs:Literal,
since it is not a self-denoting node. Eh?

It also says later:

"values of rdfs:object can include both Literals and Resources."

If literals are resources, why the conjunction? Why not just say values
can be nodes or values can be resources? It seems to me that Literals
and Resources are disjunct classes. Are they?

My reading of both the original Schema spec and the latest drafts is
that it is *not* the case that rdfs:Literal rdfs:subClassOf rdfs:Resource.

I.e., blank nodes and URIref nodes are never of rdf:type rdfs:Literal
as that is a special class that reflects members of the graph syntax. E.g

URIRef/Blank Nodes       rdfs:Resource
Literal Nodes            rdfs:Literal
Property Arcs            rdf:Property

Eh? Is this wrong? If so, why?

So, it seems quite legitimate and correct, given the above definitions,
for the closure rule in question to use rdfs:Literal to refer *only*
to an actual literal (string) node and not to some blank or URIref
node that may just happen to denote the same string resource.

This suggests to me that my original closure rule is valid, and Pat's
counter example may not be (?)

*If* literals really are resources, then I'd like to see this explicitly
defined as rdfs:Literal rdfs:subClassOf rdfs:Resource in the spec, so
that this is clear.

*If* literals are not members of rdfs:Resource, then I re-assert that
the above closure rule is valid, and furthermore, that the earlier
proposed use of rdfs:range to constrain a property to only the inline
idiom via ?property rdfs:range rdfs:Literal is also valid, and the
earlier proposed use of rdfs:range to constrain a property to the
blank node idioms via ?property rdfs:range rdfs:Resource is also
valid.

I'd *really* appreciate some clarification on this issue. Thanks.

Cheers,

Patrick

 
--
               
Patrick Stickler              Phone: +358 50 483 9453
Senior Research Scientist     Fax:   +358 7180 35409
Nokia Research Center         Email: patrick.stickler@nokia.com



