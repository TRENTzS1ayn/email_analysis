docno="lists-049-5390619"
received="Fri Aug  2 02:57:50 2002"
isoreceived="20020802065750"
sent="02 Aug 2002 01:58:20 -0500"
isosent="20020802065820"
name="Dan Connolly"
email="connolly@w3.org"
subject="toward a minimal datatypes spec: hmm..."
id="1028271501.28235.204.camel@dirk"
expires="-1"

To:w3c-rdfcore-wg@w3.org



I just spent a while noodling on the smallest
datatype spec that I think would advance the
state of the art. I didn't find one that
fits neatly into our agenda at this point...

I spent some time reviewing the various experiments
I've done with the 2001/XMLSchema namespace:
(I'm not sure how many of these are world-readable...)

http://www.w3.org/2000/10/swap/infoset/xmlSchemaRanges.n3
http://www.w3.org/2000/10/swap/pim/travelTerms.n3
http://www.w3.org/2000/10/swap/pim/itinArcs.n3
http://www.w3.org/2000/10/swap/pim/itin2ical.n3
http://www.w3.org/2000/11/mr76/swad11Jun.n3
http://www.w3.org/2000/11/mr76/w3cStyle.n3
http://www.w3.org/2000/11/mr76/swad23Jul.n3
http://www.w3.org/2000/11/mr76/swg30Jul.n3
http://www.w3.org/2001/02pd/ccpp.n3
http://www.w3.org/2001/sw/WebOnt/wowg20020613.n3
http://www.w3.org/2001/sw/schedOne.n3
http://www.w3.org/2001/sw/schedOneF.n3
http://www.w3.org/2001/03swell/charmod.n3
http://www.w3.org/2001/03swell/http.n3
http://www.w3.org/2001/03swell/mime.n3
http://www.w3.org/2002/03owlt/over17.n3
http://www.w3.org/2002/03owlt/peopleKeyP.n3
http://www.w3.org/2002/03owlt/peopleKeyR.n3
http://www.w3.org/2002/06/15-rdff2f/req.n3
http://www.w3.org/2002/07dc-ca/req.n3
http://www.w3.org/2002/07dc-ca/itin1.n3
http://www.w3.org/2002/07dc-ca/itin1-arcs.n3
http://www.w3.org/2002/08dc-ymx/req.n3
http://www.w3.org/2002/08dc-ymx/evoMissing.n3
http://www.w3.org/2002/08dc-ymx/status2evo.n3
http://www.w3.org/2002/08dc-ymx/itin1.n3
http://www.w3.org/2002/08dc-ymx/itincal.n3

I make heavy use of the "local idiom"
and depend completely on tidy literals.

Then I spent a while boiling it down to
a specification of datatypes in N3...
  http://www.w3.org/2000/10/swap/util/datatypes.n3
I tried various levels of specification,
trying to find one that was _just_ expressive
enough to meet the requirements I see.

I think it's worthwhile to have some support
for the "global idiom". The design I came
up with is:

---
:rangeSyntax a r:Property;
  s:range :Datatype.

@prefix log: <http://www.w3.org/2000/10/swap/log#> .

this log:forAll :P, :L, :DT.

{ [] :P :L.
  :P :rangeSyntax :DT.
} log:implies { [] :DT :L }.

:rangeSyntax s:comment { # example...
  { ex:age :rangeSyntax dt:integer.
    ex:jenny ex:age "10" }
    log:implies { [] dt:integer "10" } }.
---

But to actually specify even just the
"local idiom" raises some issues...

I have come to the conclusion that the minimum
spec depends on two things:
  - UnambiguousProperty (aka InverseFunctionalProperty)
  - regular expressions

i.e. it ensures that from

_:x dt:date "2001-07-01".
_:x ex:weather ex:sunny.
_:y dt:date "2001-07-01".
_:y ex:winningTeam ex:tigers.

we can conclude

_:z ex:weather ex:sunny.
_:z ex:winningTeam ex:tigers.

This involves a notion of unambiguous property
and equality in the model theory
for datatypes... which would be silly to do without
giving them names, i.e. ont:UnambiguosProperty
and ont:equivalentTo.

So I'm starting to wonder if it makes more sense
to specify datatypes in terms of some of the WebOnt
features... or move some WebOnt features
into RDFS or something...

And re regular expressions, any sane datatypes
spec should ensure...

 dt:integer rdfs:range _:numerals.
 _:numerals :stringsThatMatch "([+-])?\\d+(\\.\\d*)?".
 _:x dt:integer "not a numeral".

is a contradiction.

Maybe we could expect RDF datatypes implementation
to do more than check strings against regular expressions
that we give them, but I'm not sure how much more
we'll get... I'm not sure if I see sufficient
motivation to check that "2002-02-29" isn't
a good lexical form for a date. Hmm... maybe I would
check that one, but I'm not sure about
all the constraints on duration syntax.
Or... hmm... maybe they have test materials that
we could import in bulk.

But we can't just wave our hands and say
"when DT is in the XML Schema namespace,
 VVV DT LLL means whatever their spec says it
means" because their spec includes some
datatypes that are ambiguous: QName
and union types; I just reported this
as a bug.

* QName is ambiguous; aren't datatypes unambiguous? union types total?
 Dan Connolly (Fri, Aug 02 2002) 
http://lists.w3.org/Archives/Public/www-xml-schema-comments/2002JulSep/0056.html
http://lists.w3.org/Archives/Public/www-rdf-comments/2002JulSep/0082.html


So... those are my collected thoughts on the matter.

-- 
Dan Connolly, W3C http://www.w3.org/People/Connolly/
see you in Montreal in August at Extreme Markup 2002?



