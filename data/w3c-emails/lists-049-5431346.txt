docno="lists-049-5431346"
received="Fri Aug  2 07:28:55 2002"
isoreceived="20020802112855"
sent="Fri, 02 Aug 2002 13:28:49 +0200"
isosent="20020802112849"
name="Sergey Melnik"
email="melnik@db.stanford.edu"
subject="Syntax-level typing (was Re: A data typing proposal)"
id="3D4A6CF1.1020501@db.stanford.edu"
charset="us-ascii"
inreplyto="3D472B8A.8070905&#64;guha.com"
expires="-1"


To:"R.V.Guha"<guha@guha.com>
CC: RDF Core<w3c-rdfcore-wg@w3.org>


R.V.Guha wrote:

> ...
> The simplest thing I can think of is to say that the literal always 
> denotes the string, unless there is an explicit xsd attribute which 
> specifies some other data type. Life just becomes so much simpler ...

Let me elaborate a bit on the above. If what comes below is not what 
Guha had in mind, I apologize; call it syntax-level typing, anyway.

The simplest things to do might be to make the primitive XSD datatypes 
part of RDF abstract syntax and tackle an extensible generic typing 
scheme later on (in WebOnt or RDF 2.0).

In essence, we could assume that typed values can be referred to 
directly in the graph, without using their lexical forms. So, we simply have

Jenny --age--> (int)5

where (int)5 is a literal, just like "5" is another one. URIs like 
xsd:integer denotes the class of integers (as defined in XSD), so that

age --rdfs:range--> xsd:integer

has the expected effect.

Typed literals as used above would be opaque to RDF; their 
interpretation be fixed. An extended serialization syntax needs to be 
used to distinguish (int)5 from "5". For RDF/XML we could simply use the 
XSD syntax, e.g.:

<age xsi:type="xsd:integer">5</age>

It would be the task of the parser to look at the xsi:type declaration 
and generate the correct triples. Other RDF syntaxes (e.g., NTriples) 
would have to design their own means of encoding typed values.

All idioms that we've been discussing go away. Later on, other ways of 
referring to typed literals (e.g., using our idioms or URI-schemes) can 
be developed along with an extensible type system for RDF, which would 
allow defining derived types etc.

The syntax-level typing sketched above does not require (but of course, 
can leave with) untidiness. In fact, typed literals like (int)5 can be 
mapped directly to say Java built-in types.

Sergey



