docno="lists-049-6095693"
received="Thu Aug  8 04:48:14 2002"
isoreceived="20020808084814"
sent="Thu, 8 Aug 2002 11:48:10 +0300"
isosent="20020808084810"
name="Patrick.Stickler@nokia.com"
email="Patrick.Stickler@nokia.com"
subject="RE: XML Schema is untidy (was RE: type test case)"
id="A03E60B17132A84F9B4BB5EEDE57957B5FBA7A@trebe006.NOE.Nokia.com"
charset="iso-8859-1"
inreplyto="XML Schema is untidy (was RE: type test case)"
expires="-1"


To:<jos.deroo.jd@belgium.agfa.com>
Cc:<Graham.Klyne@MIMEsweeper.com>,<jjc@hplb.hpl.hp.com>,<melnik@db.stanford.edu>,<w3c-rdfcore-wg@w3.org>



> -----Original Message-----
> From: ext Jos De_Roo [mailto:jos.deroo.jd@belgium.agfa.com]
> Sent: 08 August, 2002 11:26
> To: Stickler Patrick (NRC/Tampere)
> Cc: Graham.Klyne@MIMEsweeper.com; jjc@hplb.hpl.hp.com;
> melnik@db.stanford.edu; w3c-rdfcore-wg@w3.org
> Subject: Re: XML Schema is untidy (was RE: type test case)
> 
> 
> let's focus/stick to XML Schema primitive datatypes
> such as testcased by DanC in
> http://www.w3.org/2000/10/swap/test/dt/typedLit.n3

Well, I don't see how my comments *don't* apply to 
XML Schema primitive datatypes, which are all simple
datatypes.

The point was that I read the XML Schema spec as expecting
that the QName value of xsi:type to be an XML Schema
datatype (whether simple or complex) and for RDF to use
it for any arbitrary datatype, including those which
may not conform to the nature of datatypes defined by
XML Schema, is not to be taken lighly.

Secondly, I was pointing out that XML Schema has untidy
semantics with regards to lexical forms of datatype
values -- and provides both global and local mechanisms
for associating a datatype with that lexical form for
interpretation.

So if we are supposed to try to be compatable with 
XML Schema, I would consider that a strong argument
in favor of untidy syntax/semantics for RDF literals.

> I'm "more comfortable with it as each day goes by"
> (especially after I was able last night to parse it)

Well, just because you can parse it does not mean
it is the right way to do things. Eh?

Some comments on Dan's NTriples examples:

1. The triple

  :jenny :age 10.

suggests that numerical values are native to RDF (i.e. a
new node type) which must be understood by all
RDF parsers and applications. RDF has no native
datatypes, and I've understood it to be WG
consensus that RDF would be datatype and datatype
framework neutral.

2. The graph representation for a typed literal would
require a URI to denote the datatypes, not a QName
and certainly not a local name. We're not defining
any built-in datatypes for RDF, and need to allow
the datatyping mechanisms to work equally well with
all URI denoted datatypes which conform to the core
characteristics agreed upon (i.e. lexical space,
value space, N:1 mapping from lexical to value space,
etc.). Thus, if typed literal nodes are part of the
graph syntax, one should write, e.g. something like

   <http://www.w3.org/2001/XMLSchema#integer>"15"

or in N3 (rather than NTriples)

   xsd:integer"15"

rather than simply

   integer"15"

3. This whole issue about whether to create a
complex typed literal node in the RDF graph syntax
is completely disjunct with the last major datatyping
issue that has been under discussion by the WG, 
namely whether literals are tidy or untidy, and
is orders of magnitude less important than the
tidyness issue.

Patrick


> -- ,
> Jos De Roo, AGFA http://www.agfa.com/w3c/jdroo/
> 
> 
> 
> 
> Patrick.Stickler@nokia.com
> Sent by: w3c-rdfcore-wg-request@w3.org
> 2002-08-08 09:07 AM
> 
>  
>         To:     <melnik@db.stanford.edu>
>         cc:     <jos.deroo.jd@belgium.agfa.com>, 
> <Graham.Klyne@MIMEsweeper.com>, 
> <jjc@hplb.hpl.hp.com>, <w3c-rdfcore-wg@w3.org>
>         Subject:        XML Schema is untidy (was RE: type test case)
> 
> 
> 
> 
> > > So, even if the "range" of xsi:type is a QName, that QName is
> > > expected to denote an XML Schema type.
> > >
> > > No?
> >
> > This is not my reading. The first sentence of the paragraph
> > refers to a
> > usual case when the type is determined by the type associated
> > with the
> > XML element in the schema (i.e., no xsi:type is used). However, when
> > xsi:type is there, its value is a QName, nothing said about
> > it referring
> > to an XSD type definition or anything else.
> >
> > Correct me if I'm wrong...
> 
> I thought I did ;-)
> 
> The text in question from the XML Schema spec is
> 
>    "The Simple Type Definition (?2.2.1.2) or Complex Type Definition 
> (?2.2.1.3) used in ?validation? of an element is usually 
> determined by 
> reference to the appropriate schema components. An element 
> information 
> item in an instance may, however, explicitly assert its type 
> using the 
> attribute xsi:type. The value of this attribute is a ?QName?; 
> see QName 
> Interpretation (?3.15.3) for the means by which the ?QName? 
> is associated 
> with a type definition."
> 
> I.e., the type is *usually* specified in the schema, but can 
> be specified
> for each instance.
> 
> This is exactly the same relation as what should exist in RDF 
> for local
> versus global datatyping. I.e. one can assert a range for a 
> property in
> a schema to specify the type of the value denoted by the literal, or
> one can assert the type locally for each instance of a literal.
> 
> Thus, the following two are very similar:
> 
>    <xsd:element name="USPrice" type="xsd:decimal"/>
>    <USPrice>10.50</USPrice>
> vs
>    <USPrice xsi:type="xsd:decimal">10.50</USPrice>
> 
> or
> 
>    WidgetX USPrice "10.05" .
>    USPrice rdfs:range xsd:decimal .
> vs
>    WidgetX USPrice [ xsd:decimal "10.05" ] .
> 
> In both cases, the element/property value denotes an actual
> datatype value, but the datatype which is paired with the
> lexical representation is either globally asserted by
> schema, or locally asserted with the instance.
> 
> In other words, XML Schema employs *untidy* semantics for
> lexical representations!
> 
> Patrick
> 
> 
> 
> 
> 
> 



