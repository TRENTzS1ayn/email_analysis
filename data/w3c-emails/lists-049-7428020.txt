docno="lists-049-7428020"
received="Fri Aug 23 05:56:08 2002"
isoreceived="20020823095608"
sent="Fri, 23 Aug 2002 10:52:52 +0100"
isosent="20020823095252"
name="Brian McBride"
email="bwm@hplb.hpl.hp.com"
subject="RE: Alternative representation of typed literal nodes in   NTriples           (and N3)"
id="5.1.0.14.0.20020823104646.02187778@0-mail-1.hpl.hp.com"
charset="us-ascii"
inreplyto="A03E60B17132A84F9B4BB5EEDE57957B160BDB&#64;trebe006.europe.nok ia.com"
expires="-1"


To:Patrick.Stickler@nokia.com,<dave.beckett@bristol.ac.uk>
Cc:<w3c-rdfcore-wg@w3.org>


At 23:08 22/08/2002 +0300, Patrick.Stickler@nokia.com wrote:

[...]

>I seem to recall alot of test cases that appeared to rely on
>distinct naming of (untidy) literals, but perhaps that is
>simply because they were assuming tidy literals and had
>to resort to distinct names to force the untidy semantics.
>
>If that's the case, then great. Not having the local names
>is much cleaner for sure.

A case that arose recently involves a statement and its reification:

   _:a    foo:bar        _:l"lit" .
   _:stmt rdf:type       rdf:Statement .
   _:stmt rdf:subject   _:a .
   _:stmt rdf:predicate foo:bar .
   _:stmt rdf:object    _l:"lit" .


The name on the literal is needed to capture the information that the 
literal which is the object of the statement is the same one as is the 
object of the rdf:object statement, so that, e.g. if we add a range 
constraint to type the literal, the rdf:object statement also picks it up.

Brian



