docno="lists-049-8756452"
received="Tue Dec  3 23:14:40 2002"
isoreceived="20021204041440"
sent="Tue, 3 Dec 2002 22:14:52 -0600"
isosent="20021204041452"
name="pat hayes"
email="phayes@ai.uwf.edu"
subject="semantics doc updated for editorial freeze(?)"
id="p05111b26ba132037dec5@[10.0.100.247]"
charset="us-ascii"
expires="-1"


To:w3c-rdfcore-wg@w3.org


See http://www.coginst.uwf.edu/~phayes/RDF_Semantics_finalCall.html

It still needs some HTML fixing, internal anchors and  links adding, 
etc. but the content should now be pretty stable. If anyone can see 
any obviously missing pointers to other docs, please suggest where 
they can go. Figure 2 still needs re-drawing. I will be getting that 
stuff done in the next couple of days.

I have made several small fixes to prose here and there, fixed the 
buggy definition of instance, rewritten the containers description 
prose, added a brief word (section 3.2.4) about poor lonely 
rdf:value,  revamped the Datatyping rules section 4.3 to keep the 
different topics more clearly separated. (Dan, the only part that is 
listed as 'required' is your minimal datatype scheme that just checks 
for lexical wellformedness.) Ive taken out things that people found 
controversial, including the XSD 'warning', and tried to fix the 
things that people found confusing. Ive also brought the stuff in 
appendix A into line with the rest.

I have incorporated rdf:XMLLiteral into the RDF entailment section, 
which turned out to be easier than I thought it would be (it just 
needed a tweak to the definition of Herbrand interpretation. God, 
that Herbrand guy was smart. ) Note there is a new RDF closure rule 
now.

The micro-detailed way things work out in this version of the MT is as follows.

1. In RDF entailment, it is valid to canonicalize properly formed 
XMLLiteral-typed literals.
2. In RDFS entailment, you also know that rdf:XMLLiteral is a 
datatype and you can use it as a class name.
3. In datatype entailment (with any set of datatypes, even the empty 
set :-), ill-formed XML in an XMLLiteral counts as a datatype 
violation.

BTW, I now distinguish between a datatype *violation* (new term; if 
anyone has a preferred alternative, it's easy to change it), which is 
a graph where some typed literal contains a string which is not in 
the correct lexical space; and a datatype *clash* (same term as 
before), which is where a datatype value is in the wrong value space. 
The former are syntactic errors, the latter are kind of inconsistent. 
And I say that dtype-savvy reasoners MAY post an error when they find 
a violation (not SHOULD), which lets them do typechecking if they 
want to but doesn't require it, since they can choose to just carry 
on doing RDFS inference if they want to, and nothing will break.

Pat

PS. I havn't (yet) included an appendix based on Patrick's XSD 
ontology, but I could easily put it in if the WG thinks it is worth 
having in there, maybe marked 'informative' (?). It seems a shame to 
waste it :-)


-- 
---------------------------------------------------------------------
IHMC(850)434 8903   home
40 South Alcaniz St.(850)202 4416   office
Pensacola               (850)202 4440   fax
FL 32501            (850)291 0667    cell
phayes@ai.uwf.edu          http://www.coginst.uwf.edu/~phayes
s.pam@ai.uwf.edu   for spam



