docno="lists-050-0156902"
received="Tue Feb 26 09:39:36 2002"
isoreceived="20020226143936"
sent="Tue, 26 Feb 2002 06:35:57 -0800"
isosent="20020226143557"
name="Mike Dean"
email="mdean@bbn.com"
subject="Datatyping Ontology"
id="3C7B9D4D.7000602@bbn.com"
charset="us-ascii"
expires="-1"


To:w3c-rdfcore-wg@w3.org

Forwarded for Patrick Stickler.

Mike



# Datatyping Ontology:

rdfs:Datatype a rdfs:Class ;
   rdfs:subClassOf rdfs:Resource .

# An rdfs:Datatype is a datatype as defined by XML Schema which
# consist of a lexical space, a value space, and an N:1 mapping
# from the lexical space to the value space.

rdfs:datatype a rdfs:Property ;
   rdfs:domain rdfs:Property ;
   rdfs:range rdfs:Datatype .

# The rdfs:datatype property associates a datatype with that property
# which specifies the extra-RDF semantics (mappings) that should be used
# to obtain an actual value from a lexical form (literal). It defines an
# extra-RDF semantic constraint on the values of the property.  It does
# not assert any rdfs:range like constraints.

#--------------------------------------------------------------------
# Closure rules:

IF
   ppp rdfs:datatype ddd .
THEN
   ddd rdf:type rdfs:Datatype .


IF
   :x :p :l .
   :p rdfs:datatype :d .
   :l rdf:type rdfs:Literal .
THEN
   :x :p _:1 .
   _:1 :d :l .


IF
   _:1 ddd :l .
   :l rdf:type rdfs:Literal .
   ddd rdf:type rdfs:Datatype .
THEN
   _:1 rdf:type ddd .

#--------------------------------------------------------------------
# Examples of how to assert RDF range constraints and extra-RDF
# datatyping constraints:

# To interpret (outside of RDF) property values as representations (by
# various idioms) of members of the value space of ddd:

:age rdfs:datatype xsd:integer .

# To restrict property values to members of value space of ddd:

:age rdfs:range xsd:integer .

# To restrict property values to literals which are expected to
# correspond to members of lexical space of ddd:

:age rdfs:range rdfs:Literal .
:age rdfs:datatype xsd:integer .

(this is an alternative to rdfs:lrange)


#--------------------------------------------------------------------
# Extra-RDF interpretation:

The final resolution to values can be based on the datatype
triple as a sort of 'primitive' idiom, which provides the
pairing of datatype and lexical form to be passed to an
extra-RDF application for mapping to an actual value.

#--------------------------------------------------------------------
# Manually expanded implication examples:

IF
  :Bob :age _:2 .
  _:2 xsd:integer "35" .
THEN
  _:2 rdf:type xsd:integer .
  {no conflicts}

--

IF
  :Bob :age _:2 .
  _:2 xsd:integer "35" .
  :age rdfs:range xsd:integer .
THEN
  _:2 rdf:type xsd:integer .
  {no conflicts}

--

IF
  :Bob :age _:2 .
  _:2 xsd:integer "35" .
  :age rdfs:range rdfs:Literal .
  :age rdfs:datatype xsd:integer .
THEN
  _:2 rdf:type xsd:integer .
  {expected range conflict: _:2 is not rdf:type rdfs:Literal}

--

IF
  :Bob :age "35" .
  :age rdfs:datatype xsd:integer .
THEN
  xsd:integer rdf:type rdfs:Datatype .
  :Bob :age _:2 .
  _:2 xsd:integer "35" .
  _:2 rdf:type xsd:integer .
  {no conflicts}

--

IF
  :Bob :age "35" .
  :age rdfs:datatype xsd:integer .
  :age rdfs:range xsd:integer .
THEN
  xsd:integer rdf:type rdfs:Datatype .
  :Bob :age _:2 .
  _:2 xsd:integer "35" .
  _:2 rdf:type xsd:integer .
BUT
  {expected range conflict: literal node "35" is not rdf:type xsd:integer}

--

IF
  :Bob :age "35" .
  :age rdfs:datatype xsd:integer .
  :age rdfs:range rdfs:Literal .
THEN
  xsd:integer rdf:type rdfs:Datatype .
  :Bob :age _:2 .
  _:2 xsd:integer "35" .
  _:2 rdf:type xsd:integer .
BUT
  {oops! unexpected range conflict: _:2 is not rdf:type rdfs:Literal}

#--------------------------------------------------------------------

Conclusion: range constraints apply to the members of the class and
a datatype class contains both lexical forms and values as its
members and it is not consistent to try to restrict the range to
only one or the other.

If you want to constrain a property to only the lexical or value
space of a datatype class, give those spaces different names
(*.lex *.val) and make the range to be that specific space.

So, we only have one range constraint (rdfs:range) and a datatype
class (e.g. xsd:integer) is the union of the value and lexical
spaces, and if a range constraint for one or the other space is
needed, then it is necessary to either have different URIs to
denote the individual spaces, or use the shared bnode idiom, or
some other means -- and it may also be necessary to have different
properties that have the tighter constraint, such as dc:dateString
or ex:ageValue leaving the general properties dc:date or ex:age
as accepting either and the distinction left outside of RDF.

# EOF



