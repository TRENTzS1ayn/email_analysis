docno="lists-050-14436324"
received="Thu Mar 21 08:55:06 2002"
isoreceived="20020321135506"
sent="Thu, 21 Mar 2002 13:54:28 -0000"
isosent="20020321135428"
name="Jeremy Carroll"
email="jjc@HPLB.HPL.HP.COM"
subject="RE: Unasserted triples, Contexts and things that go bump in    the night."
id="JAEBJCLMIFLKLOJGMELDKEHDCDAA.jjc@hplb.hpl.hp.com"
charset="us-ascii"
inreplyto="5.1.0.14.0.20020321133511.03159650&#64;0-mail-1.hpl.hp.com"
expires="-1"

To:"Brian McBride"<bwm@HPLB.HPL.HP.COM>,"Dan Connolly"<connolly@w3.org>
Cc:"Pat Hayes"<phayes@ai.uwf.edu>,<w3c-rdfcore-wg@w3.org>





> At 22:28 20/03/2002 -0600, Dan Connolly wrote:
> [...]
> >Oh... but more substantively:
> >the hassle of dealing with an infinite number
> >of rdf:_1 rdf:_2 things.
Brian:
> Hmmm.  Its been proposed we make all those subproperties of some common
> super property, e.g. rdf:member.  Is there anything we are likely
>  to want
> to say about any rdf:_nnn that is not true of rdfs:member.  Would
> that deal
> with this, or am I missing the point?

The latter :( ...

The problem is that the daml:list construction with an explicit end is
viewed as safer vis-a-vis a closed world assumption that is being made.

e.g.

_:a rdf:type daml:oneOf [ <foo> ] .

entails

_:a daml:same???As <foo> .

whereas if the [ <foo> ] can have other members that we don't know about
then _:a might be one of them.

If you know Prolog this is the contrast between:

member(A,[foo]).

and

member(A,[foo|_]).

Jeremy



