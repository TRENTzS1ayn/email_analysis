docno="lists-050-3652191"
received="Fri Jan 25 09:08:50 2002"
isoreceived="20020125140850"
sent="Fri, 25 Jan 2002 15:08:03 +0100"
isosent="20020125140803"
name="Martyn Horner"
email="martyn.horner@profium.com"
subject="Re: use/mention and reification"
id="3C5166C3.AB78288C@profium.com"
charset="us-ascii"
inreplyto="B877192A.C50F%patrick.stickler&#64;nokia.com"
expires="-1"


To: Patrick Stickler<patrick.stickler@nokia.com>
CC: RDF Core<w3c-rdfcore-wg@w3.org>

Patrick Stickler wrote:
> 
> Let me give one example from my own work, which while still
> being in the design/build phase and is not yet deployed,
> is the result of alot of exploration about the optimal
> way to achieve the desired end result.
> 
> That end result is the qualification of assertions (or
> statements in general). The key types of qualifications
> that I have myself been looking at (while still attempting
> a solution that works for any arbitrary qualifications)
> are scope, source, and authority.
> 
> The two "idioms" for expressing such qualifications that
> are the most accessible, given the present state of RDF
> and RDF tools, are
> 
> 1. Reified statement, e.g.
> 
>    <rdf:Description rdf:about="#productA">
>       <name>Product A</name>
>    </rdf:Description>
> 
>    <rdf:Statement>
>       <rdf:subject rdf:resource="#productA"/>
>       <rdf:predicate rdf:resource="&rdf;label"/>
>       <rdf:object>Product A</rdf:object>
>       <scope rdf:resource="tdl:(&xsd:lang)en"/>
>    </rdf:Statement>
> 
>    <rdf:Description rdf:about="#productA">
>       <name>Tuote A</name>
>    </rdf:Description>
> 
>    <rdf:Statement>
>       <rdf:subject rdf:resource="#productA"/>
>       <rdf:predicate rdf:resource="&rdf;label"/>
>       <rdf:object>Tuote A</rdf:object>
>       <scope rdf:resource="tdl:(&xsd:lang)fi"/>
>    </rdf:Statement>
>

Patrick,

I keep hearing `xml:lang'...

Your two RDF statments (which could be qualified with an XML:lang
attribute) could be merged, in some sense, giving something like the
structure below with QValues. We have an application (in the field!)
which uses this type of indirection exactly for this purpose. It is
certainly a small extra effort for queries to handle it but it's
logical, covered by the schema and does not mess with the level of
quotation or assertion: it's just a pattern to match. If you like: it
honestly records that `the name of this product (in English) IS `Product
A'' and `the name of this product (in Finnish) IS `tuote A''. The schema
reflects that multiple qualified values are valid and cohabiting. Your
reification example, to my eyes, represents two disjoint statements (I
instintively read them as `quotations') implying that, in separate
scopes, two voices are expressing two assertions concerning the name of
this item. The merge is therefore a non-trivial act of generalization
and co-reference and no application (in our particular part of the
woods) would dequote or dereify from one to the other, without some
extra authority.

Is this answering Frank's question about dequoting and yours about
partitioning? 

(from:

`Well put, and this question has been in my head as well. The key
is (a) distinction between assertion, statement, and quotation
and (b) intepretation based on that distinction. We just need
to do both consistently.' )

Consistently (though without much application experience), I would put
reification in the domain of quotation (do I therefore agree with DanC?)
and interpret it that way.

Does this count as a practical use case? For me it's mainly a question
of practicality: I would not use the reification to model a dual-value
relationship without understanding that the duality was in some sense
`unresolved'. 


> 2. Qualified Object
> 
>    <rdf:Description rdf:about="#productA">
>       <name>
>          <QValue>
>             <rdf:value>Product A</rdf:value>
>             <scope rdf:resource="tdl:(&xsd:lang)en"/>
>          </QValue>
>       </name>
>       <name>
>          <QValue>
>             <rdf:value>Tuote A</rdf:value>
>             <scope rdf:resource="tdl:(&xsd:lang)fi"/>
>          </QValue>
>       </name>
>    </rdf:Description>
> 
> where QValue is a type that indicates a qualified value.
> 
> Now, the latter idiom is unnatractive because it
> introduces variation in the representation of
> assertions which means that query engines or
> query writes have to know about the variant graph
> forms for qualified and unqualified values.
> 
...

-- 
Martyn Horner <martyn.horner@profium.com>
Profium, Les Espaces de Sophia,
Immeuble Delta, B.P. 037, F-06901 Sophia-Antipolis, France
Tel. +33 (0)4.93.95.31.44 Fax. +33 (0)4.93.95.52.58
Mob. +33 (0)6.21.01.54.56 Internet: http://www.profium.com



