docno="lists-050-4317981"
received="Mon Jan 28 10:05:25 2002"
isoreceived="20020128150525"
sent="Mon, 28 Jan 2002 15:05:22 -0000"
isosent="20020128150522"
name="Jeremy Carroll"
email="jjc@hplb.hpl.hp.com"
subject="Monotonicity"
id="JAEBJCLMIFLKLOJGMELDAEOFCCAA.jjc@hplb.hpl.hp.com"
charset="iso-8859-1"
inreplyto="JAEBJCLMIFLKLOJGMELDMEODCCAA.jjc&#64;hplb.hpl.hp.com"
expires="-1"

To:"Jeremy Carroll"<jjc@hplb.hpl.hp.com>,<w3c-rdfcore-wg@w3.org>



>    2B:
>
>    Monotonicity and the open world assumption on type information.
>    S (idiom B and P) is non-monotonic with respect to type information,
>    or at least forces the RDF application to behave as if the
>    underlying theory were non-monotonic.
> [Sorry this is rather obscure, I will ask for a clarification about S-P,
> which will illustrate my concerns]


In S-P as I understand it rdf:value is understood in relation to the known
datatypes:

[[[[


In other words, rdf:value "extracts" the lexical representation from a given
pair:

EXT(I(rdf:value)) := {<<x,y>, y> | <x,y> is an element of a datatype
mapping}

(Notice that for the above definition to be well-formed, we need to be able
to enumerate all datatype mappings. This can be done using special
vocabulary e.g., xsd:date.map rdfs:subClassOf rdfdt:DatatypeMapping).


]]]]

So for example, in a  minimal RDF implementation in which we only have
strings rdf:value is a 1-1 mapping. Thus in that sort of implementation we
would have:


_:a <foo> _:b .
_:b <rdf:value> "string" .
_:c <bar> _:d .
_:d <rdf:value> "string" .

implies

_:a <foo> _:b .
_:c <bar> _:b .


(in the premise both _:b and _:d are < "string", "string" > )

If a second RDF implementation has a greater range of datatypes then it may
be the case that "string" can map to something else. In this case the
implication above does not hold.

e.g. if we support xsd:string and xsd:integer then we have the following:

_:a <foo> _:b .
_:b <rdf:value> "1000" .
_:c <bar> _:d .
_:d <rdf:value> "1000" .

does not imply

_:a <foo> _:b .
_:c <bar> _:b .


I believe the semantic web will be built on the systematic application of
the open world assumption.

S-P requires a closed world assumption on datatypes, that results in
defeasible implication, and hence non-interoperability. This is a
significant concern.

Similarly S-B seems to require applications to make similar defeasible
typing above the RDF layer. Without any type information a string should be
treated as a string. In the light of a single range constraint the
application should treat the string in accordance with that datatype. If
multiple range constraints apply to the same lexical node then it is unclear
what an application should do.

So S-B also suffers non-monoticity but in the application layer.

Jeremy



