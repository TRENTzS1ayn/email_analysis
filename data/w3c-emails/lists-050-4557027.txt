docno="lists-050-4557027"
received="Tue Jan 29 07:24:27 2002"
isoreceived="20020129122427"
sent="Tue, 29 Jan 2002 12:24:52 -0000"
isosent="20020129122452"
name="Jeremy Carroll"
email="jjc@hplb.hpl.hp.com"
subject="RE: Datatyping Summary"
id="JAEBJCLMIFLKLOJGMELDAEOICCAA.jjc@hplb.hpl.hp.com"
charset="us-ascii"
inreplyto="5.1.0.14.2.20020129094952.0386b550&#64;joy.songbird.com"
expires="-1"

To:"Graham Klyne"<Graham.Klyne@MIMEsweeper.com>,"Brian McBride"<bwm@hplb.hpl.hp.com>
Cc:"RDF Core"<w3c-rdfcore-wg@w3.org>



This message addresses the main criticisms of TDL.
I will follow up with more detail concerning query, Brian's B3 & B4.

The proponents of S furnish us with an implementation of S, and a model
theory for S (which includes, naturally self-entailment).

I now can create an implementation of TDL in the following fashion.

As I read in any RDF graph I apply the following syntactic transformation.

Match:
  ?x  ?y ?z
  where ?y != rdf:value and
        ?z a literal node

  replace with
  ?x ?y NewNode
  NewNode rdf:value ?z

  where NewNode is a newly minted bNode.

For example:

<a> <foo> "ss" .

is transformed to

<a> <foo> _:b.
_:b <rdf:value> "ss".


We then use the S implementation and S model theory (idiom S-P is the only
idiom used).

Hence:
  If S is implementable then so is TDL
  The maximum overhead required for TDL is the same as that for S idiom A
and/or S idiom P.

All problems to do with entailment, query, implication, etc. are clarified
and addressed with this process (as long as they are clear and addressed
with S).

From an implementators point of view, it is clearly easier to implement the
syntactic transformation and S-P, than to implement S-A, S-B and S-P.

Graham, does this adequately address your concern about self-entailment?

[Small technical detail:

S-P uses a closed world assumption on data types, whereas TDL uses an open
world assumption. The two can be made equivalent by using S-P with at least
two incompatible types in its closed world  both having domain being the
complete set of unicode strings. Two such types are:

xsd:string = { < x, x > | for any unicode string x }
appendA    = { < x, x."A" > | for any unicode string, . being string
concatenation }

]

Jeremy



