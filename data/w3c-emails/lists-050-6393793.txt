docno="lists-050-6393793"
received="Mon Jul  8 19:41:54 2002"
isoreceived="20020708234154"
sent="Mon, 8 Jul 2002 16:42:04 -0700"
isosent="20020708234204"
name="pat hayes"
email="phayes@ai.uwf.edu"
subject="Re: literals, again."
id="p05111b23b94fd2472e6e@[192.168.0.146]"
charset="us-ascii"
inreplyto="B942680B.1799B%patrick.stickler&#64;nokia.com"
expires="-1"


To: Patrick Stickler<patrick.stickler@nokia.com>
Cc:w3c-rdfcore-wg@w3.org


>On 2002-06-28 18:56, "ext pat hayes" <phayes@ai.uwf.edu> wrote:
>
>>
>>>  Pat,
>>>
>>>  I support the "gist" of essentially all that you are saying
>>>  below, but would offer an even more simplified proposal.
>>>
>>>  Rather than
>>>
>>>>   Jenny ex:age _:y "10" .
>>>>   _:y "10" xsd:number _:x .
>>>>   Jim ex:age _:x .
>>>
>>>  simply
>>>
>>>  Jenny ex:age _:y"10" .
>>>  _:y rdf:type xsd:integer .
>>>  Jim ex:age _:y .
>>
>>  OK, but bear in mind that the subject of the second triple is the
>>  very same node as the object of the first triple, and so it still has
>>  the "10" literal label, even though you didn't mention it. So this is
>>  exactly the same graph as:
>>
>>  Jenny ex:age _:y "10" .
>>  _:y "10" rdf:type xsd:integer .
>>  Jim ex:age _:y "10".
>
>Right.
>
>>  Now, that would be nice, but...
>
>I agree.
>
>>>  so that datatyping is no different than "normal" RDF
>>>  typing, and the above works perfectly in conjuction
>>>  with rdfs:range. E.g.
>>
>>  ....seems to me that it doesn't work, and that we have been here
>>  before. In fact this is very much like the old P++ proposal that you
>>  shot down, on the excellent grounds that mere membership in the value
>>  space cannot be the trigger of a datatype check since two datatypes
>>  with different lexical2value mappings can have exactly the same value
>>  space. Which is why we decided to make the actual range itself be the
>>  trigger, rather than an rdf:type conclusion from the range. (Have you
>>  changed your mind on that point??)
>
>We discussed this in Bristol.

I didn't follow what you were saying there, and I still don't:

>The rdfs:range constraint is indeed
>only on the value space of the datatype class, and thus, the
>literal node denotes a datatype value, but because we also
>know that it is of type rdfs:Datatype

That WHAT is of that type? The value space is a class extension, and 
several different classes can have the same extension.

>, there is the additional
>constraint that the value denoted by the literal node is the
>specific value to which the lexical form embodied in the label
>maps, according to the lexical to value mapping of that datatype.

But there is in general no way to connect the literal to the 
particular datatype 'through' the value, that is the (your) point. So 
just knowing that something has the rdf:type of a certain datatype 
class is no longer sufficient to tell us how to interpret a literal 
connected to that thing.

>The rdfs:range semantics tells us the literal node denotes the value.
>The rdfs:Datatype semantics tells us the label is the lexical
>representation of the value.
>
>The fact that the class extension of the datatype is only its value
>space is only a problem for query engines or similar applications
>which might separate a lexical form from its original datatype
>context,

Any engine might do that, since there is no such thing in as this 
'context' in an RDF graph, right?

>based on the original triple in which it occurs (by e.g.
>applying subPropertyOf relations, etc.)
>
>As long as implementers are aware that subPropertyOf and subClassOf
>relations are valid for datatype values but not mappings, and
>that the original context must be preserved, then we're fine.

But what does it even *mean* to preserve this 'context' ? And if 
datatype mappings are properties, then why is subPropertyOf not valid 
on them?

Pat

-- 
---------------------------------------------------------------------
IHMC(850)434 8903   home
40 South Alcaniz St.(850)202 4416   office
Pensacola,  FL 32501(850)202 4440   fax
phayes@ai.uwf.edu 
http://www.coginst.uwf.edu/~phayes



