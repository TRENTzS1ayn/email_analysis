docno="lists-050-6446165"
received="Tue Jul  9 10:47:04 2002"
isoreceived="20020709144704"
sent="Tue, 09 Jul 2002 15:46:15 +0100"
isosent="20020709144615"
name="Brian McBride"
email="bwm@hplb.hpl.hp.com"
subject="Re: test case: Test case A and reification"
id="5.1.0.14.0.20020709153521.00ab1618@15.144.25.13"
charset="us-ascii"
inreplyto="p05111b25b94fd6401cd7&#64;[192.168.0.146]"
expires="-1"


To: pat hayes<phayes@ai.uwf.edu>
Cc:w3c-rdfcore-wg@w3.org


At 17:09 08/07/2002 -0700, pat hayes wrote:
[...]


>>Now consider:
>>
>>   <jenny> foo:age "10" .                   (3)
>>   <film>  dc:title "10" .                  (4)
>>   foo:age  rdfs:range xsdr:decimal .
>>   dc:title rdfs:range xsdr:string .
>>
>>and two reifications:
>>
>>   _:a rdf:subject <jenny> .
>>   _:a rdf:predicate foo:age .
>>   _:a rdf:object "10" .                    (5)
>>   _:a rdf:type rdf:Statement .
>>
>>   _:b rdf:subject <film> .
>>   _:b rdf:predicate dc:title .
>>   _:b rdf:object "10" .                    (6)
>>   _:b rdf:type rdf:Statement .
>>
>>
>>Then the objects of statements (5) and (6) cannot denote the same thing 
>>as the objects of statements (3) and (4) respectively.
>
>Er.... why not?

I'm thinking in terms of the proposal made at the f2f where literals are 
"untidy".

[...]


>>If the answer to test case A is yes, then we need an non-entailment test:
>>
>>   <s> <p> "a" .
>>   _:s rdf:subject <s> .
>>   _:s rdf:predicate <p> .
>>   _:s rdf:object "a" .
>>   _s: rdf:type rdf:Statement .
>>
>>where _:s is a reification of the first statement
>>
>>does not entail:
>>
>>   <s> <p> _:o .
>>   _:s rdf:object _:o .
>
>Again, I think this is valid in the current 'stake' proposal (for literals 
>and urirefs). And if literals were semantically untidy, then any 
>entailment from distinct literal nodes to common bnodes would be invalid. 
>In other words, I don't think reification introduces any new issues. The 
>issue is: If we allow untidy literal nodes, when can we assume that two 
>literals denote the same thing? Answer: when they are the same *node*. 
>It's the nodes that do the denoting, not the labels.

Ah, there was more to this syntactic/semantic tidyness than i 
appreciated.  So you are saying my example should have been:

   <jenny> foo:age _:l1"10" .                   (3)
   <film>  dc:title _:l2"10" .                  (4)
   foo:age  rdfs:range xsdr:decimal .
   dc:title rdfs:range xsdr:string .

and two reifications:

   _:a rdf:subject <jenny> .
   _:a rdf:predicate foo:age .
   _:a rdf:object _:l1"10" .                    (5)
   _:a rdf:type rdf:Statement .

   _:b rdf:subject <film> .
   _:b rdf:predicate dc:title .
   _:b rdf:object _:l2"10" .                    (6)
   _:b rdf:type rdf:Statement .

and all is well.  Except:

   <rdf:Description rdf:about="jenny">
     <age>10</age>
   </rdf:Description>
   <rdf:Description rdf:about="johnny">
     <age>10</age>
   </rdf:Description>

is then equivalent to n-triples:

   <jenny>  <age> _l1:"10" .
   <johnny> <age> _l2:"10" .

To be clear, we should rewrite test case A as the rdf/xml above because 
that is what folks will be writing.  Rewritten in that way, it fails to 
give the desired outcome, that an rdf processor can conclude that jenny and 
johnny have the same age.

Brian



