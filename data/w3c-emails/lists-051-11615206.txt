docno="lists-051-11615206"
received="Thu Sep  5 03:29:24 2002"
isoreceived="20020905072924"
sent="Thu, 5 Sep 2002 10:29:21 +0300"
isosent="20020905072921"
name="Patrick Stickler"
email="patrick.stickler@nokia.com"
subject="Re: Proposals for changes to current datatyping spec"
id="005701c254ad$f44f2c60$294516ac@NOE.Nokia.com"
charset="iso-8859-1"
inreplyto="A03E60B17132A84F9B4BB5EEDE57957B0110204A&#64;trebe006.europe.nokia.com"
expires="-1"


To:"ext Jan Grant"<Jan.Grant@bristol.ac.uk>
Cc:"w3c-rdfcore-wg"<w3c-rdfcore-wg@w3.org>




> > 5. Clarify the relation of rdfs:Literal, rdfs:Datatype, and
> >    typed literal (begs the question of whether rdfs:TypedLiteral
> >    is warranted, as a subclass of rdfs:Literal...)
> 
> This does need clarification, yes. But hang on... you suggest that
> 
>     <eg:foo> <eg:age> (xsd:integer)"10".
> 
> might (with literals "at the blunt end") imply...
> 
>      (xsd:integer)"10" <rdf:type> <xsd:integer> .
> 
> But if "TypedLiteral" is the class of typed literals, then whenever
> 
>      <xsd:someType> <rdf:type> <rdf:Datatype> .
> 
> then we have that members of <xsd:sometype> are members of
> rdfs:TypedLiteral, and hence members of rdfs:Literal. Which would kind
> of imply (since subclassing is a relation of class extensions) that
> 
>      <xsd:integer> <rdf:type> <rdf:Datatype> .
> 
> implies
> 
>      <xsd:integer> <rdfs:subClassOf> <rdf:Literal> .

No. This is not correct. I'll try to clarify.

A member of rdfs:TypedLiteral will contain, as one of its components,
a member of rdfs:Literal. The other component of a rdfs:TypedLiteral
is a member of rdfs:Datatype.

rdfs:TypedLiteral is *not* rdfs:subClassOf rdfs:Literal. 
rdfs:TypedLiteral is *not* rdfs:subClassOf rdfs:Datatype.

We have three classes, rdfs:Datatype, rdfs:Literal, and rdfs:TypedLiteral,
which are participating in RDF datatyping.

Members of the first two classes are paired components of members of
the latter class.

Members of rdfs:Datatype are datatypes conforming to the core
characteristics defined for all RDF datatypes.

Members of rdfs:Literal are literals, sans any typing (3-tuples of string/xmlbit/lang, 
or union of string/langstring/xmlstring/xmllangstring, whatever the WG
decides).

Members of rdfs:TypedLiteral are pairings of a member of rdfs:Datatype
and a member of rdfs:Literal, and a member of rdfs:TypedLiteral
denotes a specific, unambiguous datatype value -- i.e. a member of the value 
space of the datatype.

Members of the value space of a datatype are *not* members of
rdfs:Literal, nor are they members of rdfs:Datatype (the latter I hope
is obvious). They are datatype values, and the only mechanism for
denoting specific datatype values in RDF (as proposed) is a typed
literal node.

The class extension of a member of rdfs:Datatype is the value space
of the datatype, not the lexical space, not a set of typed literals, etc.

The rdfs:range property asserts that a property value is a member
of a given RDF class, and if that class is an rdfs:Datatype, then that
property value is asserted to be a member of the value space of
that datatype. Typed literal nodes, members of rdfs:TypedLiteral,
denote members of value spaces of datatypes, and therefore are
compatable property values -- presuming that the datatype value
denoted by the typed literal node is in fact a member of the value
space of the datatype specified in the range assertion.

Is that any clearer?

> ... which is why I suggested Datatype is a superfluous extension
> (particularly since it seems that all literals should carry a type, but
> I don't wish to descend into "dogmatic assertions" here :-) )

I agree fully that all literals should carry a type, explicit or implicit,
and this is the untidy view. Or rather, to avoid an untidy treatment,
we'd the need to disallow inlined literals entirely, making all literals
typed literal nodes.

Patrick



