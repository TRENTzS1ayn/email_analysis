docno="lists-051-12869946"
received="Tue Sep 17 09:43:26 2002"
isoreceived="20020917134326"
sent="Tue, 17 Sep 2002 15:41:22 +0200"
isosent="20020917134122"
name="Jeremy Carroll"
email="jjc@hplb.hpl.hp.com"
subject="RE: decision time: semantics of non-datatyped literals"
id="BHEGLCKMOHGLGNOKPGHDKEDDCAAA.jjc@hpl.hp.com"
charset="us-ascii"
inreplyto="5.1.0.14.0.20020916115141.0233fbf0&#64;0-mail-1.hpl.hp.com"
expires="-1"

To:"Brian McBride"<bwm@hplb.hpl.hp.com>,"RDF Core"<w3c-rdfcore-wg@w3.org>



>
> I note that all of the implementations of RDF with which I am
> familiar have
> implemented M&S with the assumption that literals have string semantics,
> i.e. literal("foo").equals(literal("foo")).
>
I read M&S as merely articulating syntactic facts, and hence reflecting a
syntactically tidy graph; this does not preclude semantic untidiness.

I prefer the option of "not deciding".
I could live with any of the options.

Syntactically tidy, (possibly) value based semantics, and valentines day MT.
For details see below.
(Or,
http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Sep/0086.html
)

PROS:
  - does not require changes to preexisting implementations: equals is taken
as syntactic
  - does not preclude the "10" in <Jenny> <age> "10" from meaning the
integer ten.
  - could support rdfs:range="xsd:int" construction
  - could support tidiness
  - does not fly in the face of the community feedback.

CONS:
  - somewhat contorted (the divergence between syntax and semantics may
confuse)
  - stresses further the separation of the abstract graph syntax (the Model
in M&S) and the interpretation (the Model in the MT) [we already have this
with our decision on datatypes of last Friday, see below for example]



Specifically:
- the graph is syntactically tidy
- the interpretation of a typed literal is given by its datatype
- the interpretation of a triple with an untyped literal has an extra level
of indirection (semantically untidy, the interpretation of the literal in
the triple depends on the property, and maybe the subject too)
- otherwise, and in general terms, the model thoery follows the valentines
day approach, which does not permit bnodes to match literals in entailments,
and hence the decisive questions cannot be asked.


As an implementator I would expect to implement two equivalence
relationships over graph nodes. equals() would reflect syntactic equality,
and sameValueAs() would reflect semantic equality:

e.g.

       not equals( literal("<xsd:int>010"), literal("<xsd:decimal>10.0") )

but
       sameValueAs( literal("<xsd:int>010"), literal("<xsd:decimal>10.0") )

and
       n = literal("untyped")
       equals( n, n )
but
       not sameValueAs( n, n )

(I might prefer not to have sameValueAs defined over literal nodes, but only
over triples).


This does not require implementations to change; clarifies how to implement
RDFS; is somewhat contorted; and is a bit of a fudge.

A modification to this, would be to explicitly support [p rdfs:range
<datatype>] in it, in which case it is untidy. My weak preference is to not
require that there are any literals which do not have tidy semantics. (i.e.
exactly the valentines day mt position; the machinery of untidiness is
presented, but no commitment to actually use it!)

Jeremy


PS: At the Bristol F2F Guha talked about the mapping of the literal node
depending on either:
 - only the literal
 - the literal and the property
 - the literal, the property and the subject

I can't remember whether any crucial showstoppers were identified to any of
these. I remember that rdf:object was a little disappointing with the middle
one. (And I think only the last made me feel alright about dc:Creator, but
then I'm out on limb with dc).



