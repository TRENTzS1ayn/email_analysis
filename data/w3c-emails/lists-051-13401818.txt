docno="lists-051-13401818"
received="Mon Sep 23 05:37:02 2002"
isoreceived="20020923093702"
sent="Mon, 23 Sep 2002 12:36:58 +0300"
isosent="20020923093658"
name="Patrick Stickler"
email="patrick.stickler@nokia.com"
subject="Re: DECIDED: untidy semantics"
id="005301c262e4$c2d6d580$d74416ac@NOE.Nokia.com"
charset="iso-8859-1"
inreplyto="OFEA395599.F4C5BB6F-ONC1256C3B.003C6959-C1256C3B.003E1289&#64;agfa.be"
expires="-1"


To:"w3c-rdfcore-wg"<w3c-rdfcore-wg@w3.org>,"ext Jos De_Roo"<jos.deroo.jd@belgium.agfa.com>




[Patrick Stickler, Nokia/Finland, (+358 50) 483 9453, patrick.stickler@nokia.com]


----- Original Message ----- 
From: "ext Jos De_Roo" <jos.deroo.jd@belgium.agfa.com>
To: "w3c-rdfcore-wg" <w3c-rdfcore-wg@w3.org>
Sent: 21 September, 2002 14:17
Subject: DECIDED: untidy semantics


> 
> ...
> I can't help but I can't think how to
> avoid (in my implementation) the entailment
> 
> ==== untidyP
> @prefix : <untidy#> .
> :Sergey :votes "untidy" .
> :Graham :votes "untidy" .
> ====
> 
> ==== untidyC
> @prefix : <untidy#> .
> :Sergey :votes _:x .
> :Graham :votes _:x .
> ====
> 
> (and for the moment I even have no time
> to think about it)
> 
> -- ,
> Jos De Roo, AGFA http://www.agfa.com/w3c/jdroo/
> 
> PS untidy typed literals _:x"abc" are OK for me
>    but "xyz" is always "xyz" (bare literal, *non*typed)

Right. I think this illustrates why the tidy syntax/untidy semantics
approach is not optimal. At present, nodes in a graph are tidy
according to label, and intersection of nodes is treated as
equality of denotation. I.e., same node, same meaning. Fair enough.

Thus, by simply ensuring that each occurrence of an inline literal
node gets a unique label, to protect the untidy semantics, we also
get untidy syntax (since only one occurrence will every have the
same label) and applications which presume "same node, same meaning"
can go along their merry way without any problems -- though of course,
some earlier entailments may no longer hold, given the untidy literal
nodes -- but that's the point, that those entailments *wouldn't* hold.

So, rather than the above, we'd have

==== untidyP
@prefix : <untidy#> .
:Sergey :votes _:a"untidy" .
:Graham :votes _:b"untidy" .
====

which does not entail

==== untidyC
@prefix : <untidy#> .
:Sergey :votes _:x .
:Graham :votes _:x .

though, given the additional knowledge

:votes rdfs:range xsd:string .

a datatype aware RDF application could infer that Sergey's
and Graham's votes were the same, as it would be able to
determine that in both cases, the same value is denoted.

In fact, no special knowledge about xsd:string is necessary
to determine the equality of _:a"untidy" and _:b"untidy" in
the presence of the rdfs:range assertion, since the MT would
itself be able to determine that 

   I(_:a"untidy") = I(xsd:string"untidy")
   I(_:b"untidy") = I(xsd:string"untidy")

and thus

   I(_:a"untidy") = I(_:b"untidy")

irrespective of the actual L2V mapping, since for a given datatype
interpretation, the same exact lexical form always maps to the same
value.

Patrick



