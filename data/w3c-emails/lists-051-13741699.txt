docno="lists-051-13741699"
received="Tue Sep 24 11:40:25 2002"
isoreceived="20020924154025"
sent="Tue, 24 Sep 2002 17:40:15 +0200"
isosent="20020924154015"
name="Jeremy Carroll"
email="jjc@hplb.hpl.hp.com"
subject="RE: DECIDED: untidy semantics"
id="BHEGLCKMOHGLGNOKPGHDEEELCAAA.jjc@hpl.hp.com"
charset="us-ascii"
inreplyto="OF0FF4249C.D783778E-ONC1256C3E.00517680-C1256C3E.00521295&#64;agfa.be"
expires="-1"

To:"Jos De_Roo"<jos.deroo.jd@belgium.agfa.com>,"Patrick Stickler"<patrick.stickler@nokia.com>
Cc:"Brian McBride"<bwm@hplb.hpl.hp.com>,"w3c-rdfcore-wg"<w3c-rdfcore-wg@w3.org>




> > Yes, but a URIref is an identifier with unambiguous
> > and globally consistent meaning. A bare literal,
> > without any explicit or implicit datatype denotation
> > is ambiguous,
>
> no it isn't, it's unambiguously meaning
> the *token* itself, always and everywhere
> there just is no other interpretion involved
>

Whilst I don't begrudge you three or four rounds in the ring with Patrick
(that I haven't been following), I find this somewhat exaggerated.

If we consider the classic example of <Jenny> <age> "10" . I take it, that
at some point, some piece of software might decide to read the "10" as a
number, and decide that Jenny is older than Bob, ( <Bob> <age> "3" . ) So as
far as I can see, somewhere there is some other interpretation. If there
really isn't any other possible interpretation we should perhaps deprecate
bare-literals all together. We could retain parseType="Literal" for carrying
fragments of XML documents which are to be interpreted as self denoting, but
most of the other usage of literals in RDF seems to have some implicit
referent other than the string.

Thus the choice seems to boil down to *where* is this mapping from "10"
(string) to 10 value made, and how is it licensed.

My understanding of the tidy position is that this mapping is made by the
application at its own initiative, and it is unlicensed, or licensed only by
private channel.
The untidy position is that the mapping can be made in response to a range
constraint.

Unfortunately the (only?) intuitive implementation of this depends on a
non-monotonic step: the thing that we used to regard as a string, we now
regard as a number. The monotonic way of looking at this, (the thing is
*untyped*, and hence distinct from an identical untyped thing) is not really
going to convince any but a handful of people (most of whom belong to this
WG).

Thus the untidy position ends up with RDF software that takes a
non-monotonic step; the tidy position ends up with RDF applications that
take (essentially the same) non-monotonic step.

Really using syntactic means to allocate datatype, and requiring all
Literals to be typed, would be preferable - but then that's a "I wouldn't
start from here" argument.

Jeremy



