docno="lists-051-14880381"
received="Fri Sep 27 23:10:08 2002"
isoreceived="20020928031008"
sent="Fri, 27 Sep 2002 22:10:25 -0500"
isosent="20020928031025"
name="pat hayes"
email="phayes@ai.uwf.edu"
subject="Re: possible semantic bugs concerning domain and range"
id="p05111b18b9bacb1d0acb@[65.217.30.172]"
charset="us-ascii"
inreplyto="20020925.131807.79226591.pfps&#64;research.bell-labs.com"
expires="-1"


To:"Peter F. Patel-Schneider"<pfps@research.bell-labs.com>
Cc:www-webont-wg@w3.org


I am cross-posting this to the RDF core WG for its interest.

>From: pat hayes <phayes@ai.uwf.edu>
>Subject: Re: possible semantic bugs concerning domain and range
>Date: Wed, 25 Sep 2002 12:13:40 -0500
>
>[...]
>
>>  >>  These can all be expressed using my notion of range and
>>  >>  rdfs:subClassOf or rdf:type. The important inferences about ranges -
>>  >>  notably, the kind that arise from an association of a datatype with a
>>  >>  range - apply in both semantics, but require more care to state in
>>  >>  yours.
>>  >
>>  >Do these inferences actually work?  I thought that RDF Core had decided
>>  >that they didn't work in the presence of super-properties.
>>
>>  No, the problem was the possibility of an XML datatype value space
>>  being included in another when the datatype mappings were
>>  incompatible, and we basically decided to punt on that one. I don't
>>  think superproperties pose any problem, but maybe I missed something:
>>  what do you see as the problem there?
>
>Suppose that you have the following:
>
>    foo rdfs:subPropertyOf bar .
>    foo rdfs:range xsd:[integer union string] .
>    bar rdfs:range xsd:[string union integer] .
>
>    john foo 10 .
>
>how is 10 to be interpreted?

integer. YOu can in this case also INFER that john bar 10, and now 
you can infer that the literal in that second triple means a string. 
So now, John's foo is ten and his bar is "10".

However, if you have some way to keep track of things a bit more 
finely you might also be able to infer from the first triple plus the 
datatype that:

john foo _:x .
(and  _:x is ten)

never mind for now how you know that second fact, suppose you do 
somehow - and then you can use subproperty reasoning to conclude that

john bar _:x
(and _;x is ten)

from which you know that john's bar is also ten. So John has to have 
two bars: ten and "10", if you can somehow manage to construct this 
chain of reasoning. But he still only has to have one foo.

All this is admittedly weird, but then so was your example. And it is 
quite internally coherent.

Pat
-- 
---------------------------------------------------------------------
IHMC(850)434 8903   home
40 South Alcaniz St.(850)202 4416   office
Pensacola              (850)202 4440   fax
FL 32501           (850)291 0667    cell
phayes@ai.uwf.edu          http://www.coginst.uwf.edu/~phayes



