docno="lists-051-6085213"
received="Sat Oct 12 16:29:31 2002"
isoreceived="20021012202931"
sent="Sat, 12 Oct 2002 22:28:56 +0200"
isosent="20021012202856"
name="Jos De_Roo"
email="jos.deroo.jd@belgium.agfa.com"
subject="TEST: C-urrent datatying"
id="OF09E6E61A.65132403-ONC1256C50.006FD46E-C1256C50.007083D2@agfa.be"
charset="us-ascii"
expires="-1"

To:"w3c-rdfcore-wg"<w3c-rdfcore-wg@w3.org>



I think there is a way to do Mike's long range datatyping
in C-urrent datatyping while using Patrick's _:x"y" nodes

i.e.

_:a foo:bar _:x"10" .
foo:bar rdfs:range xsd:integer .

would entail

_:a foo:bar xsd:integer"10" .


and even

_:a foo:bar _:x"10" .
foo:bar rdfs:range xsd:integer .
xsd:integer rdfs:subClassOf xsd:decimal .

would entail

_:a foo:bar xsd:decimal"10" .


but

_:a foo:bar xsd:string"10" .
foo:bar rdfs:range xsd:integer .

would clash


I've tested those 3 testcases using a closure rule

         | IF                       | THEN
------------------------------------------------
:rule10  | ?p rdfs:range ?A .       |
         | ?y str:pair (?B ?a) .    |
         | ?s ?p ?x .               |
         | ?x str:pair (?A ?a) .    |
         | ?A rdfs:subClassOf ?B .  | ?s ?p ?y .

where str:pair connects a datyped-literal
with its pair datatype-uri + lexical-form
(and it does appropriate promotion of an
existential type _:d to a universal type ?d
when it occurs in a rule premise or query)

and it works
(it's hard to kick-off from datatyping...)

-- ,
Jos De Roo, AGFA http://www.agfa.com/w3c/jdroo/



