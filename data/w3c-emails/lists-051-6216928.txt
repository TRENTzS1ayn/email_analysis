docno="lists-051-6216928"
received="Mon Oct 14 09:56:15 2002"
isoreceived="20021014135615"
sent="Mon, 14 Oct 2002 14:55:25 +0100"
isosent="20021014135525"
name="Graham Klyne"
email="Graham.Klyne@MIMEsweeper.com"
subject="Re: details of rdf:datatype?"
id="5.1.0.14.2.20021014144432.03b901a0@127.0.0.1"
charset="us-ascii"
inreplyto="1034599226.27787.109.camel&#64;dirk"
expires="-1"


To: Dan Connolly<connolly@w3.org>
Cc:w3c-rdfcore-wg@w3.org


Speaking personally...

My take is that only the first case is RDF-entailed:  if the datatype and 
text are the same for two literals then they must denote the same value.

(Need to confirm this:  I understand current thinking is that language 
codes are ignored for typed literals.  Then, language has no effect on 
typed literal entailment.)

For the case of "10" vs "010" then, as you point out, additional knowledge 
(i.e. of the datatype) is required.  I'd suggest that knowledge of specific 
datatypes is outside RDF-entailment.  (Or, if certain common datatypes are 
"built in" to RDF, then that is not taken to disallow the use of unknown 
datatypes with just string-equality entailments.)

Thus, one might have [RDF+<datatype>]-entailment, in which the equivalence 
properties of <datatype> representations are used in licensing entailments.

My aim in all this is to avoid having to draw a fixed line regarding what 
can and cannot be allowed in datatype-related entailments.  If the 
framework is known to be extensible then it's easier to start out with 
minimal (or no) built in datatypes.

#g
--

At 07:40 AM 10/14/02 -0500, Dan Connolly wrote:

>I'm puzzling thru the details of the [6Sep] decision.
>
>It seems to specify that this holds:
>
>         :jenny :age <...#integer>"10".
>=>
>         :jenny :age <...#decimal>"10".
>
>
>since those two literals denote the same value.
>
>and this one holds:
>
>         :jenny :age <...#decimal>"010".
>=>
>         :jenny :age <...#decimal>"10".
>
>If somebody would please confirm, I'd appreciate it.
>
>But I don't see how this works for an open-ended set
>of datatypes. Does this hold?
>
>         :jenny :age <http://example/vocab#type1>"hello".
>=>
>         :jenny :age <http://example/vocab#type2>"hello".
>
>If type1 and type2 map hello to the same value, it does hold.
>
>Likewise, if type1 maps hello1 and hello2 to the
>same value, then the following holds:
>
>         :jenny :age <http://example/vocab#type1>"hello1".
>=>
>         :jenny :age <http://example/vocab#type1>"hello2".
>
>It seems to me that a parser should raise an exception
>if it sees rdf:datatype used with a value it doesn't
>recognize. Recognizing datatypes is a parse-time thing;
>you can't do lazy-evaluation of the type-uri/string-val
>pair.
>
>Is that the design folks have in mind?
>
>
>[6Sep] Draft minutes: telecon 2002-09-06 Jan Grant (Fri, Sep 06 2002)
>http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Sep/0081.html
>
>=>
>http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Aug/0257.html
>
>=>
>http://www-nrc.nokia.com/sw/rdf-datatyping.html
>http://lists.w3.org/Archives/Public/www-archive/2002Aug/0111.html
>
>
>--
>Dan Connolly, W3C http://www.w3.org/People/Connolly/

-------------------
Graham Klyne
<GK@NineByNine.org>



