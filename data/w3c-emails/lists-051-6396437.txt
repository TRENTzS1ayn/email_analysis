docno="lists-051-6396437"
received="Tue Oct 15 02:55:42 2002"
isoreceived="20021015065542"
sent="Tue, 15 Oct 2002 09:55:35 +0300"
isosent="20021015065535"
name="Patrick Stickler"
email="patrick.stickler@nokia.com"
subject="Re: details of rdf:datatype?"
id="001301c27417$dcbd2b90$544516ac@NOE.Nokia.com"
charset="iso-8859-1"
inreplyto="5.1.0.14.2.20021014144432.03b901a0&#64;127.0.0.1"
expires="-1"


To:"Dan Connolly"<connolly@w3.org>,"ext Graham Klyne"<Graham.Klyne@MIMEsweeper.com>
Cc:<w3c-rdfcore-wg@w3.org>




[Patrick Stickler, Nokia/Finland, (+358 40) 801 9690, patrick.stickler@nokia.com]


----- Original Message ----- 
From: "ext Graham Klyne" <Graham.Klyne@MIMEsweeper.com>
To: "Dan Connolly" <connolly@w3.org>
Cc: <w3c-rdfcore-wg@w3.org>
Sent: 14 October, 2002 16:55
Subject: Re: details of rdf:datatype?


> 
> Speaking personally...
> 
> My take is that only the first case is RDF-entailed:  if the datatype and 
> text are the same for two literals then they must denote the same value.

But they are not the same datatype. They are different URIs, and RDF
cannot know that there is any intersection of the value spaces of
xsd:integer and xsd:decimal. Thus the first case is not RDF-entailed.

> (Need to confirm this:  I understand current thinking is that language 
> codes are ignored for typed literals.  Then, language has no effect on 
> typed literal entailment.)

Correct. Any language tag, or lack thereof, has no affect on the L2V mapping.

> For the case of "10" vs "010" then, as you point out, additional knowledge 
> (i.e. of the datatype) is required.  I'd suggest that knowledge of specific 
> datatypes is outside RDF-entailment.  (Or, if certain common datatypes are 
> "built in" to RDF, then that is not taken to disallow the use of unknown 
> datatypes with just string-equality entailments.)
> 
> Thus, one might have [RDF+<datatype>]-entailment, in which the equivalence 
> properties of <datatype> representations are used in licensing entailments.
> 
> My aim in all this is to avoid having to draw a fixed line regarding what 
> can and cannot be allowed in datatype-related entailments.  If the 
> framework is known to be extensible then it's easier to start out with 
> minimal (or no) built in datatypes.

There shouldn't be any built-in datatypes, in the iterest of system
neutrality and portability.

And the only equality that RDF can make is node equality based on
identical labels for explicitly typed literals. I.e., the two
statements

   <rdf:Description rdf:about="#someThing">
      <someProperty rdf:datatype="#someDatatype">someLexicalForm</someProperty>
   </rdf:Description>
and
   <rdf:Description rdf:about="#someThing">
      <someProperty rdf:datatype="#someDatatype">someLexicalForm</someProperty>
   </rdf:Description>

would be merged into the same triple

   <#someThing> <#someProperty> <#someDatatype>"someLexicalForm" .

But RDF/S cannot determine any equality between any typed literal nodes
if either the datatype URI or lexical form are not identical.

Patrick


> #g
> --
> 
> At 07:40 AM 10/14/02 -0500, Dan Connolly wrote:
> 
> >I'm puzzling thru the details of the [6Sep] decision.
> >
> >It seems to specify that this holds:
> >
> >         :jenny :age <...#integer>"10".
> >=>
> >         :jenny :age <...#decimal>"10".
> >
> >
> >since those two literals denote the same value.
> >
> >and this one holds:
> >
> >         :jenny :age <...#decimal>"010".
> >=>
> >         :jenny :age <...#decimal>"10".
> >
> >If somebody would please confirm, I'd appreciate it.
> >
> >But I don't see how this works for an open-ended set
> >of datatypes. Does this hold?
> >
> >         :jenny :age <http://example/vocab#type1>"hello".
> >=>
> >         :jenny :age <http://example/vocab#type2>"hello".
> >
> >If type1 and type2 map hello to the same value, it does hold.
> >
> >Likewise, if type1 maps hello1 and hello2 to the
> >same value, then the following holds:
> >
> >         :jenny :age <http://example/vocab#type1>"hello1".
> >=>
> >         :jenny :age <http://example/vocab#type1>"hello2".
> >
> >It seems to me that a parser should raise an exception
> >if it sees rdf:datatype used with a value it doesn't
> >recognize. Recognizing datatypes is a parse-time thing;
> >you can't do lazy-evaluation of the type-uri/string-val
> >pair.
> >
> >Is that the design folks have in mind?
> >
> >
> >[6Sep] Draft minutes: telecon 2002-09-06 Jan Grant (Fri, Sep 06 2002)
> >http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Sep/0081.html
> >
> >=>
> >http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Aug/0257.html
> >
> >=>
> >http://www-nrc.nokia.com/sw/rdf-datatyping.html
> >http://lists.w3.org/Archives/Public/www-archive/2002Aug/0111.html
> >
> >
> >--
> >Dan Connolly, W3C http://www.w3.org/People/Connolly/
> 
> -------------------
> Graham Klyne
> <GK@NineByNine.org>
> 



