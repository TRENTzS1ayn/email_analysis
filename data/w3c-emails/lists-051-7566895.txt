docno="lists-051-7566895"
received="Tue Oct 22 02:45:28 2002"
isoreceived="20021022064528"
sent="Tue, 22 Oct 2002 08:45:24 +0200"
isosent="20021022064524"
name="Jeremy Carroll"
email="jjc@hplb.hpl.hp.com"
subject="RE: datatype literal and lang"
id="BHEGLCKMOHGLGNOKPGHDAEGOCAAA.jjc@hpl.hp.com"
charset="us-ascii"
inreplyto="5.1.0.14.0.20021021185744.08e85528&#64;0-mail-1.hpl.hp.com"
expires="-1"

To:<w3c-rdfcore-wg@w3.org>




Offlist input:
[Let's not use]
> xml:lang as a locale indicator,



This is a good point.

The danger is that our old example "3,200"-de == "3.200"-en is incorrect:
"3,200" is not part of the german language, and "3.200" is not part of the
english language.

I am imagining defining a datatype as including a mapping either:
- from string to values (prototypical example XSD)
or
- from string,language pairs to values (prototypical example the two
built-in types: rdfs:StringLiteral, rdfs:XMLLiteral.).

The former can be regarded as a special case of the latter.

Text like:

[[
NOTE: the second mechanism allows for language dependent processing,
as envisaged with the types rdfs:StringLiteral, rdfs:XMLLiteral.
This differs from locale dependent processing, for which
it is not an appropriate mechanism.
]]

can be added to clairfy the locale/language thing.

===

I believe that the example that Patrick sketched, from which a while ago he
let me see a sample datafile, does correctly use such a mechanism, and is
one of the latter types of map.

An example, of my own, would be:

my:boolean
  { { "true"-"en", "vero"-"it" }, { "false"-"en", "falso"-"it" } }

giving two values, each with two different pairs representing it.
The language codes are, as far as I appreciate the difference, a language
not a locale.

Jeremy



