docno="lists-053-11058724"
received="Mon Oct 27 19:13:11 2003"
isoreceived="20031028001311"
sent="Tue, 28 Oct 2003 01:13:04 +0100"
isosent="20031028001304"
name="Jos De_Roo"
email="jos.deroo@agfa.com"
subject="Re: entailment-from-inconsistent-graph [was: proposed test of  RDFS    entailment  rules]"
id="OFC816CCA6.C8E97E52-ONC1256DCD.00005AAD-C1256DCD.00013220@agfa.be"
charset="us-ascii"
inreplyto="entailment-from-inconsistent-graph [was: proposed test of  RDFS    entailment  rules]"
expires="-1"

To:"pat hayes<phayes"<phayes@ihmc.us>
Cc:w3c-rdfcore-wg@w3.org




[...]

> I think this way works fine and should extend to
> datatype clashes in a uniform way, though the
> derivations there will require datataype savvies
> of course.

In the mean time we got those working, but...

> The archetype datatype contradiction would be something of the form
> "literalForm"^^ex:datatype a ex:otherDatatype
> where the "LiteralForm" cannot denote something
> in the value space of ex:otherDatatype (for any
> number of reasons, the most obvious being that it
> is illtyped for ex:datatype, but in particular
> cases it could include things like
> "0.3"^^xsd:real a xsd:integer .
> where the literal is well-typed in itself, so is
> a kosher  rdfs:Literal,  but is an 'illegal'
> value for the target datatype.

that one didn't work...
After some coding and testing we finally got
[iw:Variable "_:X_2*"; = "0.3"^^xsd:float] a xsd:integer.
(remark the xsd:float instead of the xsd:real).
There are many cases to test, but doing it both
in Java and in C# helps :-)


--
Jos De Roo, AGFA http://www.agfa.com/w3c/jdroo/



