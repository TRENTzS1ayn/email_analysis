docno="lists-053-3569782"
received="Tue Mar 11 10:17:06 2003"
isoreceived="20030311151706"
sent="Tue, 11 Mar 2003 14:31:21 +0000"
isosent="20030311143121"
name="Graham Klyne"
email="GK@NineByNine.org"
subject="(Vassillis) Re: Minutes of RDFCore WG Telecon 2003-02-24"
id="5.1.0.14.2.20030311142509.02eaed68@127.0.0.1"
charset="us-ascii"
inreplyto="1047389145.15649.82.camel&#64;birch"
expires="-1"


To: Dan Brickley<danbri@w3.org>,w3c-rdfcore-wg@w3.org


At 08:25 11/03/2003 -0500, Eric Miller wrote:
>ACTION: Gk to help respond to Vassillis's comments on datatypes
>http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0282.html
>(context: http://www.w3.org/2003/02/28-rdfcore-irc#T15-48-40)

[[
Datatyping

  With the schema datatype one can specify what type of data will make
  sense in the context of a particular property. With the new
  rdf:datatype (specifying the instance datatype) one can distinguee
  between, e.g., a string "123" and the integer 123. However, when new
  datatype definitions will arise there are some open issues. How we
  can compare different datatype definitions in order to validate RDF/S
  schemas or resource descriptions? How the schema datatype of a
  property can be compared with the instance datatype of a resource
  description? Is it easy enough that people will understand it and
  will use it in the right way? Why the schema datatype of a property
  is not sufficient to interpret its data value?
]]

I understand the question to be asking for what we previously called 
"long-range datatyping";  I.e. inferring the type to apply to a literal 
from the range of a property with which it is used.

This lies at the heart of the long discussions we had about RDF 
datatyping:  of the three desiderata:

(1) same untyped literals always denote the same thing
(2) long-range datatyping
(3) monotonic logic

we could only satisfy any two of the three.

Losing monotonicity (3) would effectively lose us the ability to do any 
form of dependable reasoning about/using RDF.  So we had to choose between 
(1) and (2).  Current implementations depend heavily on (1), so we had to 
let (2) go.

#g


-------------------
Graham Klyne
<GK@NineByNine.org>
PGP: 0FAA 69FF C083 000B A2E9  A131 01B9 1C7A DBCA CB5E



