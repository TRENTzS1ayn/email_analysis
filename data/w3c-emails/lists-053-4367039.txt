docno="lists-053-4367039"
received="Fri Mar 21 07:29:49 2003"
isoreceived="20030321122949"
sent="Fri, 21 Mar 2003 12:28:24 +0000"
isosent="20030321122824"
name="Dave Beckett"
email="dave.beckett@bristol.ac.uk"
subject="LC Issue xmlsch-08 proposed response"
id="7829.1048249704@hoth.ilrt.bris.ac.uk"
expires="-1"

To:w3c-rdfcore-wg@w3.org




Below is far too much explanation below on xmlsch-08.

I'm considering striking item 7 since magic use of xsd terms isn't
so related to their question.

My previous discussion:
  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Mar/0077.html

Dave

---


ISSUE http://www.w3.org/2001/sw/RDFCore/20030123-issues/#xmlsch-08

>    We believe there are probably good reasons for using an rdf:datatype
>    attribute, instead of re-using the existing xsi:type attribute which
>    has (when the type is defined in a schema defined by XML Schema 1.0)
>    the same semantics.In particular, rdf:datatype does not assume or
>    assert the existence of the type named as a type in a schema defined
>    by XML Schema, so it would be problematic to use xsi:type.
>
>    We do fear, however, that users are likely to find this
>    near-duplication of the meaning and function of xsi:type confusing. It
>    is not clear to us what, if anything, can or should be done to
>    minimize this danger.


The RDF Core WG has considered your this comment

  URL HERE

and decided to ?????? it.


Explanation:


W3C XML Schema Datatypes in the schema documents

In W3C XML Schema (WXS), types are identified by XML qnames - the
simple types also have URIs, but that's not the crucial point here,
in WXS documents, they are given as XML Qnames.  These types or
references to user types can be explicitly used in the WXS documents
such as like this:

 <element name="comment" type="xsd:string"/>

 <attribute name="version" type="xsi:number" fixed="1.0"/>

 <restriction base="ex:BaseThing"> 
    ...
 </restriction>

 <extension base="xsi:nonNegativeInteger">
    ...
 </extension>

here, using an XML schema simple datatype xsd:string with
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"
declared earlier.

The 'type' and 'base' (there may be others) attributes take these
identifiers have xmlns="http://www.w3.org/2001/XMLSchema-instance"

type is the most common seen and usualy written as an attribute
xsi:type with xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
declared.

  xsi:type -  http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#xsi_type

so this is the potential attribute that could have appeared in
RDF/XML instance documents to say that a particular lexical form was
an XML schema datatype.


RDF Datatypes in instance documents

Example of the solution we chose
  http://www.w3.org/TR/rdf-syntax-grammar/#section-Syntax-datatyped-literals

RDF datatypes are identified by URI-references and thus to indicate
that a piece of RDF/XML is a datatype, you need to give the URI
somewhere.  Existing (untyped) literals are used like this:

As element content:
   <ex:prop>foo</ex:prop>

As attribute content:
   <ex:Node ... ex:prop="foo" ... />

The latter is seen as an abbreviation or collapsed form, the former
the more general form.  The other things that can apply to literals
are the in-scope XML language:

As element content:
   <ex:prop xml:lang="en">foo</ex:prop>

As attribute content:
   <ex:Node ... ex:prop="foo" xml:lang="en" ... />

(of course xml:lang can be on any outer element)

So it was natural to allow datatypes by creating an extra attribute
in the element form.  Using it in the attribute form would have meant
all the attributes values were of the same datatype, not very useful,
wasn't proposed.  Thus a datatyped RDF literal is used in the
instance data in the element form with a new rdf:datatype attribute:

   <ex:prop xml:lang="en" rdf:datatype="http://example.org/dt">foo</ex:prop>
   <ex:prop rdf:datatype="http://example.org/dt">foo</ex:prop>

(Note, whether xml:lang values applies to such datatypes/is involved
in the datatype mapping is another issue, please don't get
distracted!)

Now I deliberately didn't give an XML schema datatype URI in the
example above since it was agreed by the working group that any
datatype should be allowed (identified by a URI), not just the simple
XSD ones.

On the choice of attribute name, rdf:type was already used for the
class/instance relation and rdf:datatype was seen as adequate.


On using xsi:type in RDF/XML

Not in any particular order, but this is my summary of the main RDF
Core WG issues for the RDF/XML syntax on encoding datatypes using
xsi:type and why the rdf:datatype solution was used.

1. xsi:type content is an XML Qname not a URI

Thus cannot indicate any arbitrary datatype URI reference, so another
attribute would be needed for that case (like rdf:datatypeURI) -
adding two attributes would be worse than adding one.

2. XML Qname attribute content in RDF/XML

This would be the first attribute in RDF/XML to take a XML Qname
value (a big step).  This would require extra explanation so that
existing users wouldn't confuse them with those that took URIs.

3. Namespace declarations, prefixes

It would also require instance documents to declare the xsi namespace
prefix and have to also check for any namespaces declared inside such
xsi:type values and declare those too - again new implementations and
explanation needed.  

4. xsi:type would be confused with rdf:type

Since the former takes Qnames and the latter URI references, it would
be possible to get the name wrong and be confused at the errors.
Although xsi:type wouldn't be legal everywhere rdf:type was, rdf:type
would have been allowed on elements that took xsi:type.

5. confusing URIs and Qnames

A bad choice of namespace prefixes might make cause other problems in
xsi:type values, confusing them for URIs.  It would also be more than
likely that people would try to use Qnames in rdf:type attribute values.

6. xsi:type is illegal in RDF/XML now, unlikely to be used accidently

If somebody was tempted to use xsi:type, it would likely cause the
parsing to fail.  It is only ever used as an attribute in WXS
documents and to use it on a literal in RDF/XML would be something
like this:

     <ex:prop xsi:type="xsd:string">foo</ex:prop>

which is forbidden by grammar production
  http://www.w3.org/TR/2003/WD-rdf-syntax-grammar-20030123/#literalPropertyElt

7. xsd as a magic namespace

Related, it was also considered that the simple XSD datatypes (only)
are so useful that they should be automatically recognised in
rdf/xml, such that they could appear in documents using the term
xsd:string etc. alone.

In RDF this would be with the namespace prefix
  xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
so that it constructed the URIs correctly using the RDF 
  uri=concatenate(namespace-name,local-name)
method.

In that way you might have been able to do:

  <ex:Node xsd:string="foo" ... />

but not in the element form since it would be like;
  <ex:prop xsd:string="??what goes here???">foo</ex:prop>

This important set of types was considered building in but the
flexibility of using any URI won.



