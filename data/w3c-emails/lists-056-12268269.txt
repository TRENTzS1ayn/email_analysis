docno="lists-056-12268269"
received="Sat May 24 02:35:55 1997"
isoreceived="19970524063555"
sent="Sat, 24 May 1997 02:37:58 -0400 (EDT)"
isosent="19970524063758"
name="Arjun Ray"
email="aray@q2.net"
subject="RE: SD5 - Namespaces - New Version 2"
id="Pine.LNX.3.95.970524015750.21944G-100000@q2.net"
charset="US-ASCII"
inreplyto="7BB61B44F197D011892800805FD4F792A4BFF9&#64;RED-03-MSG.dns.microsoft.com"
expires="-1"

To:w3c-sgml-wg@w3.org




On Fri, 23 May 1997, Andrew Layman wrote:

> Fair question.
> 
> <BOOK lib:loaned-to="Andrew">Last of the Mohecans</BOOK>
> 
> <BOOK>
> <TITLE>Philosophy: Who Needs It</TITLE>
> <PRICE banks:CURRENCY="USD">6.95</PRICE>
> </BOOK>
> 
> We can get some integration of concepts across various doctypes by
> sharing attributes.

But attribute names are inherently shareable! Their scope is restricted to
the element(s) with which they're associated. Moreover, it's not necessary
that the same name for an attribute imply the same semantic significance
for different elements, even though as DTD design this could arguably be
poor choice(s) in nomenclature. (For instance, consider the NAME attribute
in the HTML DTDs, used for LINK, META, A and INPUT.)

The sense I'm getting here is something like this: Suppose I'm working
with a <!DOCTYPE HERE> where an element FOO has an attribute BAR that
"means" property X. At some point it occurs to me that my spec for FOO is
incomplete: this realization happens when I encounter a <!DOCTYPE THERE>
where I see an element BAZ with attribute BAR that "means" property Y; I
would like to refine my spec for FOO to include property Y.  Since the
*name* BAR is already taken, I invent some other name, say BLORT. The
only requirement, if any, appears to be some structured means of saying
that HERE=>FOO=>BLORT has the "same semantics" , namely property Y, as
THERE=>BAZ=>BAR. But this can be made clear via the HERE DTD and its
commentary, and at any rate, the *relevant* applications that know about
FOO can be expected to grok BLORT. The *name* doesn't really matter.
(The other possibility is an application that basically greps for
particular attribute names: e.g. the intent is to find attributes named
BAR that "mean" property Y. If this is a matter of something having been
hard-coded, I'm having difficulty translating a specific programming
inadequacy into a general technical requirement. Why can't the program be 
parametrized to grep for BLORT instead?)

I'm not convinced that there's a case for qualified attribute names.


Arjun
 



