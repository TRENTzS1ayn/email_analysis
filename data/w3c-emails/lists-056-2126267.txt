docno="lists-056-2126267"
received="Mon Jun 23 01:38:05 1997"
isoreceived="19970623053805"
sent="Sun, 22 Jun 1997 22:37:56 -0700"
isosent="19970623053756"
name="Jean Paoli"
email="jeanpa@microsoft.com"
subject="XML-Data"
id="78DFE33066ABD0118B9200805FD431BA932987@RED-16-MSG.dns.microsoft.com"
expires="-1"


To:"'w3c-sgml-wg@w3.org'"<w3c-sgml-wg@w3.org>,"'xml-dev@ic.ac.uk'"<xml-dev@ic.ac.uk>,"'w3c-sgml-erb@hpsgml.fc.hp.com'"<w3c-sgml-erb@hpsgml.fc.hp.com>
Cc: Andrew Layman<andrewl@microsoft.com>, Thomas Reardon<thomasre@microsoft.com>, Adam Bosworth<adamb@microsoft.com>, Hadi Partovi<hadip@microsoft.com>

I am pleased to present XML-Data, a Position Paper from Microsoft.
XML-Data is an application of XML for exchanging 
structured data and metadata on the Internet. 
This position paper is sent to multiple working groups
in the W3C dealing with this subject (XML, meta-data)
and we expect this paper to be discussed and improved
by these working groups.
The current proposal needs namespaces and uses the Layman/Bray
proposal.

The URL of this paper (on the Microsoft site) will be posted tomorrow.
-Jean Paoli

----------------
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Template"
content="C:\MSOffice\Templates\Letters &amp; Faxes\VFPSPEC97.dot">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<title>XML-Data</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000EE"
vlink="#551A8B" alink="#FF0000">

<p align="right"><font size="4"><b>XML-Data.html</b></font> </p>
<p><font size="4"><b>Position Paper from Microsoft<br>20 June 1997
</b></font>
</p>


<h1 align="center">XML-Data</h1>


<dl>
    <dt>Authors: </dt>
    <dd><a href="mailto:andrewl@microsoft.com">Andrew Layman</a>,
        Microsoft Corporation<br>
        <a href="mailto:jeanpa@microsoft.com">Jean Paoli</a>,
        Microsoft Corporation<br>
        <a href="mailto:sjd@eps.inso.com"><font size="3">Steve De
        Rose</font></a><font size="3">, Inso Corporation</font><br>
        <a href="mailto:ht@cogsci.ed.ac.uk">Henry S. Thompson</a>,
        University of Edinburgh <br>
        </dd>
    <dt>Acknowledgements:</dt>
    <dd><font size="3">We thank </font><a
        href="mailto:paul@arbortext.com"><font size="3">Paul
        Grosso</font></a><font size="3"> (Arbortext), </font><a
        href="mailto:sca@eps.inso.com"><font size="3">Sharon
        Adler</font></a><font size="3"> (Inso Corporation), </font><a
        href="mailto:alb@eps.inso.com"><font size="3">Anders
        Berglund</font></a><font size="3"> (Inso Corporation), </font><a
        href="mailto:fcha@ais.Berger-Levrault.fr">Fran?ois
        Chahuneau</a> (AIS/Berger-Levrault),<font color="#0000FF"
        size="2" face="Arial"> </font><font size="3">and </font><a
        href="mailto:edwardj@microsoft.com"><font size="3">Edward
        Jung</font></a><font size="3"> (Microsoft) for their help
        and contributions to this proposal.</font></dd>
</dl>

<p>Copyright (c) 1997 Microsoft Corp. <br>
</p>

<hr>

<h2 align="left">Abstract</h2>

<p align="left">This document provides the specification for
exchanging structured and networked data on the Web. This
specification uses XML, the Extensible Markup Language for
describing data as well as data about data. We expect this
specification to be useful for a wide range of applications such
as describing database transfers, digital signatures or
remotely-located web resources.</p>

<h2 align="left">1. Introduction</h2>

<p><font color="#000000" size="3">The Internet holds the
potential to integrate all information in a global network (with
many private but integrated domains). The Internet promises
access to information any time and, with wireless technology,
anywhere. Today, however, the Internet is merely an <i>access
medium </i>to text and pictures. To actualize the Internet's
potential, we need to add intelligent search, data exchange,
adaptive presentation, and personalization. The Internet must go
beyond setting an information <em>access</em> standard, and must
set an information <i>understanding </i>standard, which means: a
standard way of representing data so that software can better
search, move, display, and otherwise manipulate information
currently hidden in contextual obscurity.</font></p>

<p><font color="#000000" size="3">XML is an important step in
this direction. It offers a standard syntax for textual structure
of tagged data, based on extensive industry and theoretical
experience. Its lexical format easily depicts a tree structure. A
tree is a natural format that is richer than a simple flat list,
yet (compared to a generalized graph) also respectful of
cognitive and data processing requirements for economy and
simplicity. </font></p>

<p><font color="#000000" size="3">Looking at this point in more
detail, there are several ways of structuring data. One is a flat
tagging system. In this system, sets of keywords are applied to
data elements. This is a simple form of data structure, but it
does not capture any relationships between the keywords.</font></p>

<p><font color="#000000" size="3">A more advanced means of
structuring information is a tree. A tree allows expression of
subsumption, containment, or any other single (contextual)
relationship such as &quot;manages.&quot; Trees correspond to
object-oriented class hierarchies, file system hierarchies,
organizational hierarchies and so forth. Trees are relatively
easy to understand and to construct. Trees are efficient to
process, and there is a linear (<em>e.g.</em> textual) structure
that a program can parse incrementally, and determine when it is
finished. This makes trees particularly useful as a transmission
format for asynchronous, distributed systems such as the
Internet, and also for display purposes where the single
relationship (usually visual containment) enables incremental
display.</font></p>

<p><font color="#000000" size="3">A still more elaborate
structure is a directed graph. A graph allows expression of
arbitrary binary relationships, that is, many relationships
between two things. A graph can express subsumption, containment,
and any number of other relationships simultaneously. It is
therefore a superset of a tree. This makes graphs very expressive
for real-world semantics, but it also makes them harder to
understand, more difficult to construct, and less efficient to
process than trees. There is no efficient linear (<em>e.g.</em>
textual) structure of a graph that can be incrementally
processed. Therefore, while they are particularly useful for
representing (and instrumenting) the complete semantics of a
system, they are typically not suitable for transmission,
display, or immediate processing.</font></p>

<p><font color="#000000" size="3">The tree structure is proved
broadly implementable and easy to deploy, not just in theory but
also widely in practice. Industrial implementations, in the SGML
community and elsewhere, demonstrate its intrinsic quality and
industrial strength, e.g. aircraft (ATA), automotive (J2008),
banking (OFX), and semiconductors (Pinnacles PCIS).</font></p>

<p><font color="#000000" size="3">This proposal shows how to add
a single convention to XML so that graph arcs are easily added
into a lexical tree structure, without requiring decomposition of
tree format into a &quot;lowest common denominator&quot;
nodes-and-arcs structure. (For a quick look at the difference,
see the </font><a href="#XML-Data-vs-MCF"><font color="#000000"
size="3">XML-Data versus MCF in XML comparison</font></a><font
color="#000000" size="3">.)</font></p>

<p><font color="#000000" size="3">XML-Data consists of a
collection of related technologies. First, it unifies lexical
trees with graph structures. Second, it builds on this to define
a representation for schemata based on XML instance syntax. It
offers a mechanism to organize element types into a hierarchy,
and proposes a small set of basic types. Finally, it adds
facilities for lexical typing and proposes a small collection of
lexical types.</font></p>

<p><font color="#000000" size="3">XML-Data can encode the
content, semantics and schemata for a gamut of cases, from simple
and prosaic to complex and sophisticated:</font></p>

<ul>
    <li><font color="#000000" size="3">An ordinary document</font></li>
    <li><font color="#000000" size="3">A structured record, such
        as a appointment record or purchase order</font></li>
    <li><font color="#000000" size="3">An object, with data and
        methods</font></li>
    <li><font color="#000000" size="3">A data record, such as the
        result set of a query</font></li>
    <li><font color="#000000" size="3">Information in a database
        or a web site (<em>e.g. </em>CDF)</font></li>
    <li><font color="#000000" size="3">Graphical presentation
(<em>e.g.</em>
        an application user interface)</font></li>
    <li><font color="#000000" size="3">Upper ontology (standard
        schema entities and types)</font></li>
    <li><font color="#000000" size="3">UberWeb (all the links
        between information and people on the web)</font></li>
</ul>

<p><font color="#000000" size="3">The resulting flexibility of a
single homogenous data representation system allows any reader to
uniformly determine the structural semantics of a data element.
Information can then be reused for new purposes and in novel
contexts. For example, a record from a database of restaurants
and a record from a client contact database might be reused in
the context of an appointment, say in setting a lunch date with a
client. The relationships between the restaurant and contact data
do not reside in the schema data described by either database
individually, but are extensions defined by the instance of the
appointment.</font></p>

<p><font color="#000000" size="3">This proposal, building on the
earlier <em>Web Collections in XML </em>proposal, shows how to
use a single syntax for a broad range of data, using that syntax
for data and schemata, permitting the expressiveness of graph
data when such power is required, but retaining the benefits of
lexical trees.</font></p>

<h2 align="left">2. Examples of XML-Data</h2>

<h3><font size="4" face="Times New Roman"><code>Data</code></font></h3>

<p><font size="4" face="Times New Roman"><code>The following
example shows a simple order from a bookstore for several books,
a record, and a cup of coffee.</code></font></p>

<pre><code>&lt;ORDER&gt;
  &lt;SOLD-TO&gt;
    &lt;PERSON&gt;&lt;LASTNAME&gt;<strong>Layman</strong>&lt;/PERSON&gt;
            &lt;FIRSTNAME&gt;<strong>Andrew</strong>&lt;/FIRSTNAME&gt;
    &lt;/PERSON&gt;
  &lt;/SOLD-TO&gt;
  &lt;SOLD-ON&gt;<strong>19970317</strong>&lt;/SOLD-ON&gt;
  &lt;ITEM&gt;
    &lt;PRICE&gt;<strong>5.95</strong>&lt;/PRICE&gt;
    &lt;BOOK&gt;
      &lt;TITLE&gt;<strong>Number, the Language of
Science</strong>&lt;/TITLE&gt;
      &lt;AUTHOR&gt;<strong>Dantzig, Tobias</strong>&lt;/AUTHOR&gt;
    &lt;/BOOK&gt;
  &lt;/ITEM&gt;
  &lt;ITEM&gt;
    &lt;PRICE&gt;<strong>12.95</strong>&lt;/PRICE&gt;
    &lt;BOOK&gt;
      &lt;TITLE&gt;<strong>Introduction to Objectivist
Epistemology</strong>&lt;/TITLE&gt;
      &lt;AUTHOR&gt;<strong>Rand, Ayn</strong>&lt;/AUTHOR&gt;
    &lt;/BOOK&gt;
  &lt;/ITEM&gt;
  &lt;ITEM&gt;
    &lt;PRICE&gt;<strong>12.95</strong>&lt;/PRICE&gt;
    &lt;RECORD&gt;

&lt;TITLE&gt;&lt;COMPOSER&gt;<strong>Tchaikovsky's</strong>&lt;/COMPOSER
&gt;<strong> First Piano Concerto</strong>&lt;/TITLE&gt;
      &lt;ARTIST&gt><strong>Janos</strong>&lt;/ARTIST&gt;
    &lt;/RECORD&gt;
  &lt;/ITEM&gt;
  &lt;ITEM&gt;
    &lt;PRICE&gt;<strong>1.50</strong>&lt;/PRICE&gt;
    &lt;COFFEE&gt;
      &lt;SIZE&gt;<strong>small</strong>&lt;/SIZE&gt;
      &lt;STYLE&gt;<strong>cafe macchiato</strong>&lt;/STYLE&gt;
    &lt;/COFFEE&gt;
  &lt;/ITEM&gt;
&lt;/ORDER&gt;</code></pre>

<p><font size="4" face="Times New Roman"><code>XML-Data is
flexible enough to encode heterogeneous structures, for example
books, records and coffee all within one sales order. These
different kinds of items do not need to all have the same
internal parts. For example, books have titles, coffee generally
doesn't. XML-Data allows values to be expressed as element
content (for example the book titles shown) or with a <em>value</em>
attribute (for example the author and artist elements).
Properties of elements can be expressed as attributes (e.g. size
and style of coffee) or as sub-elements (e.g. author, artist).
XML-Data can appear in separate documents or within other
documents (such as HTML pages).</code></font></p>

<h3><font size="4" face="Times New Roman"><code>Data about Other
Data</code></font></h3>

<p><font size="4" face="Times New Roman"><code>XML-Data is
suitable for complex, self-contained data structures such as the
book order, and also for information such as the </code></font><a
href="http://www.microsoft.com/standards/cdf-f.htm"><code>Channel
Definition Format</code></a><code>, </code><font size="4"
face="Times New Roman"><code>which describes remotely-located web
resources, many of which are themselves data:</code></font></p>

<pre><code>&lt;CHANNEL&gt;
  &lt;ITEM
HREF=&quot;<strong>http://www.zoosports.com/intro.htm</strong>&quot;
level=&quot;<strong>2</strong>&quot;
precache=&quot;<strong>NO</strong>&quot;&gt;
    &lt;A
HREF=&quot;<strong>http://www.zoosports.com/page1.htm</strong>&quot;&gt;
<strong>This is a link to page 1.</strong>&lt;/A&gt;
    &lt;TITLE&gt;<strong>Welcome to ZooSports!</strong>&lt;/TITLE&gt;
    &lt;ABSTRACT&gt;<strong>ZooSports articles, news, and promotional
offers</strong>&lt;/ABSTRACT&gt;
  &lt;/ITEM&gt;
  &lt;SCHEDULE ENDDATE=&quot;<strong>1994-11-05</strong>&quot;&gt;
    &lt;INTERVALTIME DAY=&quot;<strong>1</strong>&quot;/&gt;
    &lt;EARLIESTTIME HOUR=&quot;<strong>12</strong>&quot;/&gt;
    &lt;LATESTTIME HOUR=&quot;<strong>18</strong>&quot;/&gt;
  &lt;/SCHEDULE&gt;
&lt;/CHANNEL&gt;</code></pre>

<h3><font size="4" face="Times New Roman"><code>PICS-NG
Labels</code></font></h3>

<p><font size="4" face="Times New Roman"><code>XML-Data can
express PICS-NG Labels</code></font><font size="5"
face="Times New Roman"><code>:</code></font></p>

<p><font size="4" face="Times New Roman"><code>(This uses the
</code></font><a
href="http://www.w3.org/XML/Group/9705/namespace.htm"><font
size="4" face="Times New Roman"><code>Layman-Bray proposal for
namespaces</code></font></a><font size="4" face="Times New
Roman"><code>.)</code></font></p>

<pre><code>&lt;xml&gt;
  &lt;xml:schema&gt;
    &lt;namespaceDcl
href=&quot;<strong>http://purl.org/Schemas</strong>&quot;
name=&quot;<strong>purl</strong>&quot;/&gt;
    &lt;namespaceDcl
href=&quot;<strong>http://www.foo.com</strong>&quot;
name=&quot;<strong>foo</strong>&quot;/&gt;
  &lt;/xml:schema&gt;
  &lt;xml:data&gt;
    &lt;purl:description1
href=&quot;<strong>http://purl.color.org/document.html</strong>&quot;&gt
;
      &lt;title&gt;<strong>Light and Dark: A study of
color</strong>&lt;/title&gt;
      &lt;subject&gt;&lt;LCSH&gt;
          &lt;for&gt;<strong>Color and Color
Palettes</strong>&lt;/for&gt;&lt;/LCSH&gt; &lt;/subject&gt;
      &lt;author&gt; &lt;foo:author&gt;
                            &lt;name&gt;<strong>John
Smith</strong>&lt;/name&gt

&lt;affiliation&gt;<strong>thedarkside</strong>&lt;/affiliation&gt;

&lt;email&gt;<strong>john@thedarkside</strong>&lt;/email&gt;&lt;/foo:aut
hor&gt;
               &lt;foo:author&gt;
                            &lt;name&gt;<strong>Smith, Jane
Q.</strong>&lt;/name&gt

&lt;affiliation&gt;<strong>thelightregion</strong>&lt;/affiliation&gt;

&lt;email&gt;<strong>jane@thelightregion</strong>&lt;/email&gt;&lt;/foo:
author&gt;&lt;/purl:description1&gt;
  &lt;/xml:data&gt;
&lt;/xml&gt;</code></pre>

<h3><font size="4" face="Times New Roman"><code>Digital
Signatures, Security &amp;Authentication</code></font></h3>

<p><font size="4" face="Times New Roman"><code>Returning to the
bookstore example, this is the same order with a digital
signature added. The structured nature of XML-Data makes it easy
to sign whole elements or parts of them.</code></font></p>

<pre><code>&lt;ORDER&gt;
  &lt;dsig:DSIG&gt;

&lt;MANIFEST&gt><strong>80183589575795589189518915</strong>&lt;/MANIFEST
&gt;
    &lt;SIG
href=&quot;<strong>http://XYX/Joe@company.com</strong>&quot;/&gt;
  &lt;/dsig:DSIG&gt;
  &lt;SOLD-TO&gt;
    &lt;PERSON&gt;&lt;LASTNAME&gt><strong>Layman</strong>&lt;/PERSO&gt;
            &lt;FIRSTNAME&gt><strong>Andrew</strong>&lt;/FIRSTNAME&gt;
    &lt;/PERSON&gt;
  &lt;/SOLD-TO&gt;
  &lt;SOLD-ON&gt><strong>19970317&lt;/SOL</strong>&gt;
  &lt;ITEM&gt;
    &lt;PRICE&gt;<strong>5.95</strong>&lt;/PRICE&gt;
    &lt;BOOK&gt;
      &lt;TITLE&gt;<strong>Number, the Language of
Science</strong>&lt;/TITLE&gt;
      &lt;AUTHOR&gt;<strong>Dantzig, Tobias</strong>&lt;/AUTHOR&gt;
    &lt;/BOOK&gt;
  &lt;/ITEM&gt;
  &lt;ITEM&gt;
    &lt;PRICE&gt;<strong>12.95</strong>&lt;/PRICE&gt;
    &lt;BOOK&gt;
      &lt;TITLE&gt;<strong>Introduction to Objectivist
Epistemology</strong>&lt;/TITLE&gt;
      &lt;AUTHOR&gt;<strong>Rand, Ayn</strong>&lt;/AUTHOR&gt;
    &lt;/BOOK&gt;
  &lt;/ITEM&gt;
  &lt;ITEM&gt;
    &lt;PRICE&gt;<strong>12.95</strong>&lt;/PRICE&gt;
    &lt;RECORD&gt;

&lt;TITLE&gt;&lt;COMPOSER&gt;<strong>Tchaikovsky's</strong>&lt;/COMPOSER
&gt;<strong> First Piano Concerto</strong>&lt;/TITLE&gt;
      &lt;ARTIST&gt><strong>Janos</strong>&lt;/ARTIST&gt;
    &lt;/RECORD&gt;
  &lt;/ITEM&gt;
  &lt;ITEM&gt;
    &lt;PRICE&gt;<strong>1.50</strong>&lt;/PRICE&gt;
    &lt;COFFEE&gt;
      &lt;SIZE&gt;<strong>small</strong>&lt;/SIZE&gt;
      &lt;STYLE&gt;<strong>cafe macchiato</strong>&lt;/STYLE&gt;
    &lt;/COFFEE&gt;
  &lt;/ITEM&gt;
&lt;/ORDER&gt;</code></pre>

<h3><font size="4" face="Times New Roman"><code>Database
Information</code></font></h3>

<p><font size="4" face="Times New Roman"><code>While XML-Data can
represent complex structures, it can also represent simple ones,
for example a simple list of database records:</code></font></p>

<pre><code>&lt;BOOK-MASTER-LIST&gt;
  &lt;BOOK id=&quot;book1&quot;&gt;
    &lt;TITLE&gt;<strong>Number, the Language of
Science</strong>&lt;/TITLE&gt;
    &lt;AUTHOR&gt><strong>Dantzig, Tobias</strong>&lt;/AUTHOR&gt;
  &lt;/BOOK&gt;

  &lt;BOOK id=&quot;book2&quot;&gt;
    &lt;TITLE&gt;<strong>Introduction to Objectivist
Epistemology</strong>&lt;/TITLE&gt;
    &lt;AUTHOR&gt><strong>Rand, Ayn</strong>&lt;/AUTHOR&gt;
  &lt;/BOOK&gt;

  &lt;BOOK id=&quot;book3&quot;&gt;
    &lt;TITLE&gt;<strong>I, The Jury</strong>&lt;/TITLE&gt;
    &lt;AUTHOR&gt><strong>Spillane, Mickey</strong>&lt;/AUTHOR&gt;
  &lt;/BOOK&gt;

  &lt;BOOK id=&quot;book4&quot;&gt;
    &lt;TITLE&gt;<strong>Half Magic</strong>&lt;/TITLE&gt;
    &lt;AUTHOR&gt><strong>Eager, Edward</strong>&lt;/AUTHOR&gt;
  &lt;/BOOK&gt;

  &lt;BOOK id=&quot;book5&quot;&gt;
    &lt;TITLE&gt;<strong>QED</strong>&lt;/TITLE&gt;
    &lt;AUTHOR&gt><strong>Feynmann, Richard P.</strong>&lt;/AUTHOR&gt;
  &lt;/BOOK&gt;
&lt;BOOK-MASTER-LIST&gt;</code></pre>

<h3><font size="4" face="Times New Roman"><code>Graph
Structures</code></font></h3>

<p><font size="4" face="Times New Roman"><code>An XML-Data
element may include links to resources outside the immediate
tree. When it meets application needs, this <em>href</em>
facility can be used to break up a single structure into multiple
parts, with relations among them indicated by Universal Resource
Identifier (URI) links. The references can be local or remote. In
this example, they are inventory records from the database table
we just looked at.</code></font></p>

<pre><code>&lt;ORDER id=&quot;order1&quot;&gt;
   &lt;dsig:DSIG&gt;

&lt;MANIFEST&gt><strong>80183589575795589189518915</strong>&lt;/MANIFEST
&gt;
     &lt;SIG
href=&quot;<strong>http://XYX/Joe@company.com</strong>&quot;/&gt;
   &lt;/dsig:DSIG&gt;
   &lt;SOLD-TO&gt;

&lt;PERSON&gt;&lt;LASTNAME&gt><strong>Layman</strong>&lt;/PERSO&gt;
              &lt;FIRSTNAME&gt><strong>Andrew</strong>&lt;/FIRSTNAME&gt;
      &lt;/PERSON&gt;
    &lt;/SOLD-TO&gt;
    &lt;SOLD-ON&gt<strong>19970317&lt;</strong>&lt;/SOLD-ON&gt;
    &lt;ITEM
href=&quot;<strong>http://bigbookstore.com/data/bookmaster?XML-XPTR=book
1</strong>&quot;&gt;
      &lt;PRICE&gt;5.95&lt;/PRICE&gt;
    &lt;/ITEM&gt
    &lt;ITEM
href=&quot;<strong>http://bigbookstore.com/data/bookmaster?XML-XPTR=book
2</strong>&quot;&gt;
      &lt;PRICE&gt;12.95&lt;/PRICE&gt;
    &lt;/ITEM&gt
    &lt;ITEM
href=&quot;<strong>http://bigbookstore.com/data/musicmaster?XML-XPTR=cd1
</strong>&quot;&gt;
      &lt;PRICE&gt;12.95&lt;/PRICE&gt;
    &lt;/ITEM&gt
    &lt;ITEM&gt;
      &lt;PRICE&gt;1.50&lt;/PRICE&gt;
      &lt;COFFEE&gt;
        &lt;SIZE&gt;<strong>small</strong>&lt;/SIZE&gt;
        &lt;STYLE&gt;<strong>cafe macchiato</strong>&lt;/STYLE&gt;
      &lt;/COFFEE&gt;
    &lt;/ITEM&gt;
&lt;/ORDER&gt;</code></pre>

<p><font size="4" face="Times New Roman"><code>Notice that each
of the ITEM elements establishes a relationship between the ORDER
and a BOOK, and that the <em>relationship itself</em>
has attributes, in this case the price at which the book was
sold. Relations can have attributes, can contain elements and the
process can be carried to any needed level of detail.</code></font></p>

<h3><font size="4" face="Times New Roman"><code>Discontiguous
Information (propertyOf)</code></font></h3>

<p><font size="4" face="Times New Roman"><code>Information about
an element can be contained in the element, but also can sit
outside it. For example, the following applies a digital
signature to a sales order without actually modifying the
order:</code></font></p>

<pre><code>&lt;dsig:DSIG&gt;
  &lt;xml:propertyOf
href=&quot;<strong>http://bigbookstore.com/data/orders?XML-XPTR=order1&q
uot;/&gt;</strong>
  &lt;MANIFEST
&gt;<strong>80183589575795589189518915</strong>&lt;/MANIFEST&gt;
  &lt;SIG
href=&quot;<strong>http://XYX/Joe@company.com</strong>&quot;/&gt;
&lt;/dsig:DSIG&gt;</code></pre>

<h3><font size="4" face="Times New
Roman"><code>Schema</code></font></h3>

<p><font size="4" face="Times New Roman"><code>Every data object,
such as a purchase order, contains certain parts, such as
sold-to, sold-on date, items, etc. We can write a formal
description of what these parts are and which are allowed where.
This is called a &quot;schema&quot; and is written using a form
of XML-Data:</code></font></p>

<pre><code>&lt;xml:schema ID=&quot;BookOrderSchema&quot;&gt;
  &lt;!-- This schema is digitally signed. Schemas are a form of data,
       so they, too, can be signed. --&gt;
  &lt;dsig:DSIG&gt;
    &lt;MANIFEST
&gt;<strong>*(&amp;#&amp;$&amp;@*$&amp;%*&amp;@*$&amp;$*@</strong>&lt;/M
ANIFEST&gt;
    &lt;SIG
href=&quot;<strong>http://XYX/Jane@company.com</strong>&quot;/&gt;
  &lt;/dsig:DSIG&gt;

  &lt;!-- Here are all the element types, their contents,
       attributes and relations. --&gt;
  &lt;elementType id=&quot;<strong>ORDER</strong>&quot;&gt;
    &lt;relation href=&quot;<strong>#SOLD-TO</strong>&quot;/&gt;
    &lt;relation href=&quot;<strong>#SOLD-ON</strong>&quot;/&gt;
    &lt;relation href=&quot;<strong>#ITEM</strong>&quot;
occurs=&quot;<strong>STAR</strong>&quot;/&gt;
  &lt;/elementType&gt;
  &lt;relationType id=&quot;<strong>SOLD-TO</strong>&quot;&gt;
    &lt;elt href=&quot;<strong>#PERSON</strong>&quot;/&gt;
  &lt;/relationType&gt;
  &lt;relationType id=&quot;<strong>SOLD-ON</strong>&quot;&gt;  
    &lt;pcdata/&gt;
    &lt;!-- Date is YYYYMMDD --&gt;
    &lt;attribute name=&quot;<strong>lextype</strong>&quot;
default=&quot;<strong>DATE.ISO8061</strong>&quot;
presence=&quot;<strong>fixed</strong>&quot;/&gt;
  &lt;/relationType&gt;
  &lt;elementType id=&quot;<strong>PERSON</strong>&quot;&gt;
    &lt;relation href=&quot;<strong>#LASTNAME</strong>&quot;/&gt;
    &lt;relation href=&quot;<strong>#FIRSTNAME</strong>&quot;/&gt;
  &lt;/elementType&gt;
  &lt;elementType id=&quot;<strong>LASTNAME</strong>&quot;&gt;
    &lt;pcdata/&gt;
  &lt;/elementType&gt;
  &lt;elementType id=&quot;<strong>FIRSTNAME</strong>&quot;&gt;
    &lt;pcdata/&gt;
  &lt;/elementType&gt;
  &lt;relationType id=&quot;<strong>PRICE</strong>&quot;&gt;
    &lt;pcdata/&gt;
  &lt;/relationType&gt;
  &lt;relationType id=&quot;<strong>ITEM</strong>&quot;&gt;
    &lt;any/&gt;
    &lt;relation href=&quot;<strong>#PRICE</strong>&quot;/&gt;
    &lt;range href=&quot;<strong>#BOOK</strong>&quot;/&gt;
    &lt;range href=&quot;<strong>#RECORD</strong>&quot;/&gt;
    &lt;range href=&quot;<strong>#COFFEE</strong>&quot;/&gt;
  &lt;/relationType&gt;
  &lt;elementType id=&quot;<strong>BOOK</strong>&quot;&gt;
    &lt;relation href=&quot;<strong>#TITLE</strong>&quot;/&gt;
    &lt;relation href=&quot;<strong>#AUTHOR</strong>&quot;/&gt;
  &lt;/elementType&gt;
  &lt;elementType id=&quot;<strong>RECORD</strong>&quot;&gt;
    &lt;relation href=&quot;<strong>#TITLE</strong>&quot;/&gt;
    &lt;relation href=&quot;<strong>#ARTIST</strong>&quot;/&gt;
  &lt;/elementType&gt;
  &lt;relationType id=&quot;<strong>SIZE</strong>&quot;&gt;
    &lt;pcdata/&gt;
  &lt;/relationType&gt;
  &lt;relationType id=&quot;<strong>STYLE</strong>&quot;&gt;
    &lt;pcdata/&gt;
  &lt;/relationType&gt;
  &lt;elementType id=&quot;<strong>COFFEE</strong>&quot;&gt;
    &lt;relation href=&quot;<strong>#SIZE</strong>&quot;/&gt;
    &lt;relation href=&quot;<strong>#STYLE</strong>&quot;/&gt;
  &lt;/elementType&gt;
  &lt;elementType id=&quot;<strong>TITLE</strong>&quot;&gt;
    &lt;mixed&gt;&lt;elt
href=&quot;<strong>#COMPOSER</strong>&quot;/&gt;&lt;/mixed&gt;
  &lt;/elementType&gt;
  &lt;relationType id=&quot;<strong>AUTHOR</strong>&quot;&gt;
    &lt;pcdata/&gt;
  &lt;/relationType&gt;
  &lt;relationType id=&quot;<strong>ARTIST</strong>&quot;&gt;
    &lt;pcdata/&gt;
  &lt;/relationType&gt;
  &lt;relationType id=&quot;<strong>COMPOSER</strong>&quot;&gt;
    &lt;pcdata/&gt;
  &lt;/relationType&gt;
&lt;/xml:schema&gt;</code></pre>

<h3><font size="4" face="Times New Roman"><code>Type
Extension</code></font></h3>

<p><font size="4" face="Times New Roman"><code>Sometimes some
elements are variants of others, in which case we can organize
the element types into a genus-species hierarchy using the
<em>extends</em>
attribute:</code></font></p>

<pre><code>&lt;xml:schema ID=&quot;<strong>ArtSchema</strong>&quot;&gt;
  &lt;elementType id=&quot;<strong>artistic-work</strong>&quot;&gt;
    &lt;relation href=&quot;<strong>#TITLE</strong>&quot;/&gt;
  &lt;/elementType&gt;
  &lt;elementType id=&quot;<strong>BOOK</strong>&quot;
extends=&quot;<strong>#artistic-work</strong>&quot;&gt;
    &lt;relation href=&quot;<strong>#AUTHOR</strong>&quot;/&gt;
  &lt;/elementType&gt;
  &lt;elementType id=&quot;<strong>RECORD</strong>&quot;
extends=&quot;<strong>#artistic-work</strong>&quot;&gt;
    &lt;relation href=&quot;<strong>#ARTIST</strong>&quot;/&gt;
    &lt;relation href=&quot;<strong>#COMPOSER</strong>&quot;
occurs=&quot;<strong>OPTIONAL</strong>&quot;/&gt;
  &lt;/elementType&gt;
  &lt;relationType id=&quot;<strong>AUTHOR</strong>&quot;&gt;
    &lt;pcdata/&gt;
  &lt;/relationType&gt;
  &lt;relationType id=&quot;<strong>COMPOSER</strong>&quot;
extends=&quot;<strong>#AUTHOR</strong>&quot;/&gt;
  &lt;relationType id=&quot;<strong>ARTIST</strong>&quot;&gt;
    &lt;pcdata/&gt;
  &lt;/relationType&gt;
&lt;/xml:schema&gt;</code></pre>

<p><font size="4" face="Times New Roman"><code>Here we see that
books and records are both types of artistic work, and that a
composer is a type of author.</code></font></p>

<h3><font size="4" face="Times New Roman"><code>Schema
Extension</code></font></h3>

<p><font size="4" face="Times New Roman"><code>We can use also
use this ability to customize a schema that has useful features,
but which is too general. In this example, we show a general
schema for orders, then another one that is customized for our
bookstore:</code></font></p>

<pre><code>&lt;xml:schema
ID=&quot;<strong>GenericOrderSchema</strong>&quot;&gt;
  &lt;elementType id=&quot;<strong>ORDER</strong>&quot;&gt;
    &lt;relation href=&quot;<strong>#SOLD-TO</strong>&quot;/&gt;
    &lt;relation href=&quot;<strong>#SOLD-ON</strong>&quot;/&gt;
  &lt;/elementType&gt;
  &lt;relationType id=&quot;<strong>SOLD-TO</strong>&quot;&gt;
    &lt;elt href=&quot;<strong>#PERSON</strong>&quot;/&gt;
  &lt;/relationType&gt;
  &lt;elementType id=&quot;<strong>PERSON</strong>&quot;&gt;
    &lt;relation href=&quot;<strong>#LASTNAME</strong>&quot;/&gt;
    &lt;relation href=&quot;<strong>#FIRSTNAME</strong>&quot;/&gt;
  &lt;/elementType&gt;
  &lt;relationType id=&quot;<strong>LASTNAME</strong>&quot;&gt;
    &lt;pcdata/&gt;
  &lt;/relationType&gt;
  &lt;relationType id=&quot;<strong>FIRSTNAME</strong>&quot;&gt;
    &lt;pcdata/&gt;
  &lt;/relationType&gt;
&lt;/xml:schema&gt;  


&lt;xml:schema id=&quot;BookOrderSchema&quot;&gt;
  &lt;elementType id=&quot;<strong>ORDER</strong>&quot;
extends=&quot;<strong>http://generic.com/genericOrder?XML-XPTR=ID(ORDER)
</strong>&quot;&gt;
    &lt;relation href=&quot;<strong>#ITEM</strong>&quot;
occurs=&quot;<strong>STAR</strong>&quot;/&gt;
  &lt;/elementType&gt;

  &lt;relationType id=&quot;<strong>ITEM</strong>&quot;&gt;
    &lt;any/&gt;
    &lt;relation
href=&quot;<strong>http://generic.com/genericOrder?XML-XPTR=ID(ORDER)</s
trong>&quot;/&gt;
    &lt;range
href=&quot;<strong>http://art.com/schemata?XML-XPTR=ID(BOOK)</strong>&qu
ot;/&gt;
    &lt;range
href=&quot;<strong>http://art.com/schemata?XML-XPTR=ID(RECORD)</strong>&
quot;/&gt;
    &lt;range href=&quot;<strong>#COFFEE</strong>&quot;/&gt;
  &lt;/relationType&gt;

  &lt;relationType id=&quot;<strong>SIZE</strong>&quot;&gt;
    &lt;pcdata/&gt;
  &lt;/relationType&gt;

  &lt;relationType id=&quot;<strong>STYLE</strong>&quot;&gt;
    &lt;pcdata/&gt;
  &lt;/relationType&gt;

  &lt;elementType id=&quot;<strong>COFFEE</strong>&quot;&gt;
    &lt;relation href=&quot;<strong>#SIZE</strong>&quot;/&gt;
    &lt;relation href=&quot;<strong>#STYLE</strong>&quot;/&gt;
  &lt;/elementType&gt;
&lt;/xml:schema&gt;</code></pre>

<h2 align="left">3. XML-Data Schema</h2>

<p align="left">The XML-Data schema language defines element
types, attributes, relations, and which of these can be used in
which combinations with others. It also provides features for
organizing element types into a genus-species hierarchy, a basic
set of element types, and a small set of lexical types. The
schema contains other features from XML Document Type Definition
(DTD) language, such as entity and notation declarations. The
XML-Data schema is powerful enough to express the same structural
information and constraints as XML DTDs. It covers all the
features of XML-DTDs. An XML DTD can be mechanically converted to
an XML-Data schema. </p>

<p>Schemata are composed of principally of declarations for: </p>

<ul>
    <li>element types, represented by <i>elementType</i></li>
    <li>attributes of elements, represented by attribute</li>
    <li>relations<em> </em>among elements, represented by
<em>relationType</em></li>
    <li>rules governing the valid combinations of the above,
        represented by <em>any, mixed </em>and<em> pcdata; </em>also
        by<em> ent</em>, <em>group</em>, <em>relation, </em>and<em>
        range.</em>.</li>
    <li>internal and external entities, represented by
<i>intEntityDecl</i>
        and <i>extEntityDecl</i></li>
    <li>notations, represented by <i>notationDcl</i></li>
</ul>

<p>Comments can be interspersed as usual in XML, and there is
provision for using references to external schemata or schema
fragments.</p>

<h3><b>3.1. The schema document element type: </b><b><i>schema</i></b>
</h3>

<p>All schema elements are contained within a schema element,
like this:</p>

<pre><code>&lt;?XML version='1.0' rmd='all'?&gt;
&lt;!doctype schema SYSTEM
&quot;http://www.w3c.org/pub/sotr/schema.dtd&quot;&gt;
&lt;xml:schema id='ExampleSchema'&gt;
  &lt;!-- schema goes here. --&gt;
&lt;/xml:schema&gt;</code></pre>

<h3><b>3.2. The element type declaration element type:
elementType</b> </h3>

<p><em>Key terms used here:</em> <strong>element, elementType,
empty, any, mixed, pcdata</strong>, <strong>content model.</strong></p>

<p>The heart of an XML-Data schema is the <strong>elementType</strong>
declaration which defines a class of elements, gives them
attributes, establishes a grammar of which other element types
and character data are allowed in their contents and defines
their allowable relationships to elements of other classes. (The
allowable content, including relations, is called &quot;content
model.&quot;)</p>

<pre><code>&lt;elementType id=&quot;example&quot;&gt;  &lt;!-- element
example (p*) --&gt;
    &lt;elt href=&quot;#p&quot; occurs=&quot;STAR&quot;/&gt;
&lt;/elementType&gt;
&lt;elementType id=&quot;p&quot;&gt;       &lt;!-- element p
((#PCDATA|p)*) --&gt;
    &lt;mixed&gt;&lt;elt href=&quot;#p&quot;/&gt;&lt;/mixed&gt; 
&lt;/elementType&gt;</code></pre>

<p>The name attribute is optional if id is present, in which case
the id is used as the name.</p>

<p>Within an elementType, <em>elt</em> indicates that instances
are permitted to only have a single element type in their
content. The <em>occurs</em> attribute of <em>elt</em> specifies
whether this content is optional, and gives its cardinality. </p>

<p><em>Empty</em> and <em>any</em> content are expressed using
predefined elements <em>empty</em> and <em>any</em>. (<em>Empty</em>
may be omitted. <em>Any</em> signals that any mixture of elements
and parsed character data is legal.) Parsed character data
content is similarly expressed with a <em>pcdata</em> item.
<em>Mixed</em>
content (a mixture of parsed character data and one or more
element types), is identified by a <em>mixed</em> element, whose
content identifies the element types allowed in addition to
parsed character data (see below). </p>

<pre><code>&lt;elementType id=&quot;ARTIST&quot;&gt;
  &lt;pcdata/&gt;
&lt;/elementType&gt;</code></pre>

<p>More complex content models are created using <em>group</em>:</p>

<pre>&lt;elementType id=&quot;animalFriends&quot; &gt;
  &lt;group groupType=&quot;OR&quot; occurs=&quot;STAR&quot;&gt;
    &lt;group groupType=&quot;OR&quot; occurs=&quot;PLUS&quot;&gt;
      &lt;elt href=&quot;#cat&quot;/&gt;
      &lt;elt href=&quot;#dog&quot;/&gt;
    &lt;/group&gt;
    &lt;elt href=&quot;#bird&quot;/&gt;
    &lt;elt href=&quot;#rabbit&quot;/&gt;
    &lt;elt href=&quot;#pig&quot;/&gt;
    &lt;elt href=&quot;#fish&quot;/&gt;
  &lt;/group&gt;
&lt;/elementType&gt;</pre>

<h3>3.3 Relations</h3>

<p><em>Key terms used here:</em> <strong>relationType, relation,
XML-Link locator, href.</strong></p>

<p><em>Relation</em> element types express a relationship between
one element (usually the relation's parent) and either another
element or an atomic value (such as a simple number, string or
date). Relations use the XML-Link <em>locator</em> without
implying navigation. The target of a relation is the element
referenced by the <em>href</em> attribute if one is present, 
else the element contents. This single convention unifies graphs
and trees.</p>

<p>Including a relation in an elementType makes it an implicit
part of that element's content model, with the default for occurs
being OPTIONAL. Relations must occur (in a valid document
instance) after any other content. RelationsTypes are elements,
and the full content model is as if there were a sequential group
containing first the explicitly provided content model, then the
relations in a <em>starred</em> <em>or</em> group with all the
relations as content. </p>

<p>Two element types are used in the schema to effect a relation:
The <em>relationType</em> is a specialized kind of <em>elementType</em>,
while <em>relation</em> has the same function as <em>elt </em>(
but validates that it refers to a relationType). </p>

<p>If a <em>default</em> attribute is specified for a relation,
it becomes the default of the <em>value</em> attribute of the
relation elt. The <em>range</em> element, if present, declares a
restriction on the valid target of a relation. Each range element
references one elementType; any of which are valid. </p>

<pre><code> &lt;relationType id=&quot;favoriteFood&quot;
&gt;&lt;mixed/&gt;&lt;/relationType&gt;
 &lt;relationType id=&quot;chases&quot;
&gt;&lt;any/&gt;&lt;/relationType&gt;

 &lt;elementType id=&quot;dog&quot; &gt;
   &lt;any/&gt;
   &lt;attribute name=&quot;name&quot;/&gt;
   &lt;relation href=&quot;favoriteFood&quot;/&gt;
   &lt;relation href=&quot;chases&quot;/&gt;
 &lt;/elementType&gt;</code></pre>

<h3>3.4 Attributes</h3>

<p><em>Key terms used here:</em> <strong>attribute, attribute,
values, default. </strong></p>

<p>After the content model, attribute declarations may occur,
which are divided into attributes with enumerated or notation
values, and all other kinds.</p>

<pre><code>&lt;elementType id=&quot;p1&quot;&gt;       &lt;!-- element
p1 ((#PCDATA|p1)*) --&gt;
    &lt;mixed&gt;&lt;elt href=&quot;#p&quot;/&gt;&lt;/mixed&gt; 
    &lt;attribute name='id' type='ID'/&gt;  &lt;!-- attlist p id
ID=#IMPLIED
                                                        exm (a|b|c) 'c'
                                                        x CDATA FIXED
'y' --&gt;
    &lt;attribute name='exm' type='ENUMERATION' values='a b
c'default='c'/&gt;
    &lt;attribute name='x' defType='FIXED' default='y'/&gt;
&lt;/elementType&gt;</code></pre>

<p>An attribute may be given a <em>default</em> value. Whether it
is required or optional is signaled by <i>presence</i>. (Presence
ordinarily defaults to IMPLIED, but if omitted and there is an
explicit default, <i>presence</i> is set to the SPECIFIED.)</p>

<p>Attributes with enumerated (and notation) values permit a
<em>values</em>
attribute, a space-separated list of legal values.. The <em>values</em>
attribute is required when the <em>type</em> is ENUMERATION or
NOTATION,<em> </em>else it is forbidden. In these cases, if a
default is specified it must be one of the specified values.</p>

<p>Similar to the facility of multiple ATTLISTs, we sometimes
need to have <em>attributesDcls</em> declared separately from the
elementType they refer to. We can do this with the <em>propertyOf</em>
element, discussed later.</p>

<h3><b>3.5 The internal and external entity declaration element
type: </b><b><i>intEntityDcl</i></b> and <b><i>extEntityDcl</i></b></h3>

<p><em>Key terms used here:</em> <strong>entity, internal entity,
external entity, notation.</strong></p>

<p>This and the next two declarations cover <em>entities</em> in
general. Entities are a powerful shorthand mechanism, similar to
macros in a programming language.</p>

<pre><code>&lt;intEntityDcl name=&quot;LTG&quot;&gt;
    &lt;entityDef&gt;Language Technology Group&lt;/entityDef&gt;
&lt;/intEntityDcl&gt;</code></pre>

<pre><code>&lt;extEntityDcl name=&quot;dilbert&quot;&gt;
    &lt;notation href=&quot;#gif&quot;/&gt;
    &lt;systemId
href=&quot;http://www.ltg.ed.ac.uk/~ht/dilb.gif&quot;/&gt;
&lt;/extEntityDcl&gt;</code></pre>

<p>Here as elsewhere, following XML, <em>systemId</em> must be a
URL, absolute or relative, and <em>publicId</em>, if present,
must be a Public Identifier as defined in ISO/IEC 9070:1991,
Information technology -- SGML support facilities -- Registration
procedures for public text owner identifiers.. If a <em>notation</em>
is given, it must be declared (see below) and the entity will be
treated as binary, i.e., not substituted directly in place of
references.</p>

<pre><code>&lt;notationDcl name=&quot;gif&quot;&gt;
    &lt;systemId href='http://who.knows.where/'/&gt;
&lt;/notationDcl&gt;</code></pre>

<h3><b>3.6. The external declarations element type:
</b><b><i>extDcls</i></b>
</h3>

<p><em>Key terms used here:</em> <strong>external entity with
declarations.</strong></p>

<p>Although we allow an external entity with declarations to be
included, we recommend a different declaration for schema
modularization. The <em>extDcls</em> declaration gives a clean
mechanism for importing (fragments of) other schemata. It
replaces the common SGML idiom of declaring an external parameter
entity and then immediately referring to it, and has the same
import, namely, that the text referred to by the combination of
<b>systemId</b>
and <b>publicId</b> is included in the schema in place of the
<b>extDcls</b>
element, and that replacement text is then subject to the same
validity constraints and interpretation as the rest of the
schema.</p>

<h3>3.7. Type Extension</h3>

<p><em>Key terms used here:</em> <strong>type (class), typeOf,
extension (inheritance, subclassing), implements, extends, typeOf
(genus).</strong></p>

<p>Schema of all types can benefit from a subtyping mechanism:
indicating that one class of object is a specialization of
another more general class. For example, cat and dog both have
the type <em>pet</em> as their more general category. To make
more effective use of such classes, we introduce one new schema
attribute, which can be used to declare explicitly that an
element type is a subclass of another: <em>extends</em>: </p>

<pre><code>&lt;xml:schema&gt;
  &lt;elementType id=&quot;animalFriends&quot; &gt;
    &lt;elt href=&quot;#pet&quot; occurs=&quot;PLUS&quot; /&gt;
  &lt;/elementType&gt;

  &lt;elementType id=&quot;pet&quot; &gt;
    &lt;any/&gt;
  &lt;/elementType&gt;

  &lt;elementType id=&quot;cat&quot; extends=&quot;#pet&quot;/&gt;

  &lt;elementType id=&quot;dog&quot;  extends=&quot;#pet&quot;/&gt;

&lt;/xml:schema&gt;</code></pre>

<p>This schema says that the <em>animalFriends</em> element class
can contain one or more elements from the <em>pet</em> class,
such as a <em>cat</em> or a <em>dog</em>. Also, that each cat and
dog instance is a pet (<font size="3">that is, any cat is
semantically a pet, and any valid cat is also a valid pet</font>).
So the following data is now valid under this schema: </p>

<pre><code>&lt;animalFriends&gt;
  &lt;cat/&gt;
  &lt;dog/&gt;
  &lt;cat/&gt;
&lt;/animalFriends&gt;</code></pre>

<h4>Type Extension</h4>

<p>It is frequently necessary to <em>add</em> new attributes to a
subclass. This requires no extra machinery, because XML already
permits multiple attribute list declarations, which cumulatively
add attributes to element types. So each subclass may easily add
any new attributes desired, as shown here: </p>

<pre><code>&lt;elementType id=&quot;dog&quot;
extends=&quot;#pet&quot;/&gt;
  &lt;attribute name=&quot;age&quot;/&gt;
&lt;/elementType&gt;</code></pre>

<p>If the super type has content model, (attributes, etc.) these
are inherited, that is, they are also declared implicitly for the
derived class. In the following example, we give an <em>owner</em>
attribute to <em>pet</em>. This are inherited, so both <em>cat</em>
and <em>dog</em> now also now have an <em>owner</em> attribute..</p>

<pre><code>&lt;xml:schema&gt;
  &lt;elementType id=&quot;animalFriends&quot; &gt;
    &lt;elt href=&quot;#pet&quot; occurs=&quot;PLUS&quot; /&gt;
  &lt;/elementType&gt;

  &lt;elementType id=&quot;pet&quot;&gt;
    &lt;any/&gt;
    &lt;attribute id='name'/&gt;
    &lt;attribute id='owner'/&gt;
  &lt;/elementType&gt;

  &lt;elementType id=&quot;cat&quot; extends=&quot;#pet&quot;/&gt;
    &lt;elt href='#kittens'/&gt;
    &lt;attribute id='lives' type='NMTOKEN'/&gt;
  &lt;/elementType&gt;

  &lt;elementType id=&quot;dog&quot; extends=&quot;#pet&quot;/&gt;
    &lt;elt href='#puppies'/&gt;
    &lt;attribute id='breed'/&gt;
  &lt;/elementType&gt;
&lt;xml:schema&gt;</code></pre>

<p>This schema says that the animalFriends element class can
contain one or more <em>pet</em> elements. Because <em>cat</em>
and <em>dog</em> are subtypes of <em>pet</em>, they can occur as
well. So the following instance fragment is now valid under this
schema: </p>

<pre><code>&lt;animalFriends&gt;
  &lt;cat name=&quot;Fluffy&quot; lives='9'/&gt;
  &lt;pet name=&quot;Diego&quot;/&gt;
  &lt;dog name=&quot;Gromit&quot; owner='Wallace' breed='mutt'/&gt;
&lt;/animalFriends&gt;</code></pre>

<p>Additional relations can also be added, but only be added if
the content model of the superType consists of a single list of
optional, repeatable element types.</p>

<p>When defining a derived element class, one can also override
existing attributes and relations. The following example adds a
<em>Height</em>
relation and overrides the <em>favoriteFood</em> relation, giving
it a default value of &quot;Fish.&quot; (We also do something
fancy here. Making this overridden element itself have its super
type favoriteFood ensures that the derived element is in all
other respects identical.) </p>

<pre><code>&lt;relationType id=&quot;height&quot;&gt;
  &lt;any/&gt;
&lt;/relationType&gt;

&lt;relationType id=&quot;#favoriteCatFood&quot;
extends=&quot;#favoriteFood&quot;/&gt;

&lt;elementType id=&quot;cat&quot; extends=&quot;#pet&quot;/&gt;
  &lt;relation href=&quot;#height&quot;/&gt;
  &lt;relation href=&quot;#favoriteCatFood&quot;
default=&quot;Fish&quot;/&gt;
&lt;/elementType&gt;</code></pre>

<h4>Schema Extension</h4>

<p>We can also use subtyping to extend an existing schema without
editing it. Suppose that we cannot edit the schema defining pet,
cat or dog, but want to use elements with those names and
semantics in our document. The following adds the
&quot;eyeColor&quot; property to <em>cat</em>.</p>

<pre><code>&lt;relationType id=&quot;eyeColor&quot;
extends=&quot;http://whereever.org/#eyeColor&quot;&gt;
    &lt;pcdata/&gt;
&lt;/relationType&gt;

&lt;elementType id=&quot;cat&quot;
extends=&quot;http://whereever.org/#cat&quot;/&gt;
  &lt;relation href=&quot;#eyeColor&quot;/&gt;
&lt;/elementType&gt;</code></pre>

<p>The rules for allowable subtyping must enforce certain
constraints, which are in principle that a subtype can have
additional relations and attributes (provided this is consistent
with the super type's content model, but never fewer) and can add
restrictions (but never relax them). In practice, this principle
leads to rules such as that default values can be added if there
are none, changed, or converted to FIXED if DEFAULT.</p>

<h4>Implements</h4>

<p>Subtyping as we have described it here is actually a
combination of two effects: First, we assert that an element of
one type is also of another (as in a cat is a pet).</p>

<p>Second, we achieve economies and maintainability in the
declarations to make sure that the first is true. That is, the
derived element class is automatically provided with all the
properties of the super type. Sometimes it is valuable to have
the first effect without the second. (This is equivalent to the
Java <em>implements</em> facility.) We indicate this by using the
<em>implements</em> element, as in </p>

<pre><code>&lt;relationType id=&quot;favoriteFood&quot; &gt;
  &lt;mixed/&gt;
&lt;/relationType&gt;

&lt;relationType id=&quot;weight&quot; &gt;
  &lt;mixed/&gt;
&lt;/relationType&gt;

&lt;elementType id=&quot;cat&quot; &gt;
  &lt;implements href=&quot;http://whereever.org/#pet&quot; /&gt;
  &lt;attribute name=&quot;name&quot;/&gt;
  &lt;relation href=&quot;#favoriteFood&quot; /&gt;
  &lt;relation href=&quot;#weight&quot; /&gt;
&lt;/elementType<em>&gt;</em></code></pre>

<p><font size="3">This has no effect on the attributes or
relations of instances of cat, but asserts in the schema that
every cat is also a pet (that is, any cat is semantically a pet,
and any valid cat is also a valid pet).</font></p>

<h4>Relation of Type Extension to Parameter Entities</h4>

<p>Sophisticated DTDs often make complex use of <em>parameter
entities</em> in an attempt to consolidate common structures in
one, reusable place. Such parameter entities often represent
implicit classes.</p>

<p>The need is real, but the approach often leads to obscurity,
and reduced maintainability. Further, expansion of entities loses
all connection with their source: once expanded, the fact that
some set of element types was a co-declared set, re-used in
multiple places, is lost. </p>

<h3>3.8 Lexical Data Types</h3>

<p>Information such as dates and numbers is often expressed in a
format that requires some further parsing. For example, the same
date can be written &quot;October 22, 1954&quot; or
&quot;19541022&quot;. (And from what I've seen, about 300 other
ways.) The <em>lextype</em> attribute discriminates formats.
Appearing on instance elements, it describes the format of the
remainder of the element. The value of the lextype attribute is
always by reference to a URI identifying the parsing rules.
XML-Data should define a small number of these. We propose
NUMBER, INTEGER, REAL and DATE.ISO8061.</p>

<pre><code>&lt;birthday
lextype=&quot;<strong>DATE.ISO8061</strong>&quot;&gt;<strong>19541022</s
trong>&lt;/birthday&gt;</code></pre>

<p><font size="4" face="Times New Roman"><code>These are declared
in the schema as follows:</code></font></p>

<pre><code>&lt;relationType id=&quot;<strong>birthday</strong>&quot;&gt;
  &lt;attribute name=&quot;<strong>lextype</strong>&quot;
default=&quot;<strong>DATE.ISO8061</strong>&quot;
presence=&quot;<strong>fixed</strong>&quot;/&gt;
&lt;/relationType&gt;</code></pre>

<p><font size="4" face="Times New Roman"><code>When giving the
lexical type of an <em>attribute</em>
in the schema, <em>lextypeIs</em> is
used, as in:</code></font></p>

<pre><code>&lt;attribute name=&quot;<strong>price</strong>&quot;
presence=&quot;<strong>REQUIRED</strong>&quot;
lextypeIs=&quot;<strong>number</strong>&quot;/&gt;</code></pre>

<p>Some patterns will indicate that several properties or
attributes should be used in combination to arrive at a value.
For example, a custom pattern could indicate a date expressed as
the following: </p>

<pre><code>&lt;relationType id=&quot;<strong>birthday</strong>&quot;&gt;
  &lt;attribute name=&quot;lextype&quot;
default=&quot;<strong>DATE.ATTR-YMD</strong>&quot;
presence=&quot;<strong>specified</strong>&quot;/&gt;
&lt;/relationType&gt;
...
&lt;birthday year=&quot;<strong>1954</strong>&quot;
month=&quot;<strong>10</strong>&quot;
day=&quot;<strong>22</strong>&quot; &gt;
</code></pre>

<h3>3.9. Basic Semantic Data Types</h3>

<p>We need to define here a small number of basic types and their
hierarchy, corresponding to simple data types such as Number and
Date. (Dates are a subtype of numbers.) </p>

<p>We also need to define the expression of each of the basic
Java and SQL data types in terms of these basic ones, plus
additional properties giving units, precision, min, max, default
pattern, and other properties. For example, an INTEGER typically
is a number a certain min and max property values. Note that
units should be an element type with possible structure, so that
things like &quot;miles/hours&quot; or &quot;feet/(sec*sec)&quot;
can be represented and used for automatic conversions.</p>

<h2 align="left">4. Standard Vocabulary</h2>

<p align="left">We expect standard libraries of vocabulary to be
developed to capture common semantic used in vertical
applications and particularly in industry and application
domains. Dublin Core and CDF are two examples of such standard
libraries.</p>

<h2 align="left">5. Relations to other proposed standards</h2>

<p align="left"><font size="3">The W3C site at</font><font
size="4"> </font><a href="http://www.w3.org/PICS/Member/NG/"><font
color="#0000FF"
size="3"><u>http://www.w3.org/PICS/Member/NG</u></font></a><font
color="#0000FF" size="3"><u> </u></font><font color="#000000"
size="3">contains links to several related papers, including Ora
Lassila's </font><a
href="http://www.w3.org/pub/WWW/Member/9705/WD-pics-ng-metadata-970514.h
tml"><font
color="#000000" size="3">PICS-NG document</font></a><font
color="#000000" size="3">, Renato Ianella's small PICS extension
proposal, CDF, MCF in XML, the </font><a
href="http://www.w3.org/pub/WWW/Member/9703/XMLsubmit.html"><font
color="#000000" size="3">Web Collections using XML</font></a><font
color="#000000" size="3"> proposal. Specific notes on some of
these follow:</font></p>

<h3>5.1 XML-LINK</h3>

<p>All relations use <em>href</em> in a manner consistent with <a
href="http://www.w3.org/pub/WWW/TR/WD-xml-link-970406.html">XML-LINK</a>
working draft dated April 6, 1997 (the most recent as of the time
of this writing). XML-Links are a type of <em>relation</em> (with
extra attributes, elements, and semantics indicating traversal).</p>

<h3>5.2 PICS-NG</h3>

<p><a
href="http://www.w3.org/pub/WWW/Member/9705/WD-pics-ng-metadata-970514.h
tml#intro">PICS-NG
Metadata Model and Label Syntax</a> describes a set of
requirements for structured data to be used on the Internet.
XML-Data is an application of XML concepts to those requirements.</p>

<h3>5.3 CDF</h3>

<p><font size="3">The </font><a
href="http://www.microsoft.com/standards/cdf-f.htm"><font
size="3">Channel Definition Format</font></a><font size="3">
(CDF) is a natural application of XML-Data and is fully
compatible with the syntax and the ideas presented in this
document</font>. Its format is a validatable grammar given a
proper schema. The existing use of href in CDF is consistent with
XML-LINK and XML-Data usage. CDF defines a number of basic
element types that would be appropriate for a standard library.</p>

<h3>5.4 MCF in XML</h3>

<p><a href="http://www.w3.org/Member/9706/xmlmcf.htm">MCF in XML</a>
has two principal components: The ability to represent a
&quot;directed labeled graph&quot; and also a set of predefined
element types. The first of these is effected by a convention on
use of the <em>href</em> attribute (the same convention used in
XML-Data <em>relations</em>, with the same effect). Of the
second, some element types are genuinely necessary to represent
schemata and a type system (these are also present in XML-Data)
while others would be appropriate for a standard library.</p>

<p>XML-Data has a number of features not in MCF: </p>

<ul>
    <li>Principally, XML-Data permits <strong>tree structures</strong>
        in cases when MCF only permits a graph. (MCF requires
        that the target of all relations must be out-of-line when
        it is an element. XML-Data allows in-line targets.) </li>
    <li>XML-Data hrefs are explicitly <strong>URI</strong>s.
        (Though MCF <em>unit</em>s can be URIs, it is not clear
        from the current document when they are and when they are
        not.)</li>
    <li>Finally, names in XML-Data were chosen for more
        compatibility with <strong>existing XML usage</strong>
        (or at least that is the intention).</li>
    <li>XML-Data schemata can represent all the information in an
        XML <strong>DTD</strong>, while it is not clear that MCF
        can do this. </li>
    <li>XML-Data has additional capabilities for expressing
<strong>relationships
        in the schema</strong> (relation, relationType, extends,
        implements). </li>
    <li>XML-Data proposes <em><strong>lextypes</strong></em> as a
        basic element type, a feature not discussed in MCF. </li>
</ul>

<p>This chart tabulates the MCF &quot;bootstrap&quot; element
types and describes their equivalence in XML-Data</p>

<dl>
    <dt>Category</dt>
    <dd>&quot;elementType&quot; in XML-Data.</dd>
    <dt>typeOf</dt>
    <dd>&quot;typeOf&quot; relation in XML-Data.
        Also,&quot;extends&quot; and &quot;implements&quot; in
        XML-Data assert the relationship in the schema. </dd>
    <dt>Unit</dt>
    <dd>&quot;href&quot; in XML-Data.</dd>
    <dt>domain</dt>
    <dd>&quot;propertyOf&quot; in XML-Data.</dd>
    <dt>range</dt>
    <dd>&quot;range&quot; in XML-Data. This gives the allowed
        type of the target of a property.</dd>
    <dt>superType</dt>
    <dd>This may correspond to &quot;implements&quot; XML Data.
        However the MCF document is not clear on this point.</dd>
    <dt>Property</dt>
    <dd>This corresponds to the abstract concept of a link class
        expressed in schemata by <em>relation</em> and
<em>relationType</em>..
    </dd>
    <dt>FunctionalProperty</dt>
    <dd>This appears to be a <em>relation</em> with <em>occurs</em>
        = OPTIONAL or REQUIRED (that is, occurs at most once).</dd>
    <dt>mutuallyDisjoint</dt>
    <dd>This is a relationship asserted among the members of an
        enumeration. XML-Data does not contain a predefined
        propertyType for this. It could be added easily if this
        is useful. </dd>
    <dt>parent</dt>
    <dd>A generic property, whose meaning appears to be
        contextual. XML-Data does not contain a predefined
        elementType for this. It is unneeded because parentage is
        expressed by containment, while when out-of-line,
        specific meanings are conveyed by more precise
        relationship types such as <em>propertyOf</em>.</dd>
    <dt>name</dt>
    <dd>&quot;name&quot; in XML-Data. However, note that like
        parent, the interpretation of name in MCF seems to be
        contextual.</dd>
    <dt>description</dt>
    <dd>XML-Data does not contain a predefined elementType for
        this. We think that this belongs to a standard library
        and not in this specification.</dd>
    <dt>Sequence</dt>
    <dd>This is a special arc type in MCF that expresses the same
        fact as lexical order in XML.</dd>
    <dt>ord</dt>
    <dd>This is a MCF helper element type for Sequence.</dd>
</dl>

<p><a name="XML-Data-vs-MCF">Comparative examples of XML-Data and
MCF in XML</a> representation of an order for several books. (All
persons in this example are assumed to be not in the document,
but elsewhere.) The <em>id</em> attribute is on all elements
representing real-world objects, in both models. In the MCF model
<em>id</em> also appears on elements needed artificially for
reference. </p>

<table border="0">
    <tr>
        <td><font size="4">MCF in XML</font></td>
        <td><font size="4">XML-Data</font></td>
    </tr>
    <tr>
        <td valign="top"><pre><code>
&lt;ORDER id=&quot;order1&quot;&gt;
  &lt;SOLD-TO
unit=&quot;<strong>http:/people#person1</strong>&quot;/&gt;
  &lt;SOLD-ON value=&quot;<strong>19970317</strong>&quot;/&gt;
  &lt;ITEMS unit=&quot;<strong>sequence1</strong>&quot;/&gt;
&lt;/ORDER&gt;

&lt;BOOK id=&quot;book1&quot;&gt;
  &lt;TITLE value=&quot;<strong>Number, the Language of
Science</strong>&quot;/&gt;
  &lt;AUTHOR unit=&quot;<strong>http:/people#person2</strong>&quot;/&gt;
&lt;/BOOK&gt;

&lt;SEQUENCE id=&quot;sequence1&quot;&gt;
  &lt;ORD UNIT=&quot;book1&quot;&gt;
    &lt;PRICE value=<strong>&quot;5.95&quot;</strong>/&gt;
  &lt;/ORD&gt;
  &lt;ORD UNIT=&quot;cd1&quot;&gt;
    &lt;PRICE value=<strong>&quot;12.95&quot;</strong>/&gt;
  &lt;/ORD&gt;
  &lt;ORD UNIT=&quot;book2&quot;&gt;
    &lt;PRICE value=<strong>&quot;6.95&quot;</strong>/&gt;
  &lt;/ORD&gt;
  &lt;ORD UNIT=&quot;food1&quot;&gt;
    &lt;PRICE value=<strong>&quot;1.50&quot;</strong>/&gt;
  &lt;/ORD&gt;
&lt;/SEQUENCE&gt;

&lt;COFFEE id=&quot;food1&quot;&gt;
  &lt;size value=&quot;<strong>small</strong>&quot;/&gt;
  &lt;style value=&quot;<strong>cafe macchiato</strong>&quot;/&gt;
&lt;/RECORD&gt;

&lt;RECORD id=&quot;cd1&quot;&gt;
  &lt;TITLE value=&quot;<strong>Rachmaninoff's Second Piano
Concerto</strong>&quot;/&gt;
  &lt;ARTIST unit=&quot;<strong>http:/people#person3</strong>&quot;/&gt;
&lt;/RECORD&gt;

&lt;BOOK id=&quot;book2&quot;&gt;
  &lt;TITLE value=&quot;<strong>The Evolution of
Complexity</strong>&quot;/&gt;
  &lt;AUTHOR unit=&quot;<strong>http:/people#person4</strong>&quot;/&gt;
&lt;/BOOK&gt;</code></pre>
        </td>
        <td valign="top"><pre>
<code>&lt;ORDER id=&quot;order1&quot;&gt;
  &lt;SOLD-TO
href=&quot;<strong>http:/people#person1</strong>&quot;/&gt;
  &lt;SOLD-ON value=&quot;<strong>9970317&quot;</strong>/&gt;
  &lt;ITEM&gt;
    &lt;PRICE&gt;<strong>5.95</strong>&lt;/PRICE&gt;
    &lt;BOOK id=&quot;book1&quot;&gt;
      &lt;TITLE &gt;<strong>Number, the Language of
Science</strong>&lt;/TITLE&gt;
      &lt;AUTHOR
href=&quot;<strong>http:/people#person2</strong>&quot;/&gt;
    &lt;/BOOK&gt;
  &lt;/ITEM&gt;
  &lt;ITEM&gt;
    &lt;PRICE&gt;<strong>12.95</strong>&lt;/PRICE&gt;
    &lt;RECORD id=&quot;cd1&quot;&gt;
    &lt;TITLE &gt;<strong>Rachmaninoff's Second Piano
Concerto</strong>&lt;/TITLE&gt;
      &lt;ARTIST
href=&quot;<strong>http:/people#person3</strong>&quot;/&gt;
    &lt;/RECORD&gt;
  &lt;/ITEM&gt;
  &lt;ITEM&gt;
    &lt;PRICE&gt;<strong>6.95</strong>&lt;/PRICE&gt;
    &lt;BOOK id=&quot;book2&quot;&gt;
      &lt;TITLE &gt;<strong>The Evolution of
Complexity</strong>&lt;/TITLE&gt;
      &lt;AUTHOR
unit=&quot;<strong>http:/people#person4</strong>&quot;/&gt;
    &lt;/BOOK&gt;  
  &lt;/ITEM&gt;
  &lt;ITEM&gt;
    &lt;PRICE&gt;<strong>1.50</strong>&lt;/PRICE&gt;
    &lt;COFFEE&gt;
      &lt;SIZE&gt;<strong>small</strong>&lt;/SIZE&gt;
      &lt;STYLE&gt;<strong>cafe macchiato</strong>&lt;/STYLE&gt;
    &lt;/COFFEE&gt;
  &lt;/ITEM&gt;
&lt;/ORDER&gt;</code></pre>
        </td>
    </tr>
</table>

<p>&nbsp;</p>

<h2 align="left">6. Conclusion</h2>

<p><font color="#000000" size="3">Future applications of the
Internet will focus on adding user value to information through
semantic annotation. Semantics will permit information to be
discovered, targeted, reused, and integrated. Not only does this
make the content more usable, but it opens up opportunities for
software developers to build components that exploit these
semantics. Such components could include applications as prosaic
as application or user logging, or as futuristic as user agents
that assist in finding or organizing contents, World-Wide Web
&quot;surf buddies&quot; that accompany a user's browsing and
adding valuable or entertaining comments, or natural language
query systems. Semantic annotation turns the Internet into a
platform for programming powerful and valuable applications.</font></p>

<p><font color="#000000" size="3">This proposal lays the
foundation for how applications can annotate their information
content. The proposal adds powerful new constructs for
representing semantics, sufficiently advanced for use in
artificial intelligence and natural language systems, yet retains
the architecture and investment of existing XML and the
efficiency of its representation.</font></p>

<hr>

<h2 align="left">Appendix A - The XML DTD for a schema</h2>

<pre><code>
&lt;!ENTITY % nodeattrs 'id ID #IMPLIED'  &gt;
&lt;!-- href is as per XML-LINK, but is not required unless there is
      no content --&gt;

&lt;!ENTITY % exattrs   'extends CDATA #IMPLIED'  &gt;

&lt;!ENTITY % linkattrs 'id ID #IMPLIED
                      href CDATA #IMPLIED' &gt;

&lt;!-- The shared content model of elementType, linkType and
relationType --&gt;
&lt;!-- Omitted element type same as &quot;empty.&quot; --&gt;
&lt;!ENTITY % extendedmodel 'implements*,
                          (elt|group|empty|any|pcdata|mixed)?,
                          (relation|attribute)*'&gt;

&lt;!-- The top-level container --&gt;
&lt;!element schema         ((elementType|propertyOf|linkType|
                          relationType|extendType|augmentElementType|
                          intEntityDcl|extEntityDcl|
                          notationDcl|extDcls|c)*)&gt;
&lt;!attlist schema %nodeattrs;&gt;

&lt;!-- Element Type Declarations --&gt;
&lt;!element elementType   (%extendedmodel)&gt;
&lt;!-- Either name or id must be present - - absent name defaults to id
--&gt;
&lt;!attlist elementType %nodeattrs;
                      %exattrs;
                name    CDATA      #IMPLIED&gt;

&lt;!-- Element types allowed in content model --&gt;
&lt;!-- Note this is just short for a model group with only one elt in
it --&gt;
&lt;!element elt           EMPTY&gt;
&lt;!-- Elements can have exponents as well as groups --&gt;
&lt;!-- The href is required --&gt;
&lt;!attlist elt   %linkattrs;
                occurs     (required|optional|star|plus) 'required'&gt;

&lt;!-- A group in a content model, sequential or disjunctive --&gt;
&lt;!element group         ((group|elt)+)&gt;
&lt;!attlist group         %nodeattrs;
                groupType (seq|or) 'seq'
                occurs  (required|optional|plus) 'required'&gt;

&lt;!element any           EMPTY&gt;
&lt;!element empty         EMPTY&gt;
&lt;!element pcdataEMPTY&gt;

&lt;!-- mixed content is just a flat, non-empty list of elts --&gt;
&lt;!-- We don't need to say anything about #pcdata, it's implied --&gt;
&lt;!element mixed         (elt+)&gt;
&lt;!attlist mixed         %nodeattrs;&gt; 

&lt;!-- Attributes --&gt;
&lt;!-- default value must be present iff presence is specified or fixed
--&gt;
&lt;!-- presence defaults to specified if default is present, else
implied --&gt;
&lt;!-- name attribute is locally unique, defaults to id if absent
--&gt;
&lt;!element attribute  empty&gt;
&lt;!attlist attribute  %linkattrs;
                name    CDATA #IMPLIED
                type
(id|idref|idrefs|entity|entities|nmtoken|nmtokens|
                         enumeration|notation|cdata) 'cdata'
                default CDATA #IMPLIED
                values NMTOKENS #IMPLIED
                presence (implied|specified|required|fixed) #IMPLIED 
                lextypeIs CDATA #IMPLIED&gt;

&lt;!-- Relations - - relationTypes are pointed to from relations,
            just as elementTypes are pointed to from elts --&gt;
&lt;!element relationType  (%extendedmodel;,
                         range*)&gt;
&lt;!attlist relationType  %nodeattrs;
                        %exattrs;
                        name CDATA #IMPLIED &gt;

&lt;!element range empty &gt;
&lt;!attlist range %linkattrs; &gt;

&lt;!element relation  EMPTY&gt;
&lt;!attlist relation  %linkattrs;
                    default CDATA #IMPLIED
                    occurs (required|optional|star|plus) 'optional'&gt;

&lt;!-- For adding attributes to existing element types --&gt;
&lt;!element propertyOf    EMPTY&gt;
&lt;!attlist propertyOf    href CDATA #REQUIRED&gt;

</code><font color="#000000" size="3">&lt;!element augmentElementType
((relation|attribute)*)&gt;
&lt;!attlist augmentElementType %linkattrs;
                             %</font><code>exattrs</code><font
color="#000000" size="3">;&gt;</font><code>

&lt;!-- Shorthand for simple XML-LINKs --&gt;
&lt;!element linkType (%extendedmodel;)&gt;
&lt;!attlist linkType %nodeattrs;
                   %exattrs;
                   name CDATA #IMPLIED
                   role CDATA #IMPLIED
                   title CDATA #IMPLIED
                   show (embed|replace|new) #IMPLIED
                   actuate (auto|user) #IMPLIED
                   behaviour CDATA #IMPLIED &gt;
</code><font size="4"><code>
</code></font><code>&lt;!element implements EMPTY&gt;
&lt;!attlist implements href CDATA #REQUIRED&gt;

&lt;!-- Entity Declarations --&gt;
&lt;!-- Note as this is written only external entities
      can have structure without escaping it --&gt;
&lt;!-- Name defaults to id if absent --&gt;
&lt;!element intEntityDcl     (#PCDATA)&gt;
&lt;!attlist intEntityDcl %nodeattrs;
                name    CDATA #IMPLIED&gt;

&lt;!-- The entity will be treated as binary if a notation is present
--&gt;
&lt;!-- systemID and publicId (if present) must have the required syntax
--&gt;
&lt;!element extEntityDcl    ( systemId, publicId?)&gt;
&lt;!attlist extEntityDcl %nodeattrs;
                name    CDATA #IMPLIED
notation CDATA #IMPLIED&gt;

&lt;!-- Pointers for above --&gt;
&lt;!element systemID      EMPTY&gt;
&lt;!attlist systemID      %linkattrs;&gt;
&lt;!-- Must be empty if href is used --&gt;
&lt;!element publicID      (#PCDATA) &gt;
&lt;!attlist publicID      %linkattrs;&gt;

&lt;!-- Notation Declarations --&gt;
&lt;!-- systemID and publicId (if present) must have the required syntax
--&gt;
&lt;!element notationDcl        (systemId, publicId?)&gt;
&lt;!attlist notationDcl   %linkattrs;
                name    CDATA #IMPLIED&gt;

&lt;!-- External entity with declarations to be included --&gt;
&lt;!-- systemID and publicId (if present) must have the required syntax
--&gt;
&lt;!element extDcls       empty&gt;
&lt;!attlist extDcls
                systemId CDATA #REQUIRED
                publicId CDATA #IMPLIED&gt;

&lt;!-- Namespace Declarations --&gt;
&lt;!-- systemID and publicId (if present) must have the required syntax
--&gt;
&lt;!element namespaceDcl  EMPTY&gt;
&lt;!attlist namespaceDcl  %linkattrs;
                name    CDATA #IMPLIED&gt;

</code></pre>
</body>
</html>



