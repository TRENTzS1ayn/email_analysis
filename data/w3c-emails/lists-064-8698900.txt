docno="lists-064-8698900"
received="Wed Feb 14 21:38:22 2001"
isoreceived="20010215023822"
sent="Thu, 15 Feb 2001 02:39:26 -0000"
isosent="20010215023926"
name="Sean B. Palmer"
email="sean@mysterylights.com"
subject="Re: EARL: Simple Sample"
id="01b301c096f8$9ddaec80$bf6c073e@z5n9x1"
charset="iso-8859-1"
inreplyto="200102150208.VAA1056228&#64;smtp1.mail.iamworld.net"
expires="-1"


To:"Wendy A Chisholm"<wendy@w3.org>,<w3c-wai-er-ig@w3.org>,"Al Gilman"<asgilman@iamdigex.net>

> The trick is in understanding the culture involved in drawing out
> literate graphs made up of well-modulated primitives that, like
> the Dublin Core, encourage reuse.

We already have a nice set of well-modulated primitives through EDL and
EARL evolution. In this way, the vocabulary is evolving similar to that of
DC, but I envisage that the syntax won't do. Dublin Core syntax doesn't
exist: it's just a base element set with no structural definition. EARL on
the other hand is not just a core vocabulary, but a means of processing
that on non-RDF parsers as well. The EARL framework is a subset of RDF, not
an RDF langauge. We already have syntax rules: e.g. "the subject of a
triple where the predicate is earl:asserts is always an earl:Validator".
Why have these rules? Because RDF is so unconstraining. There are hundreds
of ways to make the same assertion, but with a few simple EARL rules
involving a use of the core vocabulary, we can come up with simple,
effective, modularized systems that can be groked, and yet extended at
will. In other words, any langauge that is a subset of RDF can use RDF
parsers, even if it does not allow certain features of RDF. If you allow in
*new* features, then you lose that, and that is what we must avoid.

--
Kindest Regards,
Sean B. Palmer
@prefix : <http://webns.net/roughterms/> .
[ :name "Sean B. Palmer" ] :hasHomepage <http://infomesh.net/sbp/> .



