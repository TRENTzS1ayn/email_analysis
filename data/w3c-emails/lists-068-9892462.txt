docno="lists-068-9892462"
received="Mon May 28 07:26:58 2001"
isoreceived="20010528112658"
sent="Mon, 28 May 2001 12:25:23 +0100"
isosent="20010528112523"
name="Sean B. Palmer"
email="sean@mysterylights.com"
subject="Merging WCAG With EARL"
id="005e01c0e768$e9a518a0$f2da93c3@z5n9x1"
charset="iso-8859-1"
expires="-1"


To:<w3c-wai-er-ig@w3.org>
Cc:<w3c-wai-gl@w3.org>

I've taken a sample EARL file that says "this page complies to all
WCAG priority 1 checkpoints", and merged it with a machine-readable
version of WCAG (which I had to create), to produce an explicity
enumerated output with checkpoint Ids.

What this means is that if you have a bit of EARL that says "my page
complies to all priority 1 checkpoints", you can combine that with the
machine readable version of WCAG, find out what all of the priority 1
checkpoints are, and then put them in the EARL explicitly.

How to do it: firstly, get the EARL WCAG example file [1]. This file
has the following bit of EARL code in it:-

:WCAG10P1
   earl:testCriteria
     [ earl:suite <http://www.w3.org/TR/WCAG10/>;
       earl:level <http://www.w3.org/TR/WCAG10/#wc-priority-1>;
       earl:note """All Priority 1 checkpoints conformed to means that
                    a document is WCAG Level Single-A compliant""" ] .

Which basically says that (a particular page) passes all WCAG priority
1 checkpoints. However, it does not state what these checkpoints are,
i.e. what URIs they have, explicitly.

To get that information, you need to get the machine readable version
of WCAG [2] which I painstakingly scraped from the WCAG
Recommendation. I didn't bother to put all the prose in (someone else
can do that if they're really bored), but it's enough to say "this URI
is a checkpoint, has this Id, and this priority".

Then, you'll need the filter file [3] which takes the EARL input,
merges it with the WCAG machine readable thing, and comes to its
conclusions.

As with all N3 processing things of this nature, you'll need to have
installed Python [4], and have the latest versions of CWM [5],
notation3.py [6], and xml2rdf.py [7]. I used CWM 1.48 and notation3.py
1.78, both available from the SWAP CVS repository [8].

Once you have all of this in a folder, you can run the following
command lines (in a batch file):-

   python cwm.py 0.95-ex-WCAG.n3 wcag.n3 -think
     -filter=wcagf.n3 > 0.95-ex-WCAG-ids.n3
   python cwm.py 0.95-ex-WCAG.n3 0.95-ex-WCAG-ids.n3
     > 0.95-ex-WCAG-out.n3

The first line takes the EARL WCAG conformance example, merges it with
the machine readable version of WCAG, and filters out a list of IDs
[9], depending on which priority level it conforms to. The second line
simply takes these results, and merges it back in with the original
conformance example in EARL, to give 0.95-ex-WCAG-out.n3 as the
output. This file is available from [10].

Note how the original earl:level thing is still in there - you could
filter that out on the second command line using another filter if you
really wanted to.

This working demonstration shows how easy it is to process data once
it is in a machine readable (read: RDF) format, and how by basing EARL
(and indeed, WCAG!) on this model, we can make deductions and merge
information with great ease.

[1] http://www.w3.org/2001/03/earl/0.95-ex-WCAG.n3
[2] http://www.w3.org/2001/03/earl/wcag.n3
[3] http://www.w3.org/2001/03/earl/wcagf.n3
[4] http://www.python.org/
[5] http://www.w3.org/2000/10/swap/cwm.py
[6] http://www.w3.org/2000/10/swap/notation3.py
[7] http://www.w3.org/2000/10/swap/xml2rdf.py
[8] http://dev.w3.org/cvsweb/2000/10/swap/
[9] http://www.w3.org/2001/03/earl/0.95-ex-WCAG-ids.n3
[10] http://www.w3.org/2001/03/earl/0.95-ex-WCAG-out.n3

--
Kindest Regards,
Sean B. Palmer
@prefix : <http://webns.net/roughterms/> .
:Sean :hasHomepage <http://purl.org/net/sbp/> .



