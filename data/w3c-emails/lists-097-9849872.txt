docno="lists-097-9849872"
received="Mon Dec 10 11:24:26 2001"
isoreceived="20011210162426"
sent="Mon, 10 Dec 2001 11:24:18 -0500"
isosent="20011210162418"
name="Jeff Heflin"
email="heflin@cse.lehigh.edu"
subject="Re: WebOnt General Requirements Subgroup - Initial E-mail"
id="3C14E1B2.939FAD30@cse.lehigh.edu"
charset="us-ascii"
inreplyto="3C13A793.80116C87&#64;ksl.stanford.edu"
expires="-1"


To: Deborah McGuinness<dlm@ksl.stanford.edu>
CC:ned.smith@intel.com,jeremy_carroll@hp.com,phayes@ai.uwf.edu,connolly@w3.org,jos.deroo.jd@belgium.agfa.com,herman.ter.horst@philips.com,hendler@cs.umd.edu,www-archive@w3.org

I agree our mission is a little less clear than that of the other three
subgroups, and I sometimes find myself wavering between whether we
should develop general use cases or core requirements. Although I have a
hard time viewing some of the items on the original list as language
requirements (e.g., ontology querying and ontology-based search), I
think others can be cast that way. For example, I'd say that because the
Semantic Web is ever-changing, ontologies will need to be changed over
time. As a result, the language will have to support features for
identifying the version of an ontology, and identifying which version of
an ontology is committed to by web resources. Thus, to me versioning is
a language requirement that arises from the use case of ontology
changes. Whether we should define use cases on the way to defining
requirements or jump straight to requirements is unclear. However, I am
slowly leaning towards defining use cases that don't necessarly fit in
one of the other use cases areas, but instead describe supporting or
common tasks. If that is the route we choose to go, I think we can still
"reverse-engineer" use cases from the list of requirements we are
currently developing.

Jeff

Deborah McGuinness wrote:
> 
> ps. sorry for multiple messages - i think what becomes a little tricky is the notion that we are
> talking about language requirements.
> i dont know that any of the topics on the original list:
>  versioning
> - ontology-based search
> - domain-mapping/ ontology linking
> - ontology querying
> - rapid creation of large ontologies
> - inconsistency/contradiction (added as a result of mailing list
> discussion)
> 
> are truly language requiements but they are what naturally develops as needs once one tries to use
> the language.
> note also that the "original list" of mapping and linking i would claim goes in the same point as
> my difference and merging (along with keeping track of mapping information)
> 
> d
>



