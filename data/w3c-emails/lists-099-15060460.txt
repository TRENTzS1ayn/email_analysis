docno="lists-099-15060460"
received="Mon Mar 15 16:38:33 2004"
isoreceived="20040315213833"
sent="Mon, 15 Mar 2004 22:36:56 +0100"
isosent="20040315213656"
name="Jeremy Carroll"
email="jjc@hplb.hpl.hp.com"
subject="RE: Graphs: intension and extension"
id="200403152236.56949.jjc@hplb.hpl.hp.com"
charset="us-ascii"
inreplyto="Graphs: intension and extension"
expires="-1"

To:www-archive@w3.org,phayes@ihmc.us
Cc:patrick.stickler@nokia.com,chris@bizer.de



N3 is very poorly documented, however it does have some mindshare. Given that 
this paper is likely to be an aggressively anti-N3 paper ever (it needs to 
describe log:implies as incoherent or worse), we would be well-advised to 
take some good features out of N3 where relevant ...


> Look, its *logically valid* to substitute any bnode label for any 
> other, as long as you do it systematically throughout the graph. So 
> any use of a bnode to be a label is *logically invalid*.  No matter 
> how lexically convenient it might be, that's a bad place to start.

SECOND VERSION OF RESPONSE

We could modify the abstract syntax to permit a graph to be a node in another 
graph - this would permit the nested graph within a formula that does seem 
genuinely useful. This feels like hard work too ...


FIRST VERSION OF RESPONSE:

I find this uncompelling ...
You invented reading a blank node as an existential and hence determined what 
was and was not logically valid for blank nodes.
The point being that we can make changes, but given the success of reading 
blank nodes as existentials these changes should be limited.

At the moment we are heading towards rdfg:Graph's being intensional resources, 
somehow associated with the graphs that they name. (This might or might not 
be a good way to go).
Pursuing this, we could augment classic RDF Semantics with a partial mapping 
G: IR -> the set of RDF Graphs (syntactic)
we never get to apply I to G(r) for any r in IR, that is we cannot reapply the 
semantic theory to the syntactic objects that we have just embedded within 
it.

We can then modify the semantics along the following lines:

Given a set of named graphs N, and a set A of names that we are accepting 
(i.e. the agent reading N gets to choose which of the graphs are believed, so 
the interpetation of N is not a map to {t,f} but 2^|N| such maps, depending 
on which names are in A)

Then, an interpretation of N following A is ... maybe you're right, I don't 
think this is going to work ...

I'll sleep on it

TEST CASE

Here's a simple test case:

_:a ( eg:a eg:b eg:c )
_:b ( eg:a eg:b eg:c .
       eg:d eg:e eg:f )
_:c ( _:a rdfg:subGraphOf _:b )

Graph _:c seems to be to me necessarily true with these named graphs. I find 
it very difficult to see *real* problems, rather than merely artefacts of a 
particular style of giving these things meaning.

If we force _:a and _:b to be given names we might get

#g1 ( eg:a eg:b eg:c )
#g2 ( eg:a eg:b eg:c .
       eg:d eg:e eg:f )
#g3 ( #g1 rdfg:subGraphOf #g2 )


or


#g2 ( eg:a eg:b eg:c )
#g1 ( eg:a eg:b eg:c .
       eg:d eg:e eg:f )
#g3 ( #g2 rdfg:subGraphOf #g1 )

which are different since the two #g3's are not isomorphic. However this 
difference is a totally specious artefact of the skolemization.
I think that permitting blank nodes as graph names avoids this and is 
desirable.

Jeremy



