docno="lists-099-15095355"
received="Mon Mar 15 20:02:21 2004"
isoreceived="20040316010221"
sent="Mon, 15 Mar 2004 19:02:17 -0600"
isosent="20040316010217"
name="Pat Hayes"
email="phayes@ihmc.us"
subject="RE: Graphs: intension and extension"
id="p06001f02bc7bf5c6e34f@[10.0.100.76]"
charset="us-ascii"
inreplyto="200403152236.56949.jjc&#64;hplb.hpl.hp.com"
expires="-1"


To: Jeremy Carroll<jjc@hplb.hpl.hp.com>
Cc:www-archive@w3.org


>N3 is very poorly documented, however it does have some mindshare.

I wish I could get some of it into my mind.
I mean, you are here talking about some pretty detailed aspects of 
its design. Where did YOU find out about N3 at this level of detail? 
All I can get hold of is some early noodlings by Tim BL

>Given that
>this paper is likely to be an aggressively anti-N3 paper ever (it needs to
>describe log:implies as incoherent or worse),

Do we need to get into that issue?

>  we would be well-advised to
>take some good features out of N3 where relevant ...

There seems to me to be several agendas getting mixed up here. One is 
the idea of naming graphs. The next one is having graph names be a 
basis for provenance and trust and all that stuff. Another is using 
naming to do some of the N3-style encoding of logic into RDF triple 
stores. I don't think these go in the same direction, and we should 
try to keep them separate. I'd rather just ignore N3, myself: the 
provenance stuff seems more important (and more likely to survive RDF 
:-)

>  > Look, its *logically valid* to substitute any bnode label for any
>>  other, as long as you do it systematically throughout the graph. So
>>  any use of a bnode to be a label is *logically invalid*.  No matter
>>  how lexically convenient it might be, that's a bad place to start.
>
>SECOND VERSION OF RESPONSE
>
>We could modify the abstract syntax to permit a graph to be a node in another
>graph

Ah, now that is an idea. That is a big change to RDF syntax, though 
(more than just naming).

>- this would permit the nested graph within a formula that does seem
>genuinely useful. This feels like hard work too ...

Indeed.

>FIRST VERSION OF RESPONSE:
>
>I find this uncompelling ...
>You invented reading a blank node as an existential

I didn't INVENT it, all I did was make it formal. The reading was 
already there in the original. The WG told me about it and asked me 
to make a MT. But in any case, the history is irrelevant now: the 
existential interpretation is welded firmly into RDF and OWL, and its 
too late to change it, seems to me.

>and hence determined what
>was and was not logically valid for blank nodes.
>The point being that we can make changes, but given the success of reading
>blank nodes as existentials these changes should be limited.
>
>At the moment we are heading towards rdfg:Graph's being intensional resources,
>somehow associated with the graphs that they name. (This might or might not
>be a good way to go).

The chief utility of an intensional view is that there can be more 
than one intensional thing with the same extension (like classes 
versus sets). In the graph case, what counts as the extension?

>Pursuing this, we could augment classic RDF Semantics with a partial mapping
>G: IR -> the set of RDF Graphs (syntactic)
>we never get to apply I to G(r) for any r in IR, that is we cannot reapply the
>semantic theory to the syntactic objects that we have just embedded within
>it.

Hmmm... but why not? That seems potentially useful; that's how we did 
the RDF reification semantics (non-normatively, but it still worked 
OK.).

>We can then modify the semantics along the following lines:
>
>Given a set of named graphs N, and a set A of names that we are accepting
>(i.e. the agent reading N gets to choose which of the graphs are believed, so
>the interpetation of N is not a map to {t,f} but 2^|N| such maps, depending
>on which names are in A)
>
>Then, an interpretation of N following A is ... maybe you're right, I don't
>think this is going to work ...

Here's how it would go (I think). Like the datastructure map thing. A 
named-graph interpretation I is relative to a set of named graphs (ie 
a function GN from names to graphs) and an agent, and it has to 
satisfy

I(n) = GN(n) for n in the set of graph-reference names; and
for all n such that <I(n), agent> in IEXT(I(rdfg:assertedBy)), 
I(GN(n)) = true .

So you are required to get the graph names right even if you don't 
assert anything, and you are required to, well, assert anything that 
you say you assert.

This needs some work to say exactly what 'agent' is.  Im not sure how 
to do that, to be honest.

Nothing here about bnodes, though.

>I'll sleep on it
>
>TEST CASE
>
>Here's a simple test case:
>
>_:a ( eg:a eg:b eg:c )
>_:b ( eg:a eg:b eg:c .
>        eg:d eg:e eg:f )
>_:c ( _:a rdfg:subGraphOf _:b )
>
>Graph _:c seems to be to me necessarily true with these named graphs. I find
>it very difficult to see *real* problems, rather than merely artefacts of a
>particular style of giving these things meaning.

Well, the issue seems to me to be that the truth conditions for graph 
c say that it is true if for SOME mapping A on the blank nodes, I+A 
satisfies it.  So it comes out true, but so does
_:d( _:b rdfg:subGraphOf _:a)
in fact so does
_:x(_:y rdfg:subGraphOf _:z)
and for the same reason.

>
>If we force _:a and _:b to be given names we might get
>
>#g1 ( eg:a eg:b eg:c )
>#g2 ( eg:a eg:b eg:c .
>        eg:d eg:e eg:f )
>#g3 ( #g1 rdfg:subGraphOf #g2 )
>
>
>or
>
>
>#g2 ( eg:a eg:b eg:c )
>#g1 ( eg:a eg:b eg:c .
>        eg:d eg:e eg:f )
>#g3 ( #g2 rdfg:subGraphOf #g1 )
>
>which are different since the two #g3's are not isomorphic. However this
>difference is a totally specious artefact of the skolemization.

No, its an artifact of the *naming*, if you like, but then names are 
like that. You can't expect to permute names and preserve meaning. 
Putting the names in isn't skolemizing if it is done outside the 
scope of the name; and if those 'outer' bnodes are the same as the 
'inner' ones then there has to be some kind of larger-than-graph 
convention at work for blank nodes.  But then the bnodes in a graph 
don't have the same meaning as they do at present; and the bnodes 
outside the graph act just like URIs in any case.  For example, you 
want those to not be isomorphic because some other graph somewhere 
else might use the URI, right? OK, but if bnodes have global scope, 
some other graph somewhere else might use the bnode. Its the global 
scope that kills you, not the URI syntax.

>I think that permitting blank nodes as graph names avoids this and is
>desirable.

If the bnode scope is the entire web, then you don't gain anything by 
using them as names. If its not, what is it?

Pat

>Jeremy


-- 
---------------------------------------------------------------------
IHMC(850)434 8903 or (650)494 3973   home
40 South Alcaniz St.(850)202 4416   office
Pensacola(850)202 4440   fax
FL 32501(850)291 0667    cell
phayes@ihmc.us       http://www.ihmc.us/users/phayes



