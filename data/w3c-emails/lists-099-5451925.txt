docno="lists-099-5451925"
received="Thu Jun 26 13:12:57 2003"
isoreceived="20030626171257"
sent="Thu, 26 Jun 2003 18:12:12 +0100"
isosent="20030626171212"
name="Dave Reynolds"
email="der@hplb.hpl.hp.com"
subject="Re: RDF graph query, graph equivalence and inference"
id="3EFB296C.1255823F@hplb.hpl.hp.com"
charset="us-ascii"
inreplyto="5.1.0.14.2.20030626111221.00bb0fb8&#64;127.0.0.1"
expires="-1"


To: Graham Klyne<gk@ninebynine.org>
CC: Jeremy Carroll<jjc@hpl.hp.com>, www-archive<www-archive@w3.org>, Brian McBride<bwm@hplb.hpl.hp.com>


Graham Klyne wrote:
> 
> I'm up to my elbows in implementing inference primitives on RDF 
> graphs.  What I'm aiming for is a modular set of tools that I can use to 
> construct inference patterns, using Haskell as a kind of 'glue' or 
> scripting language.  I'm trying to reach the parts that CWM can't reach, 
> and aim to use this to create domain-specific inference tools (e.g. for 
> continuing my network configuration work).  Datatype reasoning is one of my 
> targets (e.g. having a specific datatype for IP network addresses).

That sounds good. We haven't done much with datatype reasoning yet.

> My current strategy is to introduce a variant of my graph forward-chaining
> query function that matches a query graph with bnodes against a target
> graph, and use that to match the outputs from backward chaining against
> input data.  

That sounds reasonable. We do it slightly differently but only slightly.

In Jena people often think of bNodes as concrete java objects they can do things
with - they are "in" the graph and they can go back to the same graph twice and
see the same bNodes. This makes it hard to implement, say, the RDFS closure
rules in a way which users won't throw up at.

At the moment we solve this by keeping the bNodes-as-variables outside the
graph, graph access and graph inference machinery. The variables in our rules
are a different node type disjoint from both Resources and bNodes. For running
the working group tests we translate the query graph into a Jena query with each
bNode replaced by a query variable and the run the query machinery on the
inference graph.

This will only work for small query graphs because the query machinery does not
have any sophisticated subgraph isomorphism algorithms at present.

Both the forward and backward rule systems work on the raw Jena graphs, to them
a bNode is much like any other node and distinct from a rule variable.

Dave



