docno="lists-099-7931772"
received="Thu Oct 30 18:12:53 2003"
isoreceived="20031030231253"
sent="Fri, 31 Oct 2003 00:12:43 +0100"
isosent="20031030231243"
name="Jos De_Roo"
email="jos.deroo@agfa.com"
subject="Re: How does Euler handle CWM builtins?"
id="OFC75FE546.115EA369-ONC1256DCF.007F2610-C1256DCF.007F85BC@agfa.be"
charset="us-ascii"
inreplyto="How does Euler handle CWM builtins?"
expires="-1"

To:"Graham Klyne<gk"<gk@ninebynine.org>
Cc:www-archive@w3.org




Graham - CWM proposed builtins used in rule antecedents
or in queries are typically succeeding when the object
unifies with the result of the predicate operating on
the subject argument (list).
For example, the query
  (1 1) math:sum _:X.
succeeds and the proof is
  (1 1) math:sum [iw:Variable "_:X_2"; = 2].

Also
  (1 1) math:sum _:X.
  (1 _:X) math:product _:X.
succeeds,
but
  (1 1) math:sum _:X.
  (1 _:X) math:difference _:X.
doesn't succeed.

A more elaborate query is at
http://www.agfa.com/w3c/euler/builtins.n3
and it's proof is

#########################################
# Generated with http://www.agfa.com/w3c/euler/#R3629 on 30 Oct 2003
22:58:38 GMT
{
 (
 ).<http://www.w3.org/2000/10/swap/log#conjunction> =>

<http://www.agfa.com/w3c/euler/builtins.n3>.<http://www.w3.org/2000/10/swap/log#semantics>
}
<http://www.w3.org/2000/10/swap/reason#because>
{
@prefix iw: <http://www.ksl.stanford.edu/software/IW/spec/iw#>.
@prefix xsd: <http://www.w3.org/2001/XMLSchema#>.
@prefix math: <http://www.w3.org/2000/10/swap/math#>.
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix : <http://www.agfa.com/w3c/euler/builtins#>.
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
@prefix str: <http://www.w3.org/2000/10/swap/string#>.


("a" "b" "c") str:concatenation [iw:Variable "_:X_1"; = "abc"].
("a" "b" "c") str:concatenation "abc".
"xyz" str:equalIgnoringCase "XYZ".
"xyz" str:notEqualIgnoringCase "ABC".
"xyz" str:greaterThan "abc".
"abc" str:notGreaterThan "xyz".
"abc" str:lessThan "xyz".
"xyz" str:notLessThan "abc".
"xyz" str:notLessThan "xyz".
"abc" str:startsWith "ab".
"abc" str:endsWith "bc".
"abc" str:endsWith [iw:Variable "_:X_1"; = "abc"].
"abcXYZ" str:contains "cX".
"abcXYZ" str:containsIgnoringCase "Cx".
(1.2 2.3 3.5) math:sum [iw:Variable "_:Y_1"; = 7.0].
(7.0 1) math:difference [iw:Variable "_:Z_1"; = 6.0].
(1 2 3) math:product [iw:Variable "_:U_1"; = 6].
(6 3) math:quotient [iw:Variable "_:V_1"; = 2.0].
(7 3) math:quotient [iw:Variable "_:A_1"; = 2.3333333333333335].
(7 3) math:integerQuotient [iw:Variable "_:B_1"; = 2].
(6.0 2.0) math:remainder [iw:Variable "_:W_1"; = 0.0].
(7 3) math:remainder [iw:Variable "_:C_1"; = 1].
-5 math:negation [iw:Variable "_:I_1"; = 5].
-5.1 math:absoluteValue [iw:Variable "_:D_1"; = 5.1].
-5.7 math:rounded [iw:Variable "_:E_1"; = -6].
(2 10) math:exponentiation [iw:Variable "_:J_1"; = 1024].
(1 2) math:atan2 [iw:Variable "_:T1_1"; = 0.4636476090008061].
2 math:cos [iw:Variable "_:T2_1"; = -0.4161468365471424].
0.5 math:cosh [iw:Variable "_:T3_1"; = 1.0471975511965979].
2 math:degrees [iw:Variable "_:T4_1"; = 114.59155902616465].
2 math:sin [iw:Variable "_:T5_1"; = 0.9092974268256817].
0.5 math:sinh [iw:Variable "_:T6_1"; = 0.5235987755982989].
2 math:tan [iw:Variable "_:T7_1"; = -2.185039863261519].
0.5 math:tanh [iw:Variable "_:T8_1"; = 0.4636476090008061].
("a" ("b" "c") "d") math:memberCount [iw:Variable "_:K_1"; = 3].
[iw:Variable "_:U_1"; = 6] math:greaterThan [iw:Variable "_:V_1"; = 2.0].
[iw:Variable "_:V_1"; = 2.0] math:notGreaterThan [iw:Variable "_:U_1"; =
6].
[iw:Variable "_:V_1"; = 2.0] math:lessThan [iw:Variable "_:U_1"; = 6].
[iw:Variable "_:U_1"; = 6] math:notLessThan [iw:Variable "_:V_1"; = 2.0].
[iw:Variable "_:U_1"; = 6] math:equalTo [iw:Variable "_:U_1"; = 6].
[iw:Variable "_:V_1"; = 2.0] math:notEqualTo [iw:Variable "_:U_1"; = 6].
:x log:equalTo :x.
:x log:notEqualTo :y.
:b log:includes :e.
:b log:notIncludes :x.
# Proof found for http://www.agfa.com/w3c/euler/builtins.n3 in 47 steps
(671 steps/sec) using 3 engines
}.
#########################################


For the easter test case, the dates are indeed calculated.
The query here for instance could be
http://www.agfa.com/w3c/euler/easterC.n3
i.e.
_:A :hasEasterOnDay _:B; :hasEasterOnMonth _:C.
and the according proof, given
http://www.agfa.com/w3c/euler/easterP.n3
is then

#########################################
# Generated with http://www.agfa.com/w3c/euler/#R3629 on 30 Oct 2003
23:03:03 GMT
{
 (

<http://www.agfa.com/w3c/euler/easterP.n3>.<http://www.w3.org/2000/10/swap/log#semantics>
 ).<http://www.w3.org/2000/10/swap/log#conjunction> =>

<http://www.agfa.com/w3c/euler/easterC.n3>.<http://www.w3.org/2000/10/swap/log#semantics>
}
<http://www.w3.org/2000/10/swap/reason#because>
{
@prefix str: <http://www.w3.org/2000/10/swap/string#>.
@prefix xsd: <http://www.w3.org/2001/XMLSchema#>.
@prefix : <http://www.agfa.com/w3c/euler/easter#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
@prefix math: <http://www.w3.org/2000/10/swap/math#>.
@prefix owl: <http://www.w3.org/2002/07/owl#>.
@prefix iw: <http://www.ksl.stanford.edu/software/IW/spec/iw#>.
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.

 {
  <http://www.agfa.com/w3c/euler/easter#easter1>.
  [iw:Variable "?Y"; = 2003] a :Year.
  (2003 19) math:remainder [iw:Variable "?J"; = 8].
  (2003 100) math:integerQuotient [iw:Variable "?K"; = 20].
  (2003 100) math:remainder [iw:Variable "?H"; = 3].
  (20 4) math:integerQuotient [iw:Variable "?M"; = 5].
  (20 4) math:remainder [iw:Variable "?N"; = 0].
  (28 25) math:integerQuotient [iw:Variable "?P"; = 1].
  (20 3) math:integerQuotient [iw:Variable "?Q"; = 6].
  (176 30) math:remainder [iw:Variable "?R"; = 26].
  (3 4) math:integerQuotient [iw:Variable "?S"; = 0].
  (3 4) math:remainder [iw:Variable "?U"; = 3].
  (3 7) math:remainder [iw:Variable "?V"; = 3].
  (360 451) math:integerQuotient [iw:Variable "?W"; = 0].
  (143 31) math:integerQuotient [iw:Variable "?X"; = 4].
  (143 31) math:remainder [iw:Variable "?Z"; = 19].
  (19 1) math:sum [iw:Variable "?DAY"; = 20]} =>
{[iw:Variable "_:A_2"; = 2003] :hasEasterOnDay [iw:Variable "_:B_2"; =
20]}.
 {
  <http://www.agfa.com/w3c/euler/easter#easter1>.
  [iw:Variable "?Y"; = 2003] a :Year.
  (2003 19) math:remainder [iw:Variable "?J"; = 8].
  (2003 100) math:integerQuotient [iw:Variable "?K"; = 20].
  (2003 100) math:remainder [iw:Variable "?H"; = 3].
  (20 4) math:integerQuotient [iw:Variable "?M"; = 5].
  (20 4) math:remainder [iw:Variable "?N"; = 0].
  (28 25) math:integerQuotient [iw:Variable "?P"; = 1].
  (20 3) math:integerQuotient [iw:Variable "?Q"; = 6].
  (176 30) math:remainder [iw:Variable "?R"; = 26].
  (3 4) math:integerQuotient [iw:Variable "?S"; = 0].
  (3 4) math:remainder [iw:Variable "?U"; = 3].
  (3 7) math:remainder [iw:Variable "?V"; = 3].
  (360 451) math:integerQuotient [iw:Variable "?W"; = 0].
  (143 31) math:integerQuotient [iw:Variable "?X"; = 4].
  (143 31) math:remainder [iw:Variable "?Z"; = 19].
  (19 1) math:sum [iw:Variable "?DAY"; = 20]} =>
{[iw:Variable "_:A_2"; = 2003] :hasEasterOnMonth [iw:Variable "_:C_2"; =
4]}.
 {
  <http://www.agfa.com/w3c/euler/easter#easter1>.
  [iw:Variable "?Y"; = 2004] a :Year.
  (2004 19) math:remainder [iw:Variable "?J"; = 9].
  (2004 100) math:integerQuotient [iw:Variable "?K"; = 20].
  (2004 100) math:remainder [iw:Variable "?H"; = 4].
  (20 4) math:integerQuotient [iw:Variable "?M"; = 5].
  (20 4) math:remainder [iw:Variable "?N"; = 0].
  (28 25) math:integerQuotient [iw:Variable "?P"; = 1].
  (20 3) math:integerQuotient [iw:Variable "?Q"; = 6].
  (195 30) math:remainder [iw:Variable "?R"; = 15].
  (4 4) math:integerQuotient [iw:Variable "?S"; = 1].
  (4 4) math:remainder [iw:Variable "?U"; = 0].
  (19 7) math:remainder [iw:Variable "?V"; = 5].
  (284 451) math:integerQuotient [iw:Variable "?W"; = 0].
  (134 31) math:integerQuotient [iw:Variable "?X"; = 4].
  (134 31) math:remainder [iw:Variable "?Z"; = 10].
  (10 1) math:sum [iw:Variable "?DAY"; = 11]} =>
{[iw:Variable "_:A_2"; = 2004] :hasEasterOnDay [iw:Variable "_:B_2"; =
11]}.
 {
  <http://www.agfa.com/w3c/euler/easter#easter1>.
  [iw:Variable "?Y"; = 2004] a :Year.
  (2004 19) math:remainder [iw:Variable "?J"; = 9].
  (2004 100) math:integerQuotient [iw:Variable "?K"; = 20].
  (2004 100) math:remainder [iw:Variable "?H"; = 4].
  (20 4) math:integerQuotient [iw:Variable "?M"; = 5].
  (20 4) math:remainder [iw:Variable "?N"; = 0].
  (28 25) math:integerQuotient [iw:Variable "?P"; = 1].
  (20 3) math:integerQuotient [iw:Variable "?Q"; = 6].
  (195 30) math:remainder [iw:Variable "?R"; = 15].
  (4 4) math:integerQuotient [iw:Variable "?S"; = 1].
  (4 4) math:remainder [iw:Variable "?U"; = 0].
  (19 7) math:remainder [iw:Variable "?V"; = 5].
  (284 451) math:integerQuotient [iw:Variable "?W"; = 0].
  (134 31) math:integerQuotient [iw:Variable "?X"; = 4].
  (134 31) math:remainder [iw:Variable "?Z"; = 10].
  (10 1) math:sum [iw:Variable "?DAY"; = 11]} =>
{[iw:Variable "_:A_2"; = 2004] :hasEasterOnMonth [iw:Variable "_:C_2"; =
4]}.
# Proof found for http://www.agfa.com/w3c/euler/easterC.n3 in 1013 steps
(624 steps/sec) using 1 engine
}.
#########################################

so next year, Easter should be on April 11
(well, at least I hope so :-))

--
Jos De Roo, AGFA http://www.agfa.com/w3c/jdroo/


                                                                                                                                       
                      Graham Klyne                                                                                                     
                      <gk@ninebynine.or        To:       Jos De_Roo/AMDUS/MOR/Agfa-NV/BE/BAYER@AGFA                                    
                      g>                       cc:                                                                                     
                                               Subject:  How does Euler handle CWM builtins?                                           
                      2003-10-30 06:13                                                                                                 
                      PM                                                                                                               
                                                                                                                                       
                                                                                                                                       




Jos,

I'm doing a mini-survey of RDF inference techniques, with particular
reference to how datatype-related inferences are handled in different
systems.  Mostly it seems fairly crude.  I notice that Euler seems to have
some support for CWM builtins, but how do you use them?  (As defined for
use with CWM, I think they can only be used in forward chaining mode --
though clearly they could be adapted).  I'm wondering what you do.

Judging by:
   http://www.agfa.com/w3c/euler/easterP.n3
it appears that you must process the builtin's in the antecedent of a rule.
Can you actually calculate the day of Easter here, or just confirm that a
given day is correct or not?  If the former, how do you process builtins in

the antecedent of a rule?  (Hmmm... could be left-to-right, as one would if
interpreting a Prolog clause?)

#g


------------
Graham Klyne
For email:
http://www.ninebynine.org/#Contact



