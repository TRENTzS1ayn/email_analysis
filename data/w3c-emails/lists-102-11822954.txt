docno="lists-102-11822954"
received="Wed Dec 16 11:46:17 1998"
isoreceived="19981216164617"
sent="Wed, 16 Dec 1998 09:45:18 -0700"
isosent="19981216164518"
name="Ray Whitmer"
email="ray@imall.com"
subject="Re: Equality tests on DOM nodes"
id="3677E39E.8BAECF6E@imall.com"
charset="us-ascii"
inreplyto="36769F71.A90D8C2A&#64;eng.sun.com"
expires="-1"


To: David Brownell<db@Eng.Sun.COM>
CC:www-dom@w3.org,xml-sig@python.org

David Brownell wrote:

> Though there's one thing to consider:  The behavior of Object.equals()
> and Object.hashCode() is specified to make objects work as hashtable
> keys in the natural manner.  For example, strings can be used as keys
> since they're immutable and equals() is overridden ... were they mutable,
> or did they not override equals(), that'd not be so.

That is a sad but true that Hashtable influenced the implementation of
Object.  Equals is problematic in Object's API because of its ambiguity, but
about every other language seems to do something similarly ambiguous.  You
raise a connection between equals and immutability that I generally tend to
overlook as nonessential.  There are plenty of other examples in the jdk that
also overlook it that I cited before (like Point or Rectangle), again
demonstrating the ambiguity of the interpretation of equals, which I think we
are mostly agreed upon.  Users of Hashtable must rely on discipline, because
there is not enough typing to otherwise guarantee that the interpretation of
equals will not change.

In any case, equals should not be usable for Node until a clear portable
definition is established, whether that be the identity interpretation or some
deeper interpretation.

Ray



