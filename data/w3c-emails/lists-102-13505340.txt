docno="lists-102-13505340"
received="Mon Jan  4 12:55:39 1999"
isoreceived="19990104175539"
sent="Mon, 04 Jan 1999 09:49:03 -0800"
isosent="19990104174903"
name="Lauren Wood"
email="lauren@sqwest.bc.ca"
subject="Re: Level 2 - DTDs?"
id="3690FF0F.25589A36@sqwest.bc.ca"
charset="us-ascii"
inreplyto="3.0.5.32.19981228180452.0097a180&#64;citec.fi"
expires="-1"


To:www-dom@w3.org



Michael Leventhal wrote:

> Again, I apologize for barging in and asking someone to rehash
> something already said many times over.  But ... may I ask if it
> would be appropriate at this stage to consider or even to make
> a specific proposal introducing a very small set of methods which would
> today use information gotten from the DTD, perhaps later from a schema,
> and would provide something quite useful without covering the full
> expressiveness (or, if you will, arcaneness) of a DTD?  For example, 
> I could do quite a lot with only a single method which would return 
> the set of elements permitted in a context.

What would help would be some idea of the relative importance of things
commonly covered under the term "DTD". For example, you say just a list
of the elements permitted in context would be useful. I can think of a
number of things along this line, and to have some idea of relative
priority would help the DOM WG along. 

Here is a non-exclusive list:
Validation:
data typing valid (would need to wait for schemas)
this element is allowed here 
this document is currently valid

DTD information (probably to be extended with schemas):
elements allowed within this element (no repetition or ordering info)
elements allowed within this element (with repetition and ordering info)
allowed attribute names for this element
allowed attribute values for this attribute on this element

DOM Level 1 already has a list of notations and entities.

Then the question as to read-only and read-write comes up. Is read-only
sufficient to start? 

Does the information in the internal subset need to be distinguished
from that in the external subset?

Any thoughts you have on these sorts of questions would help us figure
out what the minimum useful set of functionality is. The smaller it is,
the faster we can get it done. We can add more functionality later.



