docno="lists-102-16598837"
received="Tue Oct  5 11:58:45 1999"
isoreceived="19991005155845"
sent="Tue, 5 Oct 1999 12:41:17 -0400 (EDT)"
isosent="19991005164117"
name="John Cowan"
email="cowan@locke.ccil.org"
subject="Re: DOM L2 comments, various"
id="199910051641.MAA19845@locke.ccil.org"
charset="US-ASCII"
inreplyto="37FA0CBF.8008CA18&#64;w3.org"
expires="-1"


To:lehors@w3.org(Arnaud Le Hors)
Cc:www-dom@w3.org

Arnaud Le Hors scripsit:

> John Cowan wrote:
> > 
> > Just because an object implements Attr is no guarantee
> > that it is an attribute.
> 
> Is this because in your implementation the same class is used for
> different types of nodes? I bet it is.

Indeed.

> I used to do the same. Basically
> all the HTML*Element interfaces were implemented on the same class. But
> I finally decided that it was a bug in my implementation to make
> instanceof unreliable. Think about it. If instanceof(Attr) returns true,
> it'd better be an Attr node, or your users will get very confused.

Au contraire.  I believe that using instanceof for type discrimination
(as in, if (x instanceof Element) do_this else if (x instanceof Attr) do_that)
is the worst kind of bogus OOP.  My implementation makes zero
guarantees about underlying classes, how many or with what crossovers.

BTW, I don't see how you can implement all HTML*Element interfaces with
one class in Java, since some of the instance methods have incompatible
return types, and Java doesn't allow overloading on the return type.
I needed IIRC six classes.

-- 
John Cowan                                   cowan@ccil.org
       I am a member of a civilization. --David Brin



