docno="lists-102-2809887"
received="Fri May  1 12:23:42 1998"
isoreceived="19980501162342"
sent="Fri, 1 May 1998 09:31:41 -0700"
isosent="19980501163141"
name="Andrew n marshall"
email="amarshal@usc.edu"
subject="RE: Alternative to the Live NodeIterator"
id="000201bd751e$9f0e38e0$25e37d80@philica"
charset="iso-8859-1"
inreplyto="199805011555.IAA11360&#64;sqwest.bc.ca"
expires="-1"

To:"Peter Sharpe"<peter@sqwest.bc.ca>,<www-dom@w3.org>


> -----Original Message-----
> From: Peter Sharpe
> Subject: RE: Alternative to the Live NodeIterator
 . . .
> Any object which contains a reference to one or more nodes in the tree will
> have
> to be "maintained" during editing operations. There are many ways
> to implement
> this, obviously, but one way, conceptually at least, is to have methods like
> beforeDelete(Node nodeBeingDeleted), afterInsert(Node
> nodeBeingInserted), etc.
> If you implement your iterators as a linked list then on a Node delete
> operation
> you can call
>   myIteratorClass::beforeDelete(Node nodeBeingDeleted) {
>     if nodeBeingDeleted is something I reference then
>        fix up my reference by finding an appropriate node that will still
>        be around after nodeBeingDeleted is gone.
>     }
>     nextIterator()->beforeDelete(nodeBeingDeleted);
>   }


Yes.  This is an excelent way to create the iterator class proposed in the
spec.  In fact, this is very similar to the Visitor model Don Park mentioned.

My point is it requires the document tree to have a reference to the Iterator
so this update can be made.  And as Don Park also mentioned, these reference
need a release mechanism.



Andrew n marshall
??student - artist - programmer
???? http://www.media-electronica.com/anm-bin/anm
??????"Everyone a mentor, Everyone a pupil"



