docno="lists-102-3096133"
received="Mon May  4 00:18:27 1998"
isoreceived="19980504041827"
sent="Sun, 3 May 1998 23:18:21 -0500"
isosent="19980504041821"
name="Jeff"
email="jmackay@enteract.com"
subject="Re: Alternative to the Live NodeIterator"
id="00a601bd7713$aca636a0$dc8ae5cf@jmackay-4.soho.enteract.com"
charset="iso-8859-1"
inreplyto="Alternative to the Live NodeIterator"
expires="-1"


To:<www-dom@w3.org>

>> Hmm, my reading says that there are no nodes in a "deleted" state;
they're
>> just detached from some other node.  So there's no need to have iterators
>> interacting with Node.remove!  (I just persuaded myself of that ...)
>

Actually, the NodeIterator specification just requires a "robust"
implementation of the Iterator pattern.  I'll quote from the gang of four:

    "How robust is the iterator? It can be dangerous to modify an aggregate
while you're traversing it. If elements are added or deleted from the
aggregate, you might end up accessing an element twice or missing it
completely. A simple solution is to copy the aggregate and traverse the
copy, but that's too expensive to do in general.

A *robust iterator* ensures that insertions and removals won't interfere
with traversal, and does it without copying the aggregate. There are many
ways to implement robust iterators. Most rely on registering the iterator
with the aggregate. On insertion or removal, the aggregate either adjusts
the internal state of iterators it has produced, or it maintains information
internally to ensure proper traversal."

Discussions of other existing implementations can be found in:

- Thomas Kofler, Robust Iterators in ET++, Structured Programming, 14:62-85,
March 1993.

- Robert B. Murray, C++ Strategies and Tactics, Addison-Wesley, Reading, MA,
1993



