docno="lists-102-3961152"
received="Fri May 29 13:49:57 1998"
isoreceived="19980529174957"
sent="Fri, 29 May 1998 10:50:11 -0700"
isosent="19980529175011"
name="David Brownell"
email="David.Brownell@Eng.Sun.COM"
subject="RE: Object ownership?"
id="199805291750.KAA17618@argon.eng.sun.com"
inreplyto="Object ownership?"
expires="-1"


To:ericvas@microsoft.com,mcc@arbortext.com,www-dom@w3.org

> From: Eric Vasilik <ericvas@microsoft.com>
> Date: Wed, 27 May 1998 10:20:21 -0700
> 
> It just seems that no matter what memory management model one uses, there is
> an implicit ownership model which has to exist.  Strictly, there is no need
> to mention it, but because it is so implicit, perhaps it should be mentioned
> for the sake of users and implementors.

It's already defined by the OMG-IDL ... all those "in" parameters are passed
by reference.  (I'd argue to point this out, referring to CORBA for the full
details.)  So for example consider

    module DOM {
interface Node {
    ...
    Node insertBefore (in Node newChild, in Node refChild)
raises NotMyChildException;
    ...
}
    }

In all language bindings, the caller retains ownership of the target
nodes as well as the newChild and refChild nodes.  That's before, during,
and after the calls.

If the implementation  wants to retain ownership (as it must in this case)
it will retain a reference.  In reference counted systems (CORBA C/C++
bindings, COM, etc) that's increasing a reference count.  In GC'd systems
like Java, it's just saving the (pointer to) the object.

If the caller  wants to give up ownership of the target nodes, it must
release the reference:  decrement a reference count, null out the GC'able
object pointer, etc.

- Dave



