docno="lists-102-5517484"
received="Mon Jul 27 16:34:09 1998"
isoreceived="19980727203409"
sent="Mon, 27 Jul 1998 16:34:17 -0400"
isosent="19980727203417"
name="keshlam@us.ibm.com"
email="keshlam@us.ibm.com"
subject="Implementing NodeList"
id="8525664E.0070DDC2.00@us.ibm.com"
charset="us-ascii"
expires="-1"

To:www-dom@w3.org



     Its simpler than it seems.  Each insertion or removal involves
     incrementing
     or decrementing the index by one.

That's not quite so simple, unless I'm missing something.

You're proposing we update the index of all the listed Nodes after the
insert or delete point.  I looked at that approach. For insertion, it means
doing a common-root search (or some equivalent thereof) between that point
and all the currently listed nodes until you find the appropriate insert
point in the NodeList. Not cheap, though it probably beats repeating the
search from scratch every time you increment the index.

You have to do this for all the currently-active NodeLists that might want
to know about that portion of the tree.

That "currently-active" phrase looks to be a disaster in Java. There's no
architected way to terminate a NodeList, and the reference from the tree to
the NodeList (required to ensure that the NodeList responds when the tree
is changed) will also ensure that the latter is never garbage-collected
until the tree itself goes away. So even if the above can be made to run
quickly, it's a memory leak begging for an opportunity.


Am I misunderstanding your suggestion, or misunderstanding the spec?



