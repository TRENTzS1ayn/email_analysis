docno="lists-102-7354454"
received="Thu Aug 20 18:12:10 1998"
isoreceived="19980820221210"
sent="Thu, 20 Aug 1998 16:12:14 -0600"
isosent="19980820221214"
name="Ray Whitmer"
email="ray@imall.com"
subject="Synchronization (was Re: Comments on the use of exceptions...)"
id="35DC9F3E.2756076D@imall.com"
charset="us-ascii"
inreplyto="35DC9217.1B2177C5&#64;locke.ccil.org"
expires="-1"


To:www-dom@w3.org

John Cowan wrote:

> Mike Champion wrote:
>
> > When looping over all child nodes, or all nodes returned by
> > getElementsByTag name, we DO NOT want to force the user to call the size()
> > [or whatever we ended up calling it; sorry I'm in a hurry ...] method to
> > figure out how far to loop, because that might force the implementation to
> > travel all the relevant Nodes and count them.
>
> Not only that, but there is no assurance that the user's cached value
> of NodeList.length is still correct, since new Nodes may have been
> added to the tree.  So looping from 0 to length-1 is downright
> incorrect.

For me, Mike's argument about the implementation not having to compute the
length is a more compelling reason for item to return null instead of throwing
an exception.

Looping from 0 to length - 1 is correct with synchronization.

Without synchronization, the whole thing is somewhat meaningless because the
nodes visited do not represent a consistent set.  There is more than just
wondering if the length is correct.  At least the loop from 0 to length - 1
terminates, and it is arguable whether it is any worse to miss nodes at the end
of the list than elsewhere in the list.

Various synchronization techniques provide the real answer to problems of
modifying and reading the data in the hierarchy at the same time.

NodeList is just another way to access the hierarchy.  Even without a NodeList,
an unsynchronized traversal loop fails to consistently traverse the set.  If
the loop is written using getFirstChild, getNextChild, etc., the current child
you are visiting could leave or move in the hierarchy.  You might never
complete if the last sibling continually becomes the first sibling.

Static or live, NodeList does not solve synchronization.  In some cases,
copying to a static list or snapshoting the hierarchy may be an answer.  But
that forces you to put up with the overhead to compute and copy the whole list
is advance (again, during synchronization) and have stale, misordered, and
missing entries in your result set, as compared with the current document.

Ray Whitmer
ray@imall.com



