docno="lists-102-8225942"
received="Wed Sep 23 17:03:35 1998"
isoreceived="19980923210335"
sent="Wed, 23 Sep 1998 18:53:45 -0400"
isosent="19980923225345"
name="keshlam@us.ibm.com"
email="keshlam@us.ibm.com"
subject="Re: Efficient read-only cloning?"
id="85256688.007C0DEE.00@us.ibm.com"
charset="us-ascii"
inreplyto="Efficient read-only cloning?"
expires="-1"

To:www-dom@w3.org


>Only if the design tool (editor?) actually expands the EntityReference,
>which I suspect it's not likely to do while you're editing.  If I wanted
to
>see the expansions (perhaps in some kind of preview window), I'd implement
>it using some kind of tree traverser that went directly to the Entity
rather
>than blindly descending into the children of the EntityReference.

This presumes that you're the author of the editor. If I'm trying to allow
for things an editor might do and expect to work, I think the bias goes the
other way. But we probably won't know until the DocumentType spec is nailed
down in Level 2; Level 1's design of that part of the DOM is known to be
incomplete and is intended more as a statement of direction than anything
else.

You're right, if one has an iterator/visitor class built into the DOM it
could synthesize context-dependent parentage. But we ain't got it in Level
1, and unless Level 1 changes and/or Level 2 is allowed to be incompatable
with Level 1 (neither of which I really expect to happen, though I'd
greatly prefer the former to the latter), we have to implement what we've
got -- and then hope that people realize that the Level 2 mechanisms may be
considerably more efficient than the Level 1 equivalents.


BTW, I found the wording that I think prevents the imaginary-child
solution. EntityReference, third paragraph, explicitly refers to "the
_children_ of the EntityReference" -- ergo the value is in fact children,
which implies that their parent must in fact be the EntityReference. Much
as one might wish otherwise, that word sets a whole suite of behaviors. In
fact, that paragraph goes on to mention lazy evaluation, presumably as a
mechanism for not burning the additional space for these kids until/unless
they're actually touched.

If we _can_ simply point to the Entity's subtree and tolerate the fact that
its parent links won't bring us back to the EntityReference, I'll take it
-- but in that case we need an explicit statement in EntityRef's
description that this departure from the tree model is permitted.

Without some such permission, this has to be put in the same category as
getElementsByTagName -- inefficient by design, in exchange for simplifying
the API to the point where a novice programmer won't have to learn any new
concepts. That's not my preferred tradeoff point, but it seems to be where
Level 1 was targeted.

______________________________________
Joe Kesselman  / IBM Research
Unless stated otherwise, all opinions are solely those of the author.



