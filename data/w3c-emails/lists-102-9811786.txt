docno="lists-102-9811786"
received="Fri Oct 16 09:24:40 1998"
isoreceived="19981016132440"
sent="Fri, 16 Oct 1998 09:23:50 -0400"
isosent="19981016132350"
name="Mike Champion"
email="mcc@arbortext.com"
subject="Re: Question on NodeList and client-server"
id="3.0.5.32.19981016092350.009c6500@pophost.arbortext.com"
charset="us-ascii"
inreplyto="000e01bdf838$c5534e30$dd3004c6&#64;mohawk.xyvision.com"
expires="-1"


To:"Don Hamson"<donh@xyvision.com>,<www-dom@w3.org>

At 01:43 PM 10/15/98 -0400, Don Hamson wrote:
>    NodeLists are said to be live such that additions/deletions of children
>will be reflected in the NodeList I retrieved prior to the
>addition/deletion...  Without copying the children to a private object
>instance, or locking children nodes; how do I know that the length is valid
>when I attempt to iterate over the list?

This definitely belongs in the FAQ -- Many implementations of the DOM built
on top of underlying list or tree data structures, it may be very slow to
get the length of a NodeList and then iterate across all indexes up to the
length.  The DOM specifies that the NodeList getItem() method (?? sorry, I
don't have the spec in front of me) will return NULL when it is given an
out-of-range index, so you can just loop until it returns NULL.  In other
words, a NodeList is not like a C array that could cause an addressing
violation if you try to access it beyond its boundaries, so you needn't
check to see if you are within its boundaries before you access into it.

>
>    I don't see problems for a single client environment, but for
>connectionless multi-client internet applications; seems a bit sticky.
>Comments?  Thanks.

Well, the DOM Level 1 is intended, and I think the spec clearly states this
somewhere, for single-user applications; locking, repository interfaces,
etc. will be addressed in subsequent levels.  Level 2 will have interfaces
for a query mechanism, and support "iterators" that should work more
cleanly in a multi-client environment than NodeLists.

Mike Champion



