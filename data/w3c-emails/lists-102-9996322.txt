docno="lists-102-9996322"
received="Fri Oct 16 19:29:00 1998"
isoreceived="19981016232900"
sent="Fri, 16 Oct 1998 17:27:17 -0600"
isosent="19981016232717"
name="Ray Whitmer"
email="ray@imall.com"
subject="Re: An observation about &quot;live&quot; NodeLists"
id="3627D655.39D908D2@imall.com"
charset="us-ascii"
inreplyto="qc67dk9rio.fsf&#64;gelion.crc.ricoh.com"
expires="-1"


To:"Stephen R. Savitzky"<steve@crc.ricoh.com>,www-dom@w3.org



Stephen R. Savitzky wrote:

> I think that the naive script writer is more likely to write something like
> my snippet (which blows up) or yours (which is written much more carefully
> and so only has _one_ bug in it) and spend a lot of time head-scratching.

This is a common phenomenon for containers of all sorts.  Repackaging liveness of
node lists does not make the problem worse than it is.

For example, if I use the most common Java object container models:

int length = myVector.size();
for (int i = 0; i < length; i++)
{
    Object o = myVector.elementAt(i);
    myVector.remove(o);
}

Or,

int length = myContainer.getComponentCount();
for (int i = 0; i < length; i++)
{
    java.awt.Component child = getComponent(i);
    myContainer.remove(child);
}

I get the same thing, I deleted every other object and a blowup, and the solution
you have suggested is required to solve these cases, too (and there are
alternatives, too).

Liveness is the rule in object models.  It is grade-school programming to
understand that if you remove an object, the indices shift.

Iterators to iterate such lists can solve these liveness issues.  But too many
iterator issues were unresolved to put iterators into level 1 of the DOM.

The iterator returned, for example, by java.util.Vector could easily solve the
liveness problem if it bothered to adjust the current index when an insertion or
deletion happened (which it does not).

Perhaps you could cite for me examples in the familiar Java API where a static
snapshot of a live object model's contained/collected list is returned for
indexing or iterating instead of the live model.  That would be very inefficient
and counter-intuitive for many programmers.  Static behavior is arguably far less
intuitive than live behavior, because you encounter things that are stale or out
of order, no longer related, etc. and the programmer who expects remove(i) to
remove the object as it does in other object models encounters unusual behavior.

Ray Whitmer
ray@imall.com



