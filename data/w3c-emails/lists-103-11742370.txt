docno="lists-103-11742370"
received="Thu Apr 26 08:59:13 2001"
isoreceived="20010426125913"
sent="Thu, 26 Apr 2001 08:58:14 -0400"
isosent="20010426125814"
name="Joseph Kesselman"
email="keshlam@us.ibm.com"
subject="Re: DOM Core Level 3 questions"
id="OF4ED22D46.85070FD4-ON85256A3A.0045A006@pok.ibm.com"
charset="us-ascii"
inreplyto="DOM Core Level 3 questions"
expires="-1"

To: Michael Amster<mamster@webeasy.com>
Cc:www-dom@w3.org



>1. We have a prefix without a namespace URI declaration

I don't know whether the lastest draft, which includes an algorithm sketch,
was made available to the public. If so, that gives you a detailed answer
(though not quite a correct one; we've tweaked it slightly.)

In brief:  If you have a prefix on a node, by definition that was a
namespace-aware node and also has a namespace URI. We take that as implying
a declaration, and normalizeNamespace will create the appropriate namespace
declaration attribute at "a reasonable place" -- probably locally, to
simplify the algorithm and to agree with the behavior that  serialization
(the save part of load/save) will want to use to resolve the same
situation.

>2. How do we handle ambiguous nodes

Remember, namespace-aware nodes are bound to a namespace (though not
necessarily a prefix) at the time they are created, so a node's semantic
role and "expanded name" (namespace/localname pair) can never be
ambiguioius. Which prefix we should assert for it may be ambiguous if if
the user left the prefix blank, but  that means they don't have a
preference and any in-scope prefix which is bound to that URI is
acceptable.

Note that we haven't yet firmly decided whether the DOM is going to nail
down a specific algorithm or simply require that implementations pick one
of the several approaches which will generate XML documents having the
correct semantics. We're reluctantly leaning toward the former, largely to
ease implementation of XML signatures and the like which may be sensitive
to exactly where the namespace was declared and with which prefix.

> How far along is the Xerces reference implementation?

Of this operation? Given that I've published a proposed algorithm,
implementing it  would be fairly trivial. Given that we're changing that
algorithm, and that it's subject to further evolution as we continue to run
testcases against it, I suspect they're waiting for us to stabilize a bit
more.

I have no idea what the state of Xerces is; ask them and/or offer to get
involved -- it _is_ an open source project, after all. (I've occasionally
provided code and comments to that project, but I'm not currently deeply
involved in it; my "day job" when I'm not doing standards work currently
focuses primarily on Xalan.)

______________________________________
Joe Kesselman  / IBM Research



