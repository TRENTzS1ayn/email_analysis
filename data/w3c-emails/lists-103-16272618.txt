docno="lists-103-16272618"
received="Thu Jul  5 12:37:10 2001"
isoreceived="20010705163710"
sent="Thu, 5 Jul 2001 10:33:29 -0600 "
isosent="20010705163329"
name="Arnold, Curt"
email="Curt.Arnold@hyprotech.com"
subject="ActiveNodeSet/StaticNodeSet alternative"
id="70E215722F6AD511820A000103D141D40AA410@thor.aeathtl.com"
charset="iso-8859-1"
expires="-1"


To:"'www-dom@w3.org'"<www-dom@w3.org>

The basic distinction between ActiveNodeSet and StaticNodeSet 
is whether the node set is assembled at the time of the query 
versus at the time an individual node is accessed in the node set.  
However, ActiveNodeSet and StaticNodeSet have radically different 
signatures which would make it impossible to write code that 
could readily switch between evaluation modes.  This requires 
the code author to make an apriori decision on which method 
is going to be more efficient and makes it difficult to check 
the assumption.

It seems cleaner to me to have just the NodeSet interface 
with item() and length() methods and to add a boolean parameter, 
something like "lazyEvaluate" or similar, that, when true, allows 
the processor to lazily evaluate the node set if it wants.

Calling length(), of course, might force a full evaluation 
of the NodeSet, so you would want to write iterative loops like:

boolean lazy = true;
NodeSet nodeSet = doc.evaluateAsNodeSet
(targetElem,"lineitem",nsresolver, lazy);
Element lineitem;

try {
for(int i = 0; ; i++) {
//
//   will throw exception when i >= length
lineitem = (Element) nodeSet.item(i);
//
//   do stuff
}
}
catch(DOMException ex) {
}

The loop would work equivalently with either lazy or 
immediate construction of the node set.

Implementations that did not expect lazy evaluation to 
offer significant advantages could simply ignore the
lazy parameter.



