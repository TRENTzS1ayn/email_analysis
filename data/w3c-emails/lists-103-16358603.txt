docno="lists-103-16358603"
received="Thu Jul  5 17:45:10 2001"
isoreceived="20010705214510"
sent="Thu, 5 Jul 2001 15:41:31 -0600 "
isosent="20010705214131"
name="Arnold, Curt"
email="Curt.Arnold@hyprotech.com"
subject="RE: ActiveNodeSet/StaticNodeSet alternative"
id="70E215722F6AD511820A000103D141D40AA413@thor.aeathtl.com"
charset="iso-8859-1"
inreplyto="ActiveNodeSet/StaticNodeSet alternative"
expires="-1"


To:"'www-dom@w3.org'"<www-dom@w3.org>

> I think you missed the point of ActiveNodeSet and 
> StaticNodeSet.  It is
> not so that the application writer can decide which one he 
> thinks would be
> quicker, but rather so that he can decide which one he can deal with,
> since it was clear from several sources that each is a use 
> case.  A program
> that relies on an ActiveNodeSet is likely to not work with a 
> StaticNodeSet
> and vice versa, even if the APIs were identical, because users of
> ActiveNodeSet can assume that the nodes are always still in the tree,
> but he cannot mutate the tree without invalidating his set, can only
> assume that he can mutate the tree without invalidating the list.

I'll try to reread the working draft this weekend with that in mind.

However, that would still not negate my point that objects that 
represent the same concept (a NodeSet) should at least share a common
ancestor interface so that you don't have to create four different
implementations of some code that doesn't care if the NodeSet is a 
NodeList, NamedNodeMap, ActiveNodeSet or StaticNodeSet.  Though
if those distinctions might be essential to some applications,
they could be expressed by different derived interfaces or property
values.

I'm not sure of the value of ActiveNodeSet.  For the usage scenario
that you described, the tree being modified during the lifetime of
the NodeSet, presumably by another thread, all ActiveNodeSet gets you
is a check that the node is still a member of the result set at the
instant of the call to item().  Its membership in result set
could be invalidated immediately after the call to item().

If we had a distinct XPath expression interface, could the anticipated
use cases not be more cleanly implemented by having evalute and
evaluteAsNodeSet return a "static" list, but expose a method on the XPath
expression that allows you to determine whether a particular node is
instantaneously a member of the result set for the XPath expression.

XPathExpression expr = doc.createXPathExpression("lineitem",nsresolver);
//
//   generates list of lineitems currently in order at this instant
//
NodeSet lineitems = expr.evaluteAsNodeSet(order);
//
//   get first lineitem
Element firstItem = lineitems.item(0);
//
//   remove it from order
//      
order.removeChild(firstItem);
//
//   determines if the specific node (firstItem) is
//      at this moment a member of the result set of the XPath
//      expression when applied to the Order node
//
//   would be false
if(expr.isResultSetMember(order,firstItem)) {

}



