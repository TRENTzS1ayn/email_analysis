docno="lists-103-5338481"
received="Tue Feb 29 00:12:32 2000"
isoreceived="20000229051232"
sent="Tue, 29 Feb 2000 23:10:35 -0600"
isosent="20000301051035"
name="Jeff Mackay"
email="jmackay@vtopia.com"
subject="RE: Older Sibling?"
id="NDBBLNJDHJDKCNEECKOLMEGICFAA.jmackay@vtopia.com"
charset="us-ascii"
inreplyto="38BB387A.89E9C31A&#64;pacbell.net"
expires="-1"

To:<www-dom@w3.org>


I'm not sure where this discussion left off.  The original question was
something like: is there a method that will allow the user to check the
document order of two nodes.  This seems like a reasonable request to me,
and one that many of us have had to implement ourselves while using (and
implementing) the DOM. I'm sure this was discussed in the past, but
dismissed for implementation reasons.

So at the risk of kicking a dead horse, I'd suggest that two sets of methods
would be useful. The first being index-based:

// return index of child or -1 if not an immediate child
int Node.getIndexOf(Node child);

// return this node's index in its parent's child list, or -1 if not a
child.
int Node.getIndex()

The second set of operations is relational:

// return true if arg is positioned before this node.
// If deep is false, only siblings are checked. Otherwise,
// the entire document is checked.
boolean Node.isBefore(Node arg, boolean deep);

// return true if arg is positioned after...
boolean Node.isAfter(Node arg, boolean deep)

For implementations based on an array, the first set will be fast. For
implementations based on a list, the first could be slow. So to make things
fair for all implementors, the second set of methods will probably be
complicated regardless of implementation.

Granted, it may require some work on clarifying what happens when 'arg' is a
child of an entity, but I would think that implementors would be much more
qualified to implement these functions than users. It might even help to
clarify that portion of the spec.



