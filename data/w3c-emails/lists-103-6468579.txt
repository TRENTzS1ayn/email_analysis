docno="lists-103-6468579"
received="Thu Mar 16 16:14:59 2000"
isoreceived="20000316211459"
sent="Thu, 16 Mar 2000 14:14:12 -0700 (MST)"
isosent="20000316211412"
name="Ray D. Whitmer"
email="rayw@imall.com"
subject="Re: removeAttribute"
id="Pine.GSO.4.05.10003161350090.2364-100000@sol.imall.com"
charset="X-UNKNOWN"
inreplyto="38CFE673.21B6CF8&#64;ppp.uni-bamberg.de"
expires="-1"

To: Dieter K?hler<dieter.koehler@ppp.uni-bamberg.de>
cc:"www-dom@w3.org"<www-dom@w3.org>


On Wed, 15 Mar 2000, Dieter [iso-8859-1] K?hler wrote:

>In trying to implement the Element.removeAttribute resp.
>removeAttributeNS I am a little uncertain what happens with the
>attribute node afterwards.  Since it is a remove and not a delete
>method it suggests that the attribute is still there.  The problem of
>the application is, how to find out its address (in order to entirely
>delete it or to insert it somewhere else) since the removeAttribute
>method does not return the removed node. So the application has to
>detect the Attribute before removal:
>
>MyAttr:= MyElement.getAttributeNode('xyz');
>MyElement.removeAttribute('xyz');
>deleteOrDoSomethingElse(MyAttr);
>
>But then one could instead use the removeAttributeNode method:
>
>MyAttr:= MyElement.getAttributeNode('xyz');
>MyElement.removeAttributeNode(MyAttr);
>deleteOrDoSomethingElse(MyAttr);
>
>Conclusion: removeAttribute seems to be for almost every case
>replaceable by removeAttributeNode.  So its a superfluous extension of
>the DOM unless it gets the removed node as its return value.  Then one
>could write:
>
>MyAttr:= MyElement.removeAttribute('xyz');
>deleteOrDoSomethingElse(MyAttr);
>

Generally, removeAttribute is used when a user does not already have
a reference to the node and, hence, will not be reusing it.  Otherwise
the user could have called removeAttributeNode.  But removeAttribute
still allows for reuse, since it does not explicitly delete.  If the 
user hung on to a reference in some prior call, then it does not get 
deleted.

For garbage collected or reference counted solutions, this is not a
problem, because when the attribute is removed, if no references
remain, then it is automatically deleted.  Otherwise, it may be
reused, and the reference count or garbage collector detect this.

DOM implementations which do not rely on either garbage collection
or reference counting are, I believe, somewhat unknown and not
fully understood due to precisely this type of issue.

If the root of a sub-hierarchy is deleted without removing children, 
does this mean that all descendant nodes are automatically deleted?  
How about if a descendent is deleted, does his parent get deleted?  
How about if a document gets deleted, do all owned nodes get deleted, 
regardless of whether they were part of the hierarchy, etc.

Even reference counted implementations have to have special rules to 
avoid problems with cycles.

Ray Whitmer
ray@xmission.com



