docno="lists-104-1501281"
received="Sat Aug 18 02:49:17 2001"
isoreceived="20010818064917"
sent="Sat, 18 Aug 2001 02:55:38 -0400"
isosent="20010818065538"
name="Michael B. Allen"
email="mballen@erols.com"
subject="[Events] removeEventListener on EventListeners currently being processed"
id="20010818025538.A5479@nano.foo.net"
charset="us-ascii"
expires="-1"

To:www-dom@w3.org


The removeEventListener method insists that EventListeners not be
triggered after they have been removed (natrually) even if they are
removed while the current list (of which the removed EventListener was
a member) is still being processed.

  "If an EventListener is removed from an EventTarget while it
  is processing an event, it will not be triggered by the current
  actions. EventListeners can never be invoked after being removed."

Implementation-wise this presents a bit of a problem. If you use a linked
list for your listeners and the element you are currently iterating
over is removed (the listener removed itself) then you will dereference
an invalid pointer trying to get the next node. If you make a copy,
a listener may be triggered after it has been removed.

The only solution I have at the moment is to make a copy just prior to
triggering the list in dispatchEvent _but also_ check with the live
list just before triggering each listener to make sure they have not
been removed. IOW, only if the listener is in both the live list and
the copy should it be triggered. Of course checking the live with each
invocation of a listener would suggest arrays are used.

Is this true or did I miss something? Xerces-J 1.4.2 looks like it falls
into the 'make a copy and potentially trigger a listener that has been
removed' category but I'm not terribly familiar with that code. I don't
know about Xerces-C either -- the download was a little much for my
home connection.

Mike

-- 
Wow a memory-mapped fork bomb! Now what on earth did you expect? - lkml



