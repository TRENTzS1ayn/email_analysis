docno="lists-104-16091127"
received="Tue Aug 26 12:30:32 2003"
isoreceived="20030826163032"
sent="Tue, 26 Aug 2003 10:30:12 -0600 (MDT)"
isosent="20030826163012"
name="Ray Whitmer"
email="ray@xmission.com"
subject="Re: Draft Note on DOM Support for XPath 2.0"
id="Pine.LNX.4.53.0308260948250.31063@shell2.xmission.com"
charset="US-ASCII"
inreplyto="OFC77D7E8D.251223D8-ON85256D8D.006E5CBA-85256D8D.006ED4BD&#64;us.ibm.com"
expires="-1"

To: Joseph Kesselman<keshlam@us.ibm.com>
Cc:www-dom@w3.org



On Mon, 25 Aug 2003, Joseph Kesselman wrote:

[...]

> So I'd say XPath2Sequence sounds like *exactly* the right way to model
> this.
>
> If you want to also provide a convenience API which automatically unwraps
> singleton sequences, I think that's a separate question.

Yes, the result of an XPath evaluation is always a sequence, but the
application can directly request a value out of the sequence in the API.

As provided, the structure already provides either single values or
sequences of them, depending upon the request code.  It does not have
to do with whether the XPath result is singleton, but rather whether
the application only wants to force computation of a single value.

To properly call the structure a sequence, it would be necessary to
have two different result structures, one for the convenience and one
for the sequence, such as

XPath2Sequence

and

XPath2Value

To avoid significant redundancy, this might  require XPath2Sequence to
return a XPath2Value object.

It is interesting to entertain that possibility.  When we entertained it
before, it was for consideration of XPath 1, which had no sequence
standardized and added lots of overhead for inherently-simple results.

Even with XPath2, it seems to me it would force significant additional
allocation.  As written today, there is nothing in the API that forces
any additional allocations of objects defined by the API -- the same
result object can be used for the sequences and the values within the
sequences.  I do not consider this a big deal, but there have been a
number of implementers giving feedback who do care about it, which is
why the 1.0 result object looks like it does today.

It also may force another level of indirection for users, which may
require the user to set up a variable to hold the resulting value object
while he accesses multiple firlds of it.  In Java, given the current
requirement to cast the result object, this heaps more indirection on
the user.  In ECMAScript, it makes it more difficult to access the
results in a single line, etc.  This was also previously a concern
with this approach.

I can supply examples if you cannot picture what I am talking about.

Ray



