docno="lists-104-5005182"
received="Tue Apr  2 19:59:10 2002"
isoreceived="20020403005910"
sent="Tue, 2 Apr 2002 18:58:52 -0600"
isosent="20020403005852"
name="Curt Arnold"
email="carnold@houston.rr.com"
subject="Re: XPath DOM and XPath 2.0"
id="001501c1daaa$b8eefc90$a800a8c0@CurtMicron"
charset="iso-8859-1"
inreplyto="1017792125.6619.59.camel&#64;jfouffa"
expires="-1"


To:<www-dom@w3.org>

Philippe Le Hegaret wrote:
> One solution would be to request the type in the XPath expression
> itself:
>
> evaluate(".//h1") returns
>  XPathResult.XPathSequenceResult

I don't have any problems with pushing any type coersion operations up into
the XPath query itself.  I think I suggested it myself a few times, just
didn't remember it this time.

> evaluate(".//h1[1]") returns
>  XPathResult.XPathSingletonResult(nodeValue)

I'm not sure about this, You would not want the result type changing based
on the number of nodes that matched a query and this is just a special case
of a query that never matches more than one node.  I think you've got to
flag that you want only a node and not a sequence outside of the query.

> Agree with the approach of valueTypeNamespaceURI/valueTypeLocalName.
> However, I still note that this solution forces the implementation to
> encapsulate the Nodes into XPathResult objects in case of a node set.

Yep.  To do otherwise, I'd think you'd have to have one pair of
snapshotItem/iterateNext for nodes and one for atomic values.



